/*!
* svelte-dialogs v1.2.2
* Released under the MIT License.
*/
"undefined" != typeof document && function (e, t) {
  var n = e.createElement("style");
  if (e.getElementsByTagName("head")[0].appendChild(n), n.styleSheet) n.styleSheet.disabled || (n.styleSheet.cssText = t);else try {
    n.innerHTML = t;
  } catch (e) {
    n.innerText = t;
  }
}(document, "@charset \"UTF-8\";\n" + ".dialog__overlay {\n" + "  z-index: 1000;\n" + "  background: rgba(128, 128, 128, 0.5);\n" + "  position: fixed;\n" + "  top: 0;\n" + "  left: 0;\n" + "  width: 100vw;\n" + "  height: 100vh;\n" + "  display: flex;\n" + "  justify-content: center;\n" + "  align-items: center;\n" + "}\n" + "\n" + ".dialog__container {\n" + "  z-index: 1010;\n" + "  position: fixed;\n" + "  box-sizing: border-box;\n" + "  max-height: 100vh;\n" + "  min-width: 25vw;\n" + "  max-width: 50vw;\n" + "  padding: 2rem;\n" + "  border-radius: 1rem;\n" + "  background-color: #fff;\n" + "}\n" + "@media (max-width: 640px) {\n" + "  .dialog__container {\n" + "    max-width: 75vw;\n" + "  }\n" + "}\n" + "\n" + ".dialog__container--no-padding {\n" + "  padding: 0;\n" + "}\n" + "\n" + ".dialog__close-button {\n" + "  box-sizing: border-box;\n" + "  position: absolute;\n" + "  top: 0.5rem;\n" + "  right: 0.5rem;\n" + "  height: 1.5rem;\n" + "  width: 1.5rem;\n" + "  padding: 0;\n" + "  border: none;\n" + "  cursor: pointer;\n" + "  background: transparent;\n" + "  border-radius: 1rem;\n" + "  background: #cccccc;\n" + "}\n" + ".dialog__close-button:after {\n" + "  color: #fff;\n" + "  content: \"âœ•\";\n" + "}\n" + ".dialog__close-button:hover {\n" + "  background: rgba(202, 47, 63, 0.8);\n" + "}\n" + ".dialog__close-button:focus {\n" + "  background: rgba(202, 47, 63, 0.8);\n" + "}\n" + "\n" + ".dialog__header {\n" + "  text-align: center;\n" + "}\n" + "\n" + ".dialog__header--error {\n" + "  padding: 2rem 2rem 0 2rem;\n" + "  border-radius: 1rem 1rem 0 0;\n" + "  color: #fff;\n" + "  background-color: #ca2f3f;\n" + "}\n" + "\n" + ".dialog__header--success {\n" + "  padding: 2rem 2rem 0 2rem;\n" + "  border-radius: 1rem 1rem 0 0;\n" + "  color: #fff;\n" + "  background-color: #6ea050;\n" + "}\n" + "\n" + ".dialog__header--warning {\n" + "  padding: 2rem 2rem 0 2rem;\n" + "  border-radius: 1rem 1rem 0 0;\n" + "  color: #fff;\n" + "  background-color: #f0be00;\n" + "}\n" + "\n" + ".dialog__title {\n" + "  font-size: large;\n" + "  font-weight: bold;\n" + "  line-height: 1.5;\n" + "  margin: 0;\n" + "}\n" + "\n" + ".dialog__title--xx-large {\n" + "  font-size: xx-large;\n" + "}\n" + "\n" + ".dialog-content__divider {\n" + "  border: 1px solid #808080;\n" + "}\n" + "\n" + ".dialog__body {\n" + "  box-sizing: border-box;\n" + "  text-align: center;\n" + "  padding-top: 1rem;\n" + "  min-height: 10vh;\n" + "  max-height: calc(100vh - 13rem);\n" + "  overflow-y: auto;\n" + "}\n" + ".dialog__body::-webkit-scrollbar {\n" + "  width: 5px;\n" + "}\n" + ".dialog__body::-webkit-scrollbar-track {\n" + "  box-shadow: inset 0 0 5px rgba(204, 204, 204, 0.8);\n" + "  border-radius: 10px;\n" + "}\n" + ".dialog__body::-webkit-scrollbar-thumb {\n" + "  box-shadow: inset 0 0 5px #cccccc;\n" + "  border-radius: 10px;\n" + "}\n" + "\n" + ".dialog__body--contextual {\n" + "  padding: 0 2rem;\n" + "}\n" + "\n" + ".dialog__footer {\n" + "  margin-top: 1rem;\n" + "  display: flex;\n" + "}\n" + "\n" + ".dialog__footer--contextual {\n" + "  padding: 0 2rem 2rem 2rem;\n" + "}\n" + "\n" + ".dialog__footer--space-evenly {\n" + "  justify-content: space-evenly;\n" + "}\n" + "\n" + ".dialog__footer--space-between {\n" + "  justify-content: space-between;\n" + "}\n" + "\n" + ".dialog__footer--mobile-responsive {\n" + "  flex-direction: row;\n" + "}\n" + "@media (max-width: 640px) {\n" + "  .dialog__footer--mobile-responsive {\n" + "    flex-direction: column;\n" + "  }\n" + "  .dialog__footer--mobile-responsive .dialog__button-container {\n" + "    display: flex;\n" + "    justify-content: space-between;\n" + "  }\n" + "  .dialog__footer--mobile-responsive .dialog__button-container .dialog__button {\n" + "    flex-grow: 1;\n" + "  }\n" + "}\n" + "\n" + ".dialog__form.touched .dialog__input:invalid {\n" + "  border: 2px solid rgba(202, 47, 63, 0.5);\n" + "  outline: 0;\n" + "}\n" + ".dialog__form.touched .dialog__input:invalid:focus, .dialog__form.touched .dialog__input:invalid:focus-visible {\n" + "  border: 2px solid #ca2f3f;\n" + "  outline: 0;\n" + "}\n" + "\n" + ".dialog__form-element fieldset {\n" + "  box-sizing: border-box;\n" + "  margin: 8px 0 0 0;\n" + "  width: 100%;\n" + "  padding: 1rem;\n" + "  background-color: #fff;\n" + "  border: 2px solid #cccccc;\n" + "  border-radius: 1rem;\n" + "}\n" + ".dialog__form-element fieldset legend {\n" + "  display: block;\n" + "  width: -webkit-fit-content;\n" + "  width: -moz-fit-content;\n" + "  width: fit-content;\n" + "  text-align: left;\n" + "  position: relative;\n" + "  padding: 0 5px;\n" + "  background: #fff;\n" + "}\n" + "\n" + ".dialog__input-label {\n" + "  display: block;\n" + "  width: -webkit-fit-content;\n" + "  width: -moz-fit-content;\n" + "  width: fit-content;\n" + "  margin-left: 1rem;\n" + "  text-align: left;\n" + "  position: relative;\n" + "  top: 8px;\n" + "  padding: 0 5px;\n" + "  background: #fff;\n" + "}\n" + "\n" + "select.dialog__input[multiple],\n" + "textarea.dialog__input {\n" + "  overflow-y: auto;\n" + "  direction: rtl;\n" + "  text-align: left;\n" + "}\n" + "select.dialog__input[multiple]::-webkit-scrollbar,\n" + "textarea.dialog__input::-webkit-scrollbar {\n" + "  width: 5px;\n" + "}\n" + "select.dialog__input[multiple]::-webkit-scrollbar-track,\n" + "textarea.dialog__input::-webkit-scrollbar-track {\n" + "  box-shadow: inset 0 0 5px rgba(204, 204, 204, 0.8);\n" + "  border-radius: 10px;\n" + "}\n" + "select.dialog__input[multiple]::-webkit-scrollbar-thumb,\n" + "textarea.dialog__input::-webkit-scrollbar-thumb {\n" + "  box-shadow: inset 0 0 5px #cccccc;\n" + "  border-radius: 10px;\n" + "}\n" + "select.dialog__input[multiple]::-webkit-scrollbar-track,\n" + "textarea.dialog__input::-webkit-scrollbar-track {\n" + "  margin: 5px;\n" + "}\n" + "select.dialog__input[multiple] option,\n" + "textarea.dialog__input option {\n" + "  direction: ltr;\n" + "}\n" + "\n" + ".dialog__input {\n" + "  box-sizing: border-box;\n" + "  margin: 0;\n" + "}\n" + ".dialog__input:not([type=checkbox]):not([type=radio]) {\n" + "  width: 100%;\n" + "  padding: 1rem;\n" + "  background-color: #fff;\n" + "  border: 2px solid #cccccc;\n" + "  border-radius: 1rem;\n" + "}\n" + ".dialog__input[type=checkbox], .dialog__input[type=radio] {\n" + "  width: auto;\n" + "  display: block;\n" + "  margin-top: -7px;\n" + "  text-align: left;\n" + "}\n" + ".dialog__input[type=color] {\n" + "  min-height: 3.5rem;\n" + "}\n" + ".dialog__input[type=range] {\n" + "  padding: 1rem 0;\n" + "}\n" + ".dialog__input[type=file]::-webkit-file-upload-button {\n" + "  display: none;\n" + "}\n" + ".dialog__input[type=file]::file-selector-button {\n" + "  display: none;\n" + "}\n" + ".dialog__input:focus:not(:invalid) {\n" + "  border: 2px solid #333;\n" + "}\n" + "\n" + ".dialog__button {\n" + "  box-sizing: border-box;\n" + "  display: inline-block;\n" + "  cursor: pointer;\n" + "  font-size: 1rem;\n" + "  padding: 0.5rem;\n" + "  margin: 2px;\n" + "  min-width: 6rem;\n" + "  text-align: center;\n" + "  white-space: nowrap;\n" + "  vertical-align: middle;\n" + "  -webkit-user-select: none;\n" + "     -moz-user-select: none;\n" + "          user-select: none;\n" + "  border: 0.1rem solid transparent;\n" + "  border-radius: 0.5rem;\n" + "}\n" + ".dialog__button:disabled {\n" + "  cursor: default;\n" + "  opacity: 0.5;\n" + "}\n" + ".dialog__button:focus {\n" + "  border: 0.1rem solid transparent;\n" + "}\n" + "\n" + ".dialog__button--primary {\n" + "  background-color: #cccccc;\n" + "}\n" + ".dialog__button--primary:hover {\n" + "  background-color: rgba(204, 204, 204, 0.8);\n" + "}\n" + ".dialog__button--primary:not(:disabled):active {\n" + "  background-color: #cccccc;\n" + "}\n" + ".dialog__button--primary:focus {\n" + "  box-shadow: 0 0 0 3px rgba(204, 204, 204, 0.5);\n" + "}\n" + "\n" + ".dialog__button--decline {\n" + "  background-color: #ca2f3f;\n" + "  color: #fff;\n" + "}\n" + ".dialog__button--decline:hover {\n" + "  background-color: rgba(202, 47, 63, 0.8);\n" + "}\n" + ".dialog__button--decline:not(:disabled):active {\n" + "  background-color: #ca2f3f;\n" + "}\n" + ".dialog__button--decline:focus {\n" + "  box-shadow: 0 0 0 3px rgba(202, 47, 63, 0.5);\n" + "}\n" + "\n" + ".dialog__button--error {\n" + "  background-color: #ca2f3f;\n" + "  color: #fff;\n" + "}\n" + ".dialog__button--error:hover {\n" + "  background-color: rgba(202, 47, 63, 0.8);\n" + "}\n" + ".dialog__button--error:not(:disabled):active {\n" + "  background-color: #ca2f3f;\n" + "}\n" + ".dialog__button--error:focus {\n" + "  box-shadow: 0 0 0 3px rgba(202, 47, 63, 0.5);\n" + "}\n" + "\n" + ".dialog__button--success {\n" + "  background-color: #6ea050;\n" + "  color: #fff;\n" + "}\n" + ".dialog__button--success:hover {\n" + "  background-color: rgba(110, 160, 80, 0.8);\n" + "}\n" + ".dialog__button--success:not(:disabled):active {\n" + "  background-color: #6ea050;\n" + "}\n" + ".dialog__button--success:focus {\n" + "  box-shadow: 0 0 0 3px rgba(110, 160, 80, 0.5);\n" + "}\n" + "\n" + ".dialog__button--warning {\n" + "  background-color: #f0be00;\n" + "  color: #fff;\n" + "}\n" + ".dialog__button--warning:hover {\n" + "  background-color: rgba(240, 190, 0, 0.8);\n" + "}\n" + ".dialog__button--warning:not(:disabled):active {\n" + "  background-color: #f0be00;\n" + "}\n" + ".dialog__button--warning:focus {\n" + "  box-shadow: 0 0 0 3px rgba(240, 190, 0, 0.5);\n" + "}");

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function noop() {}

var identity = function identity(x) {
  return x;
};

function assign(tar, src) {
  // @ts-ignore
  for (var k in src) {
    tar[k] = src[k];
  }

  return tar;
}

function run(fn) {
  return fn();
}

function blank_object() {
  return Object.create(null);
}

function run_all(fns) {
  fns.forEach(run);
}

function is_function(thing) {
  return typeof thing === 'function';
}

function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';
}

function is_empty(obj) {
  return Object.keys(obj).length === 0;
}

function subscribe(store) {
  if (store == null) {
    return noop;
  }

  for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    callbacks[_key - 1] = arguments[_key];
  }

  var unsub = store.subscribe.apply(store, callbacks);
  return unsub.unsubscribe ? function () {
    return unsub.unsubscribe();
  } : unsub;
}

function get_store_value(store) {
  var value;
  subscribe(store, function (_) {
    return value = _;
  })();
  return value;
}

function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}

function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    var slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}

function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}

function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    var lets = definition[2](fn(dirty));

    if ($$scope.dirty === undefined) {
      return lets;
    }

    if (_typeof(lets) === 'object') {
      var merged = [];
      var len = Math.max($$scope.dirty.length, lets.length);

      for (var i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }

      return merged;
    }

    return $$scope.dirty | lets;
  }

  return $$scope.dirty;
}

function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    var slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}

function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    var dirty = [];
    var length = $$scope.ctx.length / 32;

    for (var i = 0; i < length; i++) {
      dirty[i] = -1;
    }

    return dirty;
  }

  return -1;
}

function exclude_internal_props(props) {
  var result = {};

  for (var k in props) {
    if (k[0] !== '$') result[k] = props[k];
  }

  return result;
}

function compute_rest_props(props, keys) {
  var rest = {};
  keys = new Set(keys);

  for (var k in props) {
    if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];
  }

  return rest;
}

function compute_slots(slots) {
  var result = {};

  for (var key in slots) {
    result[key] = true;
  }

  return result;
}

function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

var is_client = typeof window !== 'undefined';
var now = is_client ? function () {
  return window.performance.now();
} : function () {
  return Date.now();
};
var raf = is_client ? function (cb) {
  return requestAnimationFrame(cb);
} : noop; // used internally for testing

var tasks = new Set();

function run_tasks(now) {
  tasks.forEach(function (task) {
    if (!task.c(now)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0) raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */


function loop(callback) {
  var task;
  if (tasks.size === 0) raf(run_tasks);
  return {
    promise: new Promise(function (fulfill) {
      tasks.add(task = {
        c: callback,
        f: fulfill
      });
    }),
    abort: function abort() {
      tasks.delete(task);
    }
  };
} // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM

function append(target, node) {
  target.appendChild(node);
}

function get_root_for_style(node) {
  if (!node) return document;
  var root = node.getRootNode ? node.getRootNode() : node.ownerDocument;

  if (root && root.host) {
    return root;
  }

  return node.ownerDocument;
}

function append_empty_stylesheet(node) {
  var style_element = element('style');
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}

function append_stylesheet(node, style) {
  append(node.head || node, style);
}

function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}

function detach(node) {
  node.parentNode.removeChild(node);
}

function destroy_each(iterations, detaching) {
  for (var i = 0; i < iterations.length; i += 1) {
    if (iterations[i]) iterations[i].d(detaching);
  }
}

function element(name) {
  return document.createElement(name);
}

function svg_element(name) {
  return document.createElementNS('http://www.w3.org/2000/svg', name);
}

function text(data) {
  return document.createTextNode(data);
}

function space() {
  return text(' ');
}

function empty() {
  return text('');
}

function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return function () {
    return node.removeEventListener(event, handler, options);
  };
}

function prevent_default(fn) {
  return function (event) {
    event.preventDefault(); // @ts-ignore

    return fn.call(this, event);
  };
}

function attr(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}

function set_attributes(node, attributes) {
  // @ts-ignore
  var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);

  for (var key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === 'style') {
      node.style.cssText = attributes[key];
    } else if (key === '__value') {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}

function children(element) {
  return Array.from(element.childNodes);
}

function set_data(text, data) {
  data = '' + data;
  if (text.wholeText !== data) text.data = data;
}

function set_input_value(input, value) {
  input.value = value == null ? '' : value;
}

function select_option(select, value) {
  for (var i = 0; i < select.options.length; i += 1) {
    var option = select.options[i];

    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }

  select.selectedIndex = -1; // no option should be selected
}

function select_options(select, value) {
  for (var i = 0; i < select.options.length; i += 1) {
    var option = select.options[i];
    option.selected = ~value.indexOf(option.__value);
  }
}

function select_value(select) {
  var selected_option = select.querySelector(':checked') || select.options[0];
  return selected_option && selected_option.__value;
}

function select_multiple_value(select) {
  return [].map.call(select.querySelectorAll(':checked'), function (option) {
    return option.__value;
  });
} // unfortunately this can't be a constant as that wouldn't be tree-shakeable

function toggle_class(element, name, toggle) {
  element.classList[toggle ? 'add' : 'remove'](name);
}

function custom_event(type, detail) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$bubbles = _ref.bubbles,
      bubbles = _ref$bubbles === void 0 ? false : _ref$bubbles,
      _ref$cancelable = _ref.cancelable,
      cancelable = _ref$cancelable === void 0 ? false : _ref$cancelable;

  var e = document.createEvent('CustomEvent');
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}

var HtmlTag = /*#__PURE__*/function () {
  function HtmlTag() {
    var is_svg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    _classCallCheck(this, HtmlTag);

    this.is_svg = false;
    this.is_svg = is_svg;
    this.e = this.n = null;
  }

  _createClass(HtmlTag, [{
    key: "c",
    value: function c(html) {
      this.h(html);
    }
  }, {
    key: "m",
    value: function m(html, target) {
      var anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (!this.e) {
        if (this.is_svg) this.e = svg_element(target.nodeName);else this.e = element(target.nodeName);
        this.t = target;
        this.c(html);
      }

      this.i(anchor);
    }
  }, {
    key: "h",
    value: function h(html) {
      this.e.innerHTML = html;
      this.n = Array.from(this.e.childNodes);
    }
  }, {
    key: "i",
    value: function i(anchor) {
      for (var i = 0; i < this.n.length; i += 1) {
        insert(this.t, this.n[i], anchor);
      }
    }
  }, {
    key: "p",
    value: function p(html) {
      this.d();
      this.h(html);
      this.i(this.a);
    }
  }, {
    key: "d",
    value: function d() {
      this.n.forEach(detach);
    }
  }]);

  return HtmlTag;
}();
// https://github.com/sveltejs/svelte/issues/3624


var managed_styles = new Map();
var active = 0; // https://github.com/darkskyapp/string-hash/blob/master/index.js

function hash(str) {
  var hash = 5381;
  var i = str.length;

  while (i--) {
    hash = (hash << 5) - hash ^ str.charCodeAt(i);
  }

  return hash >>> 0;
}

function create_style_information(doc, node) {
  var info = {
    stylesheet: append_empty_stylesheet(node),
    rules: {}
  };
  managed_styles.set(doc, info);
  return info;
}

function create_rule(node, a, b, duration, delay, ease, fn) {
  var uid = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  var step = 16.666 / duration;
  var keyframes = '{\n';

  for (var p = 0; p <= 1; p += step) {
    var t = a + (b - a) * ease(p);
    keyframes += p * 100 + "%{".concat(fn(t, 1 - t), "}\n");
  }

  var rule = keyframes + "100% {".concat(fn(b, 1 - b), "}\n}");
  var name = "__svelte_".concat(hash(rule), "_").concat(uid);
  var doc = get_root_for_style(node);

  var _ref2 = managed_styles.get(doc) || create_style_information(doc, node),
      stylesheet = _ref2.stylesheet,
      rules = _ref2.rules;

  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule("@keyframes ".concat(name, " ").concat(rule), stylesheet.cssRules.length);
  }

  var animation = node.style.animation || '';
  node.style.animation = "".concat(animation ? "".concat(animation, ", ") : '').concat(name, " ").concat(duration, "ms linear ").concat(delay, "ms 1 both");
  active += 1;
  return name;
}

function delete_rule(node, name) {
  var previous = (node.style.animation || '').split(', ');
  var next = previous.filter(name ? function (anim) {
    return anim.indexOf(name) < 0;
  } // remove specific animation
  : function (anim) {
    return anim.indexOf('__svelte') === -1;
  } // remove all Svelte animations
  );
  var deleted = previous.length - next.length;

  if (deleted) {
    node.style.animation = next.join(', ');
    active -= deleted;
    if (!active) clear_rules();
  }
}

function clear_rules() {
  raf(function () {
    if (active) return;
    managed_styles.forEach(function (info) {
      var stylesheet = info.stylesheet;
      var i = stylesheet.cssRules.length;

      while (i--) {
        stylesheet.deleteRule(i);
      }

      info.rules = {};
    });
    managed_styles.clear();
  });
}

var current_component;

function set_current_component(component) {
  current_component = component;
}

function get_current_component() {
  if (!current_component) throw new Error('Function called outside component initialization');
  return current_component;
}

function createEventDispatcher() {
  var component = get_current_component();
  return function (type, detail) {
    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref3$cancelable = _ref3.cancelable,
        cancelable = _ref3$cancelable === void 0 ? false : _ref3$cancelable;

    var callbacks = component.$$.callbacks[type];

    if (callbacks) {
      // TODO are there situations where events could be dispatched
      // in a server (non-DOM) environment?
      var event = custom_event(type, detail, {
        cancelable: cancelable
      });
      callbacks.slice().forEach(function (fn) {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }

    return true;
  };
}

function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}

function getContext(key) {
  return get_current_component().$$.context.get(key);
}
// shorthand events, or if we want to implement
// a real bubbling mechanism


function bubble(component, event) {
  var _this2 = this;

  var callbacks = component.$$.callbacks[event.type];

  if (callbacks) {
    // @ts-ignore
    callbacks.slice().forEach(function (fn) {
      return fn.call(_this2, event);
    });
  }
}

var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;

function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}

function add_render_callback(fn) {
  render_callbacks.push(fn);
}

function add_flush_callback(fn) {
  flush_callbacks.push(fn);
} // flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.


var seen_callbacks = new Set();
var flushidx = 0; // Do *not* move this inside the flush() function

function flush() {
  var saved_component = current_component;

  do {
    // first, call beforeUpdate functions
    // and update components
    while (flushidx < dirty_components.length) {
      var component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }

    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;

    while (binding_callbacks.length) {
      binding_callbacks.pop()();
    } // then, once components are updated, call
    // afterUpdate functions. This may cause
    // subsequent updates...


    for (var i = 0; i < render_callbacks.length; i += 1) {
      var callback = render_callbacks[i];

      if (!seen_callbacks.has(callback)) {
        // ...so guard against infinite loops
        seen_callbacks.add(callback);
        callback();
      }
    }

    render_callbacks.length = 0;
  } while (dirty_components.length);

  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }

  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}

function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    var dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}

var promise;

function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(function () {
      promise = null;
    });
  }

  return promise;
}

function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event("".concat(direction ? 'intro' : 'outro').concat(kind)));
}

var outroing = new Set();
var outros;

function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros // parent group

  };
}

function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }

  outros = outros.p;
}

function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}

function transition_out(block, local, detach, callback) {
  if (block && block.o) {
    if (outroing.has(block)) return;
    outroing.add(block);
    outros.c.push(function () {
      outroing.delete(block);

      if (callback) {
        if (detach) block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}

var null_transition = {
  duration: 0
};

function create_in_transition(node, fn, params) {
  var config = fn(node, params);
  var running = false;
  var animation_name;
  var task;
  var uid = 0;

  function cleanup() {
    if (animation_name) delete_rule(node, animation_name);
  }

  function go() {
    var _ref4 = config || null_transition,
        _ref4$delay = _ref4.delay,
        delay = _ref4$delay === void 0 ? 0 : _ref4$delay,
        _ref4$duration = _ref4.duration,
        duration = _ref4$duration === void 0 ? 300 : _ref4$duration,
        _ref4$easing = _ref4.easing,
        easing = _ref4$easing === void 0 ? identity : _ref4$easing,
        _ref4$tick = _ref4.tick,
        tick = _ref4$tick === void 0 ? noop : _ref4$tick,
        css = _ref4.css;

    if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
    tick(0, 1);
    var start_time = now() + delay;
    var end_time = start_time + duration;
    if (task) task.abort();
    running = true;
    add_render_callback(function () {
      return dispatch(node, true, 'start');
    });
    task = loop(function (now) {
      if (running) {
        if (now >= end_time) {
          tick(1, 0);
          dispatch(node, true, 'end');
          cleanup();
          return running = false;
        }

        if (now >= start_time) {
          var t = easing((now - start_time) / duration);
          tick(t, 1 - t);
        }
      }

      return running;
    });
  }

  var started = false;
  return {
    start: function start() {
      if (started) return;
      started = true;
      delete_rule(node);

      if (is_function(config)) {
        config = config();
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate: function invalidate() {
      started = false;
    },
    end: function end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}

function create_out_transition(node, fn, params) {
  var config = fn(node, params);
  var running = true;
  var animation_name;
  var group = outros;
  group.r += 1;

  function go() {
    var _ref5 = config || null_transition,
        _ref5$delay = _ref5.delay,
        delay = _ref5$delay === void 0 ? 0 : _ref5$delay,
        _ref5$duration = _ref5.duration,
        duration = _ref5$duration === void 0 ? 300 : _ref5$duration,
        _ref5$easing = _ref5.easing,
        easing = _ref5$easing === void 0 ? identity : _ref5$easing,
        _ref5$tick = _ref5.tick,
        tick = _ref5$tick === void 0 ? noop : _ref5$tick,
        css = _ref5.css;

    if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
    var start_time = now() + delay;
    var end_time = start_time + duration;
    add_render_callback(function () {
      return dispatch(node, false, 'start');
    });
    loop(function (now) {
      if (running) {
        if (now >= end_time) {
          tick(0, 1);
          dispatch(node, false, 'end');

          if (! --group.r) {
            // this will result in `end()` being called,
            // so we don't need to clean up here
            run_all(group.c);
          }

          return false;
        }

        if (now >= start_time) {
          var t = easing((now - start_time) / duration);
          tick(1 - t, t);
        }
      }

      return running;
    });
  }

  if (is_function(config)) {
    wait().then(function () {
      // @ts-ignore
      config = config();
      go();
    });
  } else {
    go();
  }

  return {
    end: function end(reset) {
      if (reset && config.tick) {
        config.tick(1, 0);
      }

      if (running) {
        if (animation_name) delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}

function get_spread_update(levels, updates) {
  var update = {};
  var to_null_out = {};
  var accounted_for = {
    $$scope: 1
  };
  var i = levels.length;

  while (i--) {
    var o = levels[i];
    var n = updates[i];

    if (n) {
      for (var key in o) {
        if (!(key in n)) to_null_out[key] = 1;
      }

      for (var _key3 in n) {
        if (!accounted_for[_key3]) {
          update[_key3] = n[_key3];
          accounted_for[_key3] = 1;
        }
      }

      levels[i] = n;
    } else {
      for (var _key4 in o) {
        accounted_for[_key4] = 1;
      }
    }
  }

  for (var _key5 in to_null_out) {
    if (!(_key5 in update)) update[_key5] = undefined;
  }

  return update;
}

function get_spread_object(spread_props) {
  return _typeof(spread_props) === 'object' && spread_props !== null ? spread_props : {};
} // source: https://html.spec.whatwg.org/multipage/indices.html

function bind(component, name, callback) {
  var index = component.$$.props[name];

  if (index !== undefined) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}

function create_component(block) {
  block && block.c();
}

function mount_component(component, target, anchor, customElement) {
  var _component$$$ = component.$$,
      fragment = _component$$$.fragment,
      on_mount = _component$$$.on_mount,
      on_destroy = _component$$$.on_destroy,
      after_update = _component$$$.after_update;
  fragment && fragment.m(target, anchor);

  if (!customElement) {
    // onMount happens before the initial afterUpdate
    add_render_callback(function () {
      var new_on_destroy = on_mount.map(run).filter(is_function);

      if (on_destroy) {
        on_destroy.push.apply(on_destroy, _toConsumableArray(new_on_destroy));
      } else {
        // Edge case - component was destroyed immediately,
        // most likely as a result of a binding initialising
        run_all(new_on_destroy);
      }

      component.$$.on_mount = [];
    });
  }

  after_update.forEach(add_render_callback);
}

function destroy_component(component, detaching) {
  var $$ = component.$$;

  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to
    // preserve final state?)

    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}

function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }

  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}

function init(component, options, instance, create_fragment, not_equal, props, append_styles) {
  var dirty = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [-1];
  var parent_component = current_component;
  set_current_component(component);
  var $$ = component.$$ = {
    fragment: null,
    ctx: null,
    // state
    props: props,
    update: noop,
    not_equal: not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty: dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  var ready = false;
  $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {
    var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;

    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
      if (ready) make_dirty(component, i);
    }

    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update); // `false` as a special case of no DOM component

  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;

  if (options.target) {
    if (options.hydrate) {
      var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      $$.fragment && $$.fragment.c();
    }

    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    flush();
  }

  set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */


var SvelteComponent = /*#__PURE__*/function () {
  function SvelteComponent() {
    _classCallCheck(this, SvelteComponent);
  }

  _createClass(SvelteComponent, [{
    key: "$destroy",
    value: function $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
  }, {
    key: "$on",
    value: function $on(type, callback) {
      var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return function () {
        var index = callbacks.indexOf(callback);
        if (index !== -1) callbacks.splice(index, 1);
      };
    }
  }, {
    key: "$set",
    value: function $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  }]);

  return SvelteComponent;
}();

function cubicInOut(t) {
  return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
}

function cubicOut(t) {
  var f = t - 1.0;
  return f * f * f + 1.0;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function blur(node) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$delay = _ref.delay,
      delay = _ref$delay === void 0 ? 0 : _ref$delay,
      _ref$duration = _ref.duration,
      duration = _ref$duration === void 0 ? 400 : _ref$duration,
      _ref$easing = _ref.easing,
      easing = _ref$easing === void 0 ? cubicInOut : _ref$easing,
      _ref$amount = _ref.amount,
      amount = _ref$amount === void 0 ? 5 : _ref$amount,
      _ref$opacity = _ref.opacity,
      opacity = _ref$opacity === void 0 ? 0 : _ref$opacity;

  var style = getComputedStyle(node);
  var target_opacity = +style.opacity;
  var f = style.filter === 'none' ? '' : style.filter;
  var od = target_opacity * (1 - opacity);
  return {
    delay: delay,
    duration: duration,
    easing: easing,
    css: function css(_t, u) {
      return "opacity: ".concat(target_opacity - od * u, "; filter: ").concat(f, " blur(").concat(u * amount, "px);");
    }
  };
}

function fade(node) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$delay = _ref2.delay,
      delay = _ref2$delay === void 0 ? 0 : _ref2$delay,
      _ref2$duration = _ref2.duration,
      duration = _ref2$duration === void 0 ? 400 : _ref2$duration,
      _ref2$easing = _ref2.easing,
      easing = _ref2$easing === void 0 ? identity : _ref2$easing;

  var o = +getComputedStyle(node).opacity;
  return {
    delay: delay,
    duration: duration,
    easing: easing,
    css: function css(t) {
      return "opacity: ".concat(t * o);
    }
  };
}

function fly(node) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$delay = _ref3.delay,
      delay = _ref3$delay === void 0 ? 0 : _ref3$delay,
      _ref3$duration = _ref3.duration,
      duration = _ref3$duration === void 0 ? 400 : _ref3$duration,
      _ref3$easing = _ref3.easing,
      easing = _ref3$easing === void 0 ? cubicOut : _ref3$easing,
      _ref3$x = _ref3.x,
      x = _ref3$x === void 0 ? 0 : _ref3$x,
      _ref3$y = _ref3.y,
      y = _ref3$y === void 0 ? 0 : _ref3$y,
      _ref3$opacity = _ref3.opacity,
      opacity = _ref3$opacity === void 0 ? 0 : _ref3$opacity;

  var style = getComputedStyle(node);
  var target_opacity = +style.opacity;
  var transform = style.transform === 'none' ? '' : style.transform;
  var od = target_opacity * (1 - opacity);
  return {
    delay: delay,
    duration: duration,
    easing: easing,
    css: function css(t, u) {
      return "\n\t\t\ttransform: ".concat(transform, " translate(").concat((1 - t) * x, "px, ").concat((1 - t) * y, "px);\n\t\t\topacity: ").concat(target_opacity - od * u);
    }
  };
}

function slide(node) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref4$delay = _ref4.delay,
      delay = _ref4$delay === void 0 ? 0 : _ref4$delay,
      _ref4$duration = _ref4.duration,
      duration = _ref4$duration === void 0 ? 400 : _ref4$duration,
      _ref4$easing = _ref4.easing,
      easing = _ref4$easing === void 0 ? cubicOut : _ref4$easing;

  var style = getComputedStyle(node);
  var opacity = +style.opacity;
  var height = parseFloat(style.height);
  var padding_top = parseFloat(style.paddingTop);
  var padding_bottom = parseFloat(style.paddingBottom);
  var margin_top = parseFloat(style.marginTop);
  var margin_bottom = parseFloat(style.marginBottom);
  var border_top_width = parseFloat(style.borderTopWidth);
  var border_bottom_width = parseFloat(style.borderBottomWidth);
  return {
    delay: delay,
    duration: duration,
    easing: easing,
    css: function css(t) {
      return 'overflow: hidden;' + "opacity: ".concat(Math.min(t * 20, 1) * opacity, ";") + "height: ".concat(t * height, "px;") + "padding-top: ".concat(t * padding_top, "px;") + "padding-bottom: ".concat(t * padding_bottom, "px;") + "margin-top: ".concat(t * margin_top, "px;") + "margin-bottom: ".concat(t * margin_bottom, "px;") + "border-top-width: ".concat(t * border_top_width, "px;") + "border-bottom-width: ".concat(t * border_bottom_width, "px;");
    }
  };
}

function scale(node) {
  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref5$delay = _ref5.delay,
      delay = _ref5$delay === void 0 ? 0 : _ref5$delay,
      _ref5$duration = _ref5.duration,
      duration = _ref5$duration === void 0 ? 400 : _ref5$duration,
      _ref5$easing = _ref5.easing,
      easing = _ref5$easing === void 0 ? cubicOut : _ref5$easing,
      _ref5$start = _ref5.start,
      start = _ref5$start === void 0 ? 0 : _ref5$start,
      _ref5$opacity = _ref5.opacity,
      opacity = _ref5$opacity === void 0 ? 0 : _ref5$opacity;

  var style = getComputedStyle(node);
  var target_opacity = +style.opacity;
  var transform = style.transform === 'none' ? '' : style.transform;
  var sd = 1 - start;
  var od = target_opacity * (1 - opacity);
  return {
    delay: delay,
    duration: duration,
    easing: easing,
    css: function css(_t, u) {
      return "\n\t\t\ttransform: ".concat(transform, " scale(").concat(1 - sd * u, ");\n\t\t\topacity: ").concat(target_opacity - od * u, "\n\t\t");
    }
  };
}

function draw(node) {
  var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref6$delay = _ref6.delay,
      delay = _ref6$delay === void 0 ? 0 : _ref6$delay,
      speed = _ref6.speed,
      duration = _ref6.duration,
      _ref6$easing = _ref6.easing,
      easing = _ref6$easing === void 0 ? cubicInOut : _ref6$easing;

  var len = node.getTotalLength();
  var style = getComputedStyle(node);

  if (style.strokeLinecap !== 'butt') {
    len += parseInt(style.strokeWidth);
  }

  if (duration === undefined) {
    if (speed === undefined) {
      duration = 800;
    } else {
      duration = len / speed;
    }
  } else if (typeof duration === 'function') {
    duration = duration(len);
  }

  return {
    delay: delay,
    duration: duration,
    easing: easing,
    css: function css(t, u) {
      return "stroke-dasharray: ".concat(t * len, " ").concat(u * len);
    }
  };
}

function crossfade(_a) {
  var fallback = _a.fallback,
      defaults = __rest(_a, ["fallback"]);

  var to_receive = new Map();
  var to_send = new Map();

  function crossfade(from, node, params) {
    var _assign = assign(assign({}, defaults), params),
        _assign$delay = _assign.delay,
        delay = _assign$delay === void 0 ? 0 : _assign$delay,
        _assign$duration = _assign.duration,
        duration = _assign$duration === void 0 ? function (d) {
      return Math.sqrt(d) * 30;
    } : _assign$duration,
        _assign$easing = _assign.easing,
        easing = _assign$easing === void 0 ? cubicOut : _assign$easing;

    var to = node.getBoundingClientRect();
    var dx = from.left - to.left;
    var dy = from.top - to.top;
    var dw = from.width / to.width;
    var dh = from.height / to.height;
    var d = Math.sqrt(dx * dx + dy * dy);
    var style = getComputedStyle(node);
    var transform = style.transform === 'none' ? '' : style.transform;
    var opacity = +style.opacity;
    return {
      delay: delay,
      duration: is_function(duration) ? duration(d) : duration,
      easing: easing,
      css: function css(t, u) {
        return "\n\t\t\t\topacity: ".concat(t * opacity, ";\n\t\t\t\ttransform-origin: top left;\n\t\t\t\ttransform: ").concat(transform, " translate(").concat(u * dx, "px,").concat(u * dy, "px) scale(").concat(t + (1 - t) * dw, ", ").concat(t + (1 - t) * dh, ");\n\t\t\t");
      }
    };
  }

  function transition(items, counterparts, intro) {
    return function (node, params) {
      items.set(params.key, {
        rect: node.getBoundingClientRect()
      });
      return function () {
        if (counterparts.has(params.key)) {
          var _counterparts$get = counterparts.get(params.key),
              rect = _counterparts$get.rect;

          counterparts.delete(params.key);
          return crossfade(rect, node, params);
        } // if the node is disappearing altogether
        // (i.e. wasn't claimed by the other list)
        // then we need to supply an outro


        items.delete(params.key);
        return fallback && fallback(node, params, intro);
      };
    };
  }

  return [transition(to_send, to_receive, false), transition(to_receive, to_send, true)];
}

var svelteTransitions = /*#__PURE__*/Object.freeze({
  __proto__: null,
  blur: blur,
  crossfade: crossfade,
  draw: draw,
  fade: fade,
  fly: fly,
  scale: scale,
  slide: slide
});

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
}

var closeSym = Symbol("close");
var optsSym = Symbol("opts");
/**
 *
 * @param {symbol} key - the key associated with the property stored in context
 * @returns {any} - the property sored in context
 * @throws {Error} - if called after component initialization
 */

var getFromContext = function getFromContext(key) {
  try {
    return getContext(key);
  } catch (cause) {
    throw new Error("Context element ".concat(key.description, " can be retrieved only on component initialization"), {
      cause: cause
    });
  }
};
/**
 * Retrieves the close function from context
 * @returns {function} - the close function stored in context
 */


var getClose = function getClose() {
  return getFromContext(closeSym);
};
/**
 * Put the close function in context
 * @param {function} close - the function to store in context
 * @returns {function} - the close function stored in context
 */

var setClose = function setClose(close) {
  return setContext(closeSym, close);
};
/**
 * Retrieves the options object from context
 * @returns {object} - the options object stored in context
 */

var getOptions = function getOptions() {
  return getFromContext(optsSym);
};
/**
 * Put the options object in context
 * @param {object} close - the object to store in context
 * @returns {object} - the options object stored in context
 */

var setOptions = function setOptions(opts) {
  return setContext(optsSym, opts);
};

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var get_footer_slot_changes = function get_footer_slot_changes(dirty) {
  return {};
};

var get_footer_slot_context = function get_footer_slot_context(ctx) {
  return {};
};

var get_body_slot_changes = function get_body_slot_changes(dirty) {
  return {};
};

var get_body_slot_context = function get_body_slot_context(ctx) {
  return {};
};

var get_header_slot_changes = function get_header_slot_changes(dirty) {
  return {};
};

var get_header_slot_context = function get_header_slot_context(ctx) {
  return {};
}; // (61:4) {#if title && ($$slots.body || text)}


function create_if_block_1$2(ctx) {
  var hr;
  return {
    c: function c() {
      hr = element("hr");
      attr(hr, "class",
      /*dividerClass*/
      ctx[5]);
      attr(hr, "data-testid", "dialog-content__divider");
    },
    m: function m(target, anchor) {
      insert(target, hr, anchor);
    },
    p: noop,
    d: function d(detaching) {
      if (detaching) detach(hr);
    }
  };
} // (57:22)      


function fallback_block_1(ctx) {
  var h2;
  var t;
  var if_block_anchor;
  var if_block =
  /*title*/
  ctx[3] && (
  /*$$slots*/
  ctx[8].body ||
  /*text*/
  ctx[4]) && create_if_block_1$2(ctx);
  return {
    c: function c() {
      h2 = element("h2");
      t = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      attr(h2, "id",
      /*titleId*/
      ctx[2]);
      attr(h2, "class",
      /*titleClass*/
      ctx[1]);
      attr(h2, "data-testid", "dialog-content__title");
    },
    m: function m(target, anchor) {
      insert(target, h2, anchor);
      h2.innerHTML =
      /*title*/
      ctx[3];
      insert(target, t, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p: function p(ctx, dirty) {
      if (
      /*title*/
      ctx[3] && (
      /*$$slots*/
      ctx[8].body ||
      /*text*/
      ctx[4])) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1$2(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function d(detaching) {
      if (detaching) detach(h2);
      if (detaching) detach(t);
      if (if_block) if_block.d(detaching);
      if (detaching) detach(if_block_anchor);
    }
  };
} // (67:0) {#if $$slots.body || text}


function create_if_block$4(ctx) {
  var div;
  var current;
  var body_slot_template =
  /*#slots*/
  ctx[10].body;
  var body_slot = create_slot(body_slot_template, ctx,
  /*$$scope*/
  ctx[9], get_body_slot_context);
  var body_slot_or_fallback = body_slot || fallback_block(ctx);
  return {
    c: function c() {
      div = element("div");
      if (body_slot_or_fallback) body_slot_or_fallback.c();
      attr(div, "class",
      /*bodyClass*/
      ctx[6]);
      attr(div, "data-testid", "dialog-content__body");
    },
    m: function m(target, anchor) {
      insert(target, div, anchor);

      if (body_slot_or_fallback) {
        body_slot_or_fallback.m(div, null);
      }

      current = true;
    },
    p: function p(ctx, dirty) {
      if (body_slot) {
        if (body_slot.p && (!current || dirty &
        /*$$scope*/
        512)) {
          update_slot_base(body_slot, body_slot_template, ctx,
          /*$$scope*/
          ctx[9], !current ? get_all_dirty_from_scope(
          /*$$scope*/
          ctx[9]) : get_slot_changes(body_slot_template,
          /*$$scope*/
          ctx[9], dirty, get_body_slot_changes), get_body_slot_context);
        }
      }
    },
    i: function i(local) {
      if (current) return;
      transition_in(body_slot_or_fallback, local);
      current = true;
    },
    o: function o(local) {
      transition_out(body_slot_or_fallback, local);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) detach(div);
      if (body_slot_or_fallback) body_slot_or_fallback.d(detaching);
    }
  };
} // (69:22) {@html text}


function fallback_block(ctx) {
  var html_tag;
  var html_anchor;
  return {
    c: function c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function m(target, anchor) {
      html_tag.m(
      /*text*/
      ctx[4], target, anchor);
      insert(target, html_anchor, anchor);
    },
    p: noop,
    d: function d(detaching) {
      if (detaching) detach(html_anchor);
      if (detaching) html_tag.d();
    }
  };
}

function create_fragment$6(ctx) {
  var header;
  var t0;
  var t1;
  var footer;
  var current;
  var header_slot_template =
  /*#slots*/
  ctx[10].header;
  var header_slot = create_slot(header_slot_template, ctx,
  /*$$scope*/
  ctx[9], get_header_slot_context);
  var header_slot_or_fallback = header_slot || fallback_block_1(ctx);
  var if_block = (
  /*$$slots*/
  ctx[8].body ||
  /*text*/
  ctx[4]) && create_if_block$4(ctx);
  var footer_slot_template =
  /*#slots*/
  ctx[10].footer;
  var footer_slot = create_slot(footer_slot_template, ctx,
  /*$$scope*/
  ctx[9], get_footer_slot_context);
  return {
    c: function c() {
      header = element("header");
      if (header_slot_or_fallback) header_slot_or_fallback.c();
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
      footer = element("footer");
      if (footer_slot) footer_slot.c();
      attr(header, "class",
      /*headerClass*/
      ctx[0]);
      attr(header, "data-testid", "dialog-content__header");
      attr(footer, "class",
      /*footerClass*/
      ctx[7]);
      attr(footer, "data-testid", "dialog-content__footer");
    },
    m: function m(target, anchor) {
      insert(target, header, anchor);

      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(header, null);
      }

      insert(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, t1, anchor);
      insert(target, footer, anchor);

      if (footer_slot) {
        footer_slot.m(footer, null);
      }

      current = true;
    },
    p: function p(ctx, _ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          dirty = _ref2[0];

      if (header_slot) {
        if (header_slot.p && (!current || dirty &
        /*$$scope*/
        512)) {
          update_slot_base(header_slot, header_slot_template, ctx,
          /*$$scope*/
          ctx[9], !current ? get_all_dirty_from_scope(
          /*$$scope*/
          ctx[9]) : get_slot_changes(header_slot_template,
          /*$$scope*/
          ctx[9], dirty, get_header_slot_changes), get_header_slot_context);
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty &
        /*$$slots*/
        256)) {
          header_slot_or_fallback.p(ctx, !current ? -1 : dirty);
        }
      }

      if (
      /*$$slots*/
      ctx[8].body ||
      /*text*/
      ctx[4]) {
        if (if_block) {
          if_block.p(ctx, dirty);

          if (dirty &
          /*$$slots*/
          256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$4(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, function () {
          if_block = null;
        });
        check_outros();
      }

      if (footer_slot) {
        if (footer_slot.p && (!current || dirty &
        /*$$scope*/
        512)) {
          update_slot_base(footer_slot, footer_slot_template, ctx,
          /*$$scope*/
          ctx[9], !current ? get_all_dirty_from_scope(
          /*$$scope*/
          ctx[9]) : get_slot_changes(footer_slot_template,
          /*$$scope*/
          ctx[9], dirty, get_footer_slot_changes), get_footer_slot_context);
        }
      }
    },
    i: function i(local) {
      if (current) return;
      transition_in(header_slot_or_fallback, local);
      transition_in(if_block);
      transition_in(footer_slot, local);
      current = true;
    },
    o: function o(local) {
      transition_out(header_slot_or_fallback, local);
      transition_out(if_block);
      transition_out(footer_slot, local);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) detach(header);
      if (header_slot_or_fallback) header_slot_or_fallback.d(detaching);
      if (detaching) detach(t0);
      if (if_block) if_block.d(detaching);
      if (detaching) detach(t1);
      if (detaching) detach(footer);
      if (footer_slot) footer_slot.d(detaching);
    }
  };
}

function instance$6($$self, $$props, $$invalidate) {
  var _$$props$$$slots = $$props.$$slots,
      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
      $$scope = $$props.$$scope;
  var $$slots = compute_slots(slots);

  var _getOptions = getOptions(),
      headerClass = _getOptions.headerClass,
      titleClass = _getOptions.titleClass,
      titleId = _getOptions.titleId,
      title = _getOptions.title,
      text = _getOptions.text,
      dividerClass = _getOptions.dividerClass,
      bodyClass = _getOptions.bodyClass,
      footerClass = _getOptions.footerClass;

  $$self.$$set = function ($$props) {
    if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
  };

  return [headerClass, titleClass, titleId, title, text, dividerClass, bodyClass, footerClass, $$slots, $$scope, slots];
}

var DialogContent = /*#__PURE__*/function (_SvelteComponent) {
  _inherits(DialogContent, _SvelteComponent);

  var _super = _createSuper$6(DialogContent);

  function DialogContent(options) {
    var _this;

    _classCallCheck(this, DialogContent);

    _this = _super.call(this);
    init(_assertThisInitialized(_this), options, instance$6, create_fragment$6, safe_not_equal, {});
    return _this;
  }

  return _createClass(DialogContent);
}(SvelteComponent);

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function create_footer_slot$2(ctx) {
  var button;
  var mounted;
  var dispose;
  return {
    c: function c() {
      button = element("button");
      attr(button, "class",
      /*dismissButtonClass*/
      ctx[1]);
      attr(button, "aria-label", "Dismiss alert");
      attr(button, "data-testid", "alert__dismiss-button");
    },
    m: function m(target, anchor) {
      insert(target, button, anchor);
      button.innerHTML =
      /*dismissButtonText*/
      ctx[2];

      if (!mounted) {
        dispose = listen(button, "click",
        /*click_handler*/
        ctx[3]);
        mounted = true;
      }
    },
    p: noop,
    d: function d(detaching) {
      if (detaching) detach(button);
      mounted = false;
      dispose();
    }
  };
}

function create_fragment$5(ctx) {
  var dialogcontent;
  var current;
  dialogcontent = new DialogContent({
    props: {
      $$slots: {
        footer: [create_footer_slot$2]
      },
      $$scope: {
        ctx: ctx
      }
    }
  });
  return {
    c: function c() {
      create_component(dialogcontent.$$.fragment);
    },
    m: function m(target, anchor) {
      mount_component(dialogcontent, target, anchor);
      current = true;
    },
    p: function p(ctx, _ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          dirty = _ref2[0];

      var dialogcontent_changes = {};

      if (dirty &
      /*$$scope*/
      16) {
        dialogcontent_changes.$$scope = {
          dirty: dirty,
          ctx: ctx
        };
      }

      dialogcontent.$set(dialogcontent_changes);
    },
    i: function i(local) {
      if (current) return;
      transition_in(dialogcontent.$$.fragment, local);
      current = true;
    },
    o: function o(local) {
      transition_out(dialogcontent.$$.fragment, local);
      current = false;
    },
    d: function d(detaching) {
      destroy_component(dialogcontent, detaching);
    }
  };
}

function instance$5($$self) {
  var close = getClose();
  /** retrieve options from context */

  var _getOptions = getOptions(),
      dismissButtonClass = _getOptions.dismissButtonClass,
      dismissButtonText = _getOptions.dismissButtonText;

  var click_handler = function click_handler() {
    return close();
  };

  return [close, dismissButtonClass, dismissButtonText, click_handler];
}

var Alert = /*#__PURE__*/function (_SvelteComponent) {
  _inherits(Alert, _SvelteComponent);

  var _super = _createSuper$5(Alert);

  function Alert(options) {
    var _this;

    _classCallCheck(this, Alert);

    _this = _super.call(this);
    init(_assertThisInitialized(_this), options, instance$5, create_fragment$5, safe_not_equal, {});
    return _this;
  }

  return _createClass(Alert);
}(SvelteComponent);

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function create_footer_slot$1(ctx) {
  var button0;
  var t;
  var button1;
  var mounted;
  var dispose;
  return {
    c: function c() {
      button0 = element("button");
      t = space();
      button1 = element("button");
      attr(button0, "class",
      /*declineButtonClass*/
      ctx[1]);
      attr(button0, "aria-label", "Decline");
      attr(button0, "data-testid", "confirm__decline-button");
      attr(button1, "class",
      /*confirmButtonClass*/
      ctx[3]);
      attr(button1, "aria-label", "Confirm");
      attr(button1, "data-testid", "confirm__confirm-button");
    },
    m: function m(target, anchor) {
      insert(target, button0, anchor);
      button0.innerHTML =
      /*declineButtonText*/
      ctx[2];
      insert(target, t, anchor);
      insert(target, button1, anchor);
      button1.innerHTML =
      /*confirmButtonText*/
      ctx[4];

      if (!mounted) {
        dispose = [listen(button0, "click",
        /*click_handler*/
        ctx[5]), listen(button1, "click",
        /*click_handler_1*/
        ctx[6])];
        mounted = true;
      }
    },
    p: noop,
    d: function d(detaching) {
      if (detaching) detach(button0);
      if (detaching) detach(t);
      if (detaching) detach(button1);
      mounted = false;
      run_all(dispose);
    }
  };
}

function create_fragment$4(ctx) {
  var dialogcontent;
  var current;
  dialogcontent = new DialogContent({
    props: {
      $$slots: {
        footer: [create_footer_slot$1]
      },
      $$scope: {
        ctx: ctx
      }
    }
  });
  return {
    c: function c() {
      create_component(dialogcontent.$$.fragment);
    },
    m: function m(target, anchor) {
      mount_component(dialogcontent, target, anchor);
      current = true;
    },
    p: function p(ctx, _ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          dirty = _ref2[0];

      var dialogcontent_changes = {};

      if (dirty &
      /*$$scope*/
      128) {
        dialogcontent_changes.$$scope = {
          dirty: dirty,
          ctx: ctx
        };
      }

      dialogcontent.$set(dialogcontent_changes);
    },
    i: function i(local) {
      if (current) return;
      transition_in(dialogcontent.$$.fragment, local);
      current = true;
    },
    o: function o(local) {
      transition_out(dialogcontent.$$.fragment, local);
      current = false;
    },
    d: function d(detaching) {
      destroy_component(dialogcontent, detaching);
    }
  };
}

function instance$4($$self) {
  var close = getClose();
  /** retrieve options from context */

  var _getOptions = getOptions(),
      declineButtonClass = _getOptions.declineButtonClass,
      declineButtonText = _getOptions.declineButtonText,
      confirmButtonClass = _getOptions.confirmButtonClass,
      confirmButtonText = _getOptions.confirmButtonText;

  var click_handler = function click_handler() {
    return close(false);
  };

  var click_handler_1 = function click_handler_1() {
    return close(true);
  };

  return [close, declineButtonClass, declineButtonText, confirmButtonClass, confirmButtonText, click_handler, click_handler_1];
}

var Confirm = /*#__PURE__*/function (_SvelteComponent) {
  _inherits(Confirm, _SvelteComponent);

  var _super = _createSuper$4(Confirm);

  function Confirm(options) {
    var _this;

    _classCallCheck(this, Confirm);

    _this = _super.call(this);
    init(_assertThisInitialized(_this), options, instance$4, create_fragment$4, safe_not_equal, {});
    return _this;
  }

  return _createClass(Confirm);
}(SvelteComponent);

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * Calls out transitions before destroying the component instance
 * Workaround for https://github.com/sveltejs/svelte/issues/4056
 * @param {SvelteComponent} instance - the svelte component instance
 */

var outroAndDestroy = function outroAndDestroy(instance) {
  if (instance.$$.fragment && instance.$$.fragment.o) {
    group_outros();
    transition_out(instance.$$.fragment, 0, 0, function () {
      instance.$destroy();
    });
    check_outros();
  } else {
    instance.$destroy();
  }
};
/**
 * Utility function to resolve strings to svelte transitions functions.
 * It modifies the transition in the configuration object if is a string,
 * and that's ok: doing so it needs to resolve them only the first time
 * it's passed to this function
 * @param {object} transitions - the transitions object from configuration
 * @param {(string|function)} transitions.transition - the transitions object from configuration
 * @returns {object} - the transitions object from configuration
 * @throws {Error} - not an existing svelte transition
 */

var resolveConfigTransitions = function resolveConfigTransitions(transitions) {
  for (var key in transitions) {
    var point = transitions[key];

    if (point && typeof point.transition === "string") {
      var transition = svelteTransitions[point.transition];
      if (!transition) throw new Error("".concat(point.transition, " not an existing svelte transition"));
      point.transition = transition;
    }
  }

  return transitions;
};
/**
 * Utility function to apply a transition from the transitions congiguration object
 * to an html target
 * @param {Element} node - the document element target of the transition
 * @param {object} point - the transitions configuration object point of application
 * @param {function} point.transition - svelte transition function to apply
 * @param {object} point.props - props for the svelte transition function
 * @returns {TransitionConfig} - the configuration for the transition used by svelte
 */

var applyTransition = function applyTransition(node, point) {
  if (!point) return null;
  var transition = point.transition,
      props = point.props;
  if (!transition) return null;
  return transition(node, props);
};
/**
 * Utility function to map the initial values of prompt input.
 * If not given, return defaults for different input types.
 * @param {object} input - the input object
 * @param {object} input.props - the input object props
 * @param {object} input.props.value - the input object given initial value
 * @param {object} input.props.type - the input object type
 * @returns {any} - the input initial value
 */

var inputInitialValueMapping = function inputInitialValueMapping(_ref) {
  var props = _ref.props;
  var type = props.type,
      value = props.value,
      multiple = props.multiple;
  /** if there is an initial value, use that */

  if (value) return value;
  /** if not, use the type default */

  if (type === "checkbox") return false;
  if (type === "select" && multiple) return [];
  return undefined;
};
/**
 * Utility function to map the input argument of prompt().
 * @param {(string|function|object)} input - the input argument of prompt()
 * @returns {object} - the configuration object to be merged with other configuration.
 */

var promptInputMapping = function promptInputMapping(input) {
  if (typeof input === "string") {
    /** if input is string, use it as label */
    return {
      props: {
        label: input
      }
    };
  } else if (typeof input === "function") {
    /** if input is SvelteComponent, use it as content */
    return {
      component: input,
      props: {}
    };
  } else if (!input.props && !input.component) {
    /** if input is object without props and component, use it as component props */
    return {
      props: input
    };
  } else {
    /** if input is object use it as input option */
    return input;
  }
};
/**
 * Utility function to add props to inputs props from prompt()
 * @param {object[]} inputs - the inputs with base configuration
 * @param {object} opts - the options for the given component
 * @returns {object[]} - the inputs with enriched props
 */

var getInputsWithProps = function getInputsWithProps(inputs, opts) {
  var inputComponent = opts.inputComponent,
      inputProps = opts.inputProps,
      formElementClass = opts.formElementClass,
      inputLabelClass = opts.inputLabelClass,
      inputClass = opts.inputClass;
  /** merge custom inputProps with default config options */

  var defaultProps = _objectSpread$2({
    label: "",
    formElementClass: formElementClass,
    inputLabelClass: inputLabelClass,
    inputClass: inputClass
  }, inputProps);

  return inputs.map(function (_ref2) {
    var component = _ref2.component,
        props = _ref2.props;

    /**
     * If there is a custom component passed in caller,
     * use it without default or configured props
     */
    if (component && component !== inputComponent) return {
      component: component,
      props: props
    };
    /** else merge the passed props with the default ones */

    return {
      component: inputComponent,
      props: _objectSpread$2(_objectSpread$2({}, defaultProps), props)
    };
  });
};
/**
 * Utility function to get the description from an option in DialogInput
 * @param {(string|object)} option - the option
 * @returns {string} - the description
 */

var optionDescription = function optionDescription(option) {
  var _option$description;

  return typeof option === "string" ? option : (_option$description = option.description) !== null && _option$description !== void 0 ? _option$description : "";
};
/**
 * Utility function to check if an option is the selected
 * @param {(string|object)} selected - the selected option
 * @param {(string|object)} option - the option to check
 * @returns {boolean} - if the option is the selected one
 */

var optionCompare = function optionCompare(selected, option) {
  return typeof option === "string" ? selected === option : selected.value === option.value;
};
/**
 * Utility function to check if an option is among the selected
 * @param {(string|object)} selected - the selected option
 * @param {(string|object)} option - the option to check
 * @returns {boolean} - if the option is the selected one
 */

var optionCompareMultiple = function optionCompareMultiple(value, option) {
  return !!value.find(function (selected) {
    return optionCompare(selected, option);
  });
};
/**
 * Utility function to retrieve the compare function based on the multiple attribute
 * @param {boolean} multiple - the multiple attribute value
 * @returns {function} - the function to check an option against the DialogInput value
 */

var getOptionCompare = function getOptionCompare(multiple) {
  return multiple ? optionCompareMultiple : optionCompare;
};
/**
 * Utility function to create random ids
 * @returns {string} - the id
 */

var randomId = function randomId() {
  return Math.random().toString(36).substring(2) + Date.now().toString(36);
};

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function get_each_context_2(ctx, list, i) {
  var child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  child_ctx[28] = i;
  return child_ctx;
}

function get_each_context_1(ctx, list, i) {
  var child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}

function get_each_context$1(ctx, list, i) {
  var child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
} // (51:2) {#if type !== "radio"}


function create_if_block_6(ctx) {
  var label_1;
  var t0;
  var t1_value = (
  /*required*/
  ctx[8] ? " *" : "") + "";
  var t1;
  return {
    c: function c() {
      label_1 = element("label");
      t0 = text(
      /*label*/
      ctx[1]);
      t1 = text(t1_value);
      attr(label_1, "class",
      /*inputLabelClass*/
      ctx[4]);
      attr(label_1, "data-testid", "dialog-input__label");
      attr(label_1, "for",
      /*id*/
      ctx[2]);
    },
    m: function m(target, anchor) {
      insert(target, label_1, anchor);
      append(label_1, t0);
      append(label_1, t1);
    },
    p: function p(ctx, dirty) {
      if (dirty &
      /*label*/
      2) set_data(t0,
      /*label*/
      ctx[1]);

      if (dirty &
      /*inputLabelClass*/
      16) {
        attr(label_1, "class",
        /*inputLabelClass*/
        ctx[4]);
      }

      if (dirty &
      /*id*/
      4) {
        attr(label_1, "for",
        /*id*/
        ctx[2]);
      }
    },
    d: function d(detaching) {
      if (detaching) detach(label_1);
    }
  };
} // (127:2) {:else}


function create_else_block_1(ctx) {
  var input;
  var mounted;
  var dispose;
  var input_levels = [{
    id:
    /*id*/
    ctx[2]
  }, {
    class:
    /*inputClass*/
    ctx[5]
  }, {
    "data-testid": "dialog-input__input"
  },
  /*$$restProps*/
  ctx[11]];
  var input_data = {};

  for (var i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }

  return {
    c: function c() {
      input = element("input");
      set_attributes(input, input_data);
    },
    m: function m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus) input.focus();
      set_input_value(input,
      /*value*/
      ctx[0]);

      if (!mounted) {
        dispose = listen(input, "input",
        /*input_input_handler*/
        ctx[19]);
        mounted = true;
      }
    },
    p: function p(ctx, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [dirty &
      /*id*/
      4 && {
        id:
        /*id*/
        ctx[2]
      }, dirty &
      /*inputClass*/
      32 && {
        class:
        /*inputClass*/
        ctx[5]
      }, {
        "data-testid": "dialog-input__input"
      }, dirty &
      /*$$restProps*/
      2048 &&
      /*$$restProps*/
      ctx[11]]));

      if (dirty &
      /*value, options*/
      65 && input.value !==
      /*value*/
      ctx[0]) {
        set_input_value(input,
        /*value*/
        ctx[0]);
      }
    },
    d: function d(detaching) {
      if (detaching) detach(input);
      mounted = false;
      dispose();
    }
  };
} // (109:29) 


function create_if_block_5(ctx) {
  var fieldset;
  var legend;
  var t0;
  var t1_value = (
  /*required*/
  ctx[8] ? " *" : "") + "";
  var t1;
  var t2;
  var each_value_2 =
  /*options*/
  ctx[6];
  var each_blocks = [];

  for (var i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }

  return {
    c: function c() {
      fieldset = element("fieldset");
      legend = element("legend");
      t0 = text(
      /*label*/
      ctx[1]);
      t1 = text(t1_value);
      t2 = space();

      for (var _i = 0; _i < each_blocks.length; _i += 1) {
        each_blocks[_i].c();
      }

      attr(legend, "data-testid", "dialog-input__legend");
      attr(fieldset, "data-testid", "dialog-input__fieldset");
    },
    m: function m(target, anchor) {
      insert(target, fieldset, anchor);
      append(fieldset, legend);
      append(legend, t0);
      append(legend, t1);
      append(fieldset, t2);

      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
        each_blocks[_i2].m(fieldset, null);
      }
    },
    p: function p(ctx, dirty) {
      if (dirty &
      /*label*/
      2) set_data(t0,
      /*label*/
      ctx[1]);

      if (dirty &
      /*id, options, inputClass, $$restProps, value, inputLabelClass, optionDescription*/
      2165) {
        each_value_2 =
        /*options*/
        ctx[6];

        var _i3;

        for (_i3 = 0; _i3 < each_value_2.length; _i3 += 1) {
          var child_ctx = get_each_context_2(ctx, each_value_2, _i3);

          if (each_blocks[_i3]) {
            each_blocks[_i3].p(child_ctx, dirty);
          } else {
            each_blocks[_i3] = create_each_block_2(child_ctx);

            each_blocks[_i3].c();

            each_blocks[_i3].m(fieldset, null);
          }
        }

        for (; _i3 < each_blocks.length; _i3 += 1) {
          each_blocks[_i3].d(1);
        }

        each_blocks.length = each_value_2.length;
      }
    },
    d: function d(detaching) {
      if (detaching) detach(fieldset);
      destroy_each(each_blocks, detaching);
    }
  };
} // (83:30) 


function create_if_block_3(ctx) {
  var if_block_anchor;

  function select_block_type_1(ctx, dirty) {
    if (
    /*multiple*/
    ctx[9]) return create_if_block_4;
    return create_else_block$1;
  }

  var current_block_type = select_block_type_1(ctx);
  var if_block = current_block_type(ctx);
  return {
    c: function c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p: function p(ctx, dirty) {
      if_block.p(ctx, dirty);
    },
    d: function d(detaching) {
      if_block.d(detaching);
      if (detaching) detach(if_block_anchor);
    }
  };
} // (74:28) 


function create_if_block_2$1(ctx) {
  var input;
  var mounted;
  var dispose;
  var input_levels = [{
    type: "file"
  }, {
    id:
    /*id*/
    ctx[2]
  }, {
    class:
    /*inputClass*/
    ctx[5]
  }, {
    "data-testid": "dialog-input__input"
  },
  /*$$restProps*/
  ctx[11]];
  var input_data = {};

  for (var i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }

  return {
    c: function c() {
      input = element("input");
      set_attributes(input, input_data);
    },
    m: function m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus) input.focus();

      if (!mounted) {
        dispose = listen(input, "change",
        /*input_change_handler_1*/
        ctx[14]);
        mounted = true;
      }
    },
    p: function p(ctx, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [{
        type: "file"
      }, dirty &
      /*id*/
      4 && {
        id:
        /*id*/
        ctx[2]
      }, dirty &
      /*inputClass*/
      32 && {
        class:
        /*inputClass*/
        ctx[5]
      }, {
        "data-testid": "dialog-input__input"
      }, dirty &
      /*$$restProps*/
      2048 &&
      /*$$restProps*/
      ctx[11]]));
    },
    d: function d(detaching) {
      if (detaching) detach(input);
      mounted = false;
      dispose();
    }
  };
} // (65:32) 


function create_if_block_1$1(ctx) {
  var input;
  var mounted;
  var dispose;
  var input_levels = [{
    type: "checkbox"
  }, {
    id:
    /*id*/
    ctx[2]
  }, {
    class:
    /*inputClass*/
    ctx[5]
  }, {
    "data-testid": "dialog-input__input"
  },
  /*$$restProps*/
  ctx[11]];
  var input_data = {};

  for (var i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }

  return {
    c: function c() {
      input = element("input");
      set_attributes(input, input_data);
    },
    m: function m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus) input.focus();
      input.checked =
      /*value*/
      ctx[0];

      if (!mounted) {
        dispose = listen(input, "change",
        /*input_change_handler*/
        ctx[13]);
        mounted = true;
      }
    },
    p: function p(ctx, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [{
        type: "checkbox"
      }, dirty &
      /*id*/
      4 && {
        id:
        /*id*/
        ctx[2]
      }, dirty &
      /*inputClass*/
      32 && {
        class:
        /*inputClass*/
        ctx[5]
      }, {
        "data-testid": "dialog-input__input"
      }, dirty &
      /*$$restProps*/
      2048 &&
      /*$$restProps*/
      ctx[11]]));

      if (dirty &
      /*value, options*/
      65) {
        input.checked =
        /*value*/
        ctx[0];
      }
    },
    d: function d(detaching) {
      if (detaching) detach(input);
      mounted = false;
      dispose();
    }
  };
} // (57:2) {#if type === "textarea"}


function create_if_block$3(ctx) {
  var textarea;
  var mounted;
  var dispose;
  var textarea_levels = [{
    id:
    /*id*/
    ctx[2]
  }, {
    class:
    /*inputClass*/
    ctx[5]
  }, {
    "data-testid": "dialog-input__input"
  },
  /*$$restProps*/
  ctx[11]];
  var textarea_data = {};

  for (var i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }

  return {
    c: function c() {
      textarea = element("textarea");
      set_attributes(textarea, textarea_data);
    },
    m: function m(target, anchor) {
      insert(target, textarea, anchor);
      if (textarea.autofocus) textarea.focus();
      set_input_value(textarea,
      /*value*/
      ctx[0]);

      if (!mounted) {
        dispose = listen(textarea, "input",
        /*textarea_input_handler*/
        ctx[12]);
        mounted = true;
      }
    },
    p: function p(ctx, dirty) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [dirty &
      /*id*/
      4 && {
        id:
        /*id*/
        ctx[2]
      }, dirty &
      /*inputClass*/
      32 && {
        class:
        /*inputClass*/
        ctx[5]
      }, {
        "data-testid": "dialog-input__input"
      }, dirty &
      /*$$restProps*/
      2048 &&
      /*$$restProps*/
      ctx[11]]));

      if (dirty &
      /*value, options*/
      65) {
        set_input_value(textarea,
        /*value*/
        ctx[0]);
      }
    },
    d: function d(detaching) {
      if (detaching) detach(textarea);
      mounted = false;
      dispose();
    }
  };
} // (112:6) {#each options as option, idx}


function create_each_block_2(ctx) {
  var label_1;
  var t0_value = optionDescription(
  /*option*/
  ctx[22]) + "";
  var t0;
  var label_1_for_value;
  var t1;
  var input;
  var input_id_value;
  var input_value_value;
  var mounted;
  var dispose;
  var input_levels = [{
    type: "radio"
  }, {
    id: input_id_value =
    /*id*/
    ctx[2] +
    /*idx*/
    ctx[28]
  }, {
    __value: input_value_value =
    /*option*/
    ctx[22]
  }, {
    class:
    /*inputClass*/
    ctx[5]
  }, {
    "data-testid": "dialog-input__input"
  },
  /*$$restProps*/
  ctx[11]];
  var input_data = {};

  for (var i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }

  return {
    c: function c() {
      label_1 = element("label");
      t0 = text(t0_value);
      t1 = space();
      input = element("input");
      attr(label_1, "class",
      /*inputLabelClass*/
      ctx[4]);
      attr(label_1, "data-testid", "dialog-input__label");
      attr(label_1, "for", label_1_for_value =
      /*id*/
      ctx[2] +
      /*idx*/
      ctx[28]);
      set_attributes(input, input_data);
      /*$$binding_groups*/

      ctx[18][0].push(input);
    },
    m: function m(target, anchor) {
      insert(target, label_1, anchor);
      append(label_1, t0);
      insert(target, t1, anchor);
      insert(target, input, anchor);
      if (input.autofocus) input.focus();
      input.checked = input.__value ===
      /*value*/
      ctx[0];

      if (!mounted) {
        dispose = listen(input, "change",
        /*input_change_handler_2*/
        ctx[17]);
        mounted = true;
      }
    },
    p: function p(ctx, dirty) {
      if (dirty &
      /*options*/
      64 && t0_value !== (t0_value = optionDescription(
      /*option*/
      ctx[22]) + "")) set_data(t0, t0_value);

      if (dirty &
      /*inputLabelClass*/
      16) {
        attr(label_1, "class",
        /*inputLabelClass*/
        ctx[4]);
      }

      if (dirty &
      /*id*/
      4 && label_1_for_value !== (label_1_for_value =
      /*id*/
      ctx[2] +
      /*idx*/
      ctx[28])) {
        attr(label_1, "for", label_1_for_value);
      }

      set_attributes(input, input_data = get_spread_update(input_levels, [{
        type: "radio"
      }, dirty &
      /*id*/
      4 && input_id_value !== (input_id_value =
      /*id*/
      ctx[2] +
      /*idx*/
      ctx[28]) && {
        id: input_id_value
      }, dirty &
      /*options*/
      64 && input_value_value !== (input_value_value =
      /*option*/
      ctx[22]) && {
        __value: input_value_value
      }, dirty &
      /*inputClass*/
      32 && {
        class:
        /*inputClass*/
        ctx[5]
      }, {
        "data-testid": "dialog-input__input"
      }, dirty &
      /*$$restProps*/
      2048 &&
      /*$$restProps*/
      ctx[11]]));

      if (dirty &
      /*value, options*/
      65) {
        input.checked = input.__value ===
        /*value*/
        ctx[0];
      }
    },
    d: function d(detaching) {
      if (detaching) detach(label_1);
      if (detaching) detach(t1);
      if (detaching) detach(input);
      /*$$binding_groups*/

      ctx[18][0].splice(
      /*$$binding_groups*/
      ctx[18][0].indexOf(input), 1);
      mounted = false;
      dispose();
    }
  };
} // (100:4) {:else}


function create_else_block$1(ctx) {
  var select;
  var mounted;
  var dispose;
  var each_value_1 =
  /*options*/
  ctx[6];
  var each_blocks = [];

  for (var i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }

  var select_levels = [{
    id:
    /*id*/
    ctx[2]
  }, {
    class:
    /*inputClass*/
    ctx[5]
  }, {
    "data-testid": "dialog-input__input"
  },
  /*$$restProps*/
  ctx[11]];
  var select_data = {};

  for (var _i4 = 0; _i4 < select_levels.length; _i4 += 1) {
    select_data = assign(select_data, select_levels[_i4]);
  }

  return {
    c: function c() {
      select = element("select");

      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
        each_blocks[_i5].c();
      }

      set_attributes(select, select_data);
      if (
      /*value*/
      ctx[0] === void 0) add_render_callback(function () {
        return (
          /*select_change_handler_1*/
          ctx[16].call(select)
        );
      });
    },
    m: function m(target, anchor) {
      insert(target, select, anchor);

      for (var _i6 = 0; _i6 < each_blocks.length; _i6 += 1) {
        each_blocks[_i6].m(select, null);
      }

      (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (select.autofocus) select.focus();
      select_option(select,
      /*value*/
      ctx[0]);

      if (!mounted) {
        dispose = listen(select, "change",
        /*select_change_handler_1*/
        ctx[16]);
        mounted = true;
      }
    },
    p: function p(ctx, dirty) {
      if (dirty &
      /*options, isSelected, optionDescription*/
      1088) {
        each_value_1 =
        /*options*/
        ctx[6];

        var _i7;

        for (_i7 = 0; _i7 < each_value_1.length; _i7 += 1) {
          var child_ctx = get_each_context_1(ctx, each_value_1, _i7);

          if (each_blocks[_i7]) {
            each_blocks[_i7].p(child_ctx, dirty);
          } else {
            each_blocks[_i7] = create_each_block_1(child_ctx);

            each_blocks[_i7].c();

            each_blocks[_i7].m(select, null);
          }
        }

        for (; _i7 < each_blocks.length; _i7 += 1) {
          each_blocks[_i7].d(1);
        }

        each_blocks.length = each_value_1.length;
      }

      set_attributes(select, select_data = get_spread_update(select_levels, [dirty &
      /*id*/
      4 && {
        id:
        /*id*/
        ctx[2]
      }, dirty &
      /*inputClass*/
      32 && {
        class:
        /*inputClass*/
        ctx[5]
      }, {
        "data-testid": "dialog-input__input"
      }, dirty &
      /*$$restProps*/
      2048 &&
      /*$$restProps*/
      ctx[11]]));
      if (dirty &
      /*id, inputClass, $$restProps*/
      2084 && 'value' in select_data) (select_data.multiple ? select_options : select_option)(select, select_data.value);

      if (dirty &
      /*value, options*/
      65) {
        select_option(select,
        /*value*/
        ctx[0]);
      }
    },
    d: function d(detaching) {
      if (detaching) detach(select);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
} // (84:4) {#if multiple}


function create_if_block_4(ctx) {
  var select;
  var mounted;
  var dispose;
  var each_value =
  /*options*/
  ctx[6];
  var each_blocks = [];

  for (var i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }

  return {
    c: function c() {
      select = element("select");

      for (var _i8 = 0; _i8 < each_blocks.length; _i8 += 1) {
        each_blocks[_i8].c();
      }

      attr(select, "id",
      /*id*/
      ctx[2]);
      attr(select, "class",
      /*inputClass*/
      ctx[5]);
      attr(select, "data-testid", "dialog-input__input");
      select.required =
      /*required*/
      ctx[8];
      select.multiple = true;
      if (
      /*value*/
      ctx[0] === void 0) add_render_callback(function () {
        return (
          /*select_change_handler*/
          ctx[15].call(select)
        );
      });
    },
    m: function m(target, anchor) {
      insert(target, select, anchor);

      for (var _i9 = 0; _i9 < each_blocks.length; _i9 += 1) {
        each_blocks[_i9].m(select, null);
      }

      select_options(select,
      /*value*/
      ctx[0]);

      if (!mounted) {
        dispose = listen(select, "change",
        /*select_change_handler*/
        ctx[15]);
        mounted = true;
      }
    },
    p: function p(ctx, dirty) {
      if (dirty &
      /*options, isSelected, optionDescription*/
      1088) {
        each_value =
        /*options*/
        ctx[6];

        var _i10;

        for (_i10 = 0; _i10 < each_value.length; _i10 += 1) {
          var child_ctx = get_each_context$1(ctx, each_value, _i10);

          if (each_blocks[_i10]) {
            each_blocks[_i10].p(child_ctx, dirty);
          } else {
            each_blocks[_i10] = create_each_block$1(child_ctx);

            each_blocks[_i10].c();

            each_blocks[_i10].m(select, null);
          }
        }

        for (; _i10 < each_blocks.length; _i10 += 1) {
          each_blocks[_i10].d(1);
        }

        each_blocks.length = each_value.length;
      }

      if (dirty &
      /*id*/
      4) {
        attr(select, "id",
        /*id*/
        ctx[2]);
      }

      if (dirty &
      /*inputClass*/
      32) {
        attr(select, "class",
        /*inputClass*/
        ctx[5]);
      }

      if (dirty &
      /*value, options*/
      65) {
        select_options(select,
        /*value*/
        ctx[0]);
      }
    },
    d: function d(detaching) {
      if (detaching) detach(select);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
} // (102:8) {#each options as option}


function create_each_block_1(ctx) {
  var option;
  var t0_value = optionDescription(
  /*option*/
  ctx[22]) + "";
  var t0;
  var t1;
  var option_value_value;
  var option_selected_value;
  return {
    c: function c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = option_value_value =
      /*option*/
      ctx[22];
      option.value = option.__value;
      option.selected = option_selected_value =
      /*isSelected*/
      ctx[10](
      /*option*/
      ctx[22]);
      attr(option, "data-testid", "dialog-input__option");
    },
    m: function m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p: function p(ctx, dirty) {
      if (dirty &
      /*options*/
      64 && t0_value !== (t0_value = optionDescription(
      /*option*/
      ctx[22]) + "")) set_data(t0, t0_value);

      if (dirty &
      /*options*/
      64 && option_value_value !== (option_value_value =
      /*option*/
      ctx[22])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }

      if (dirty &
      /*options*/
      64 && option_selected_value !== (option_selected_value =
      /*isSelected*/
      ctx[10](
      /*option*/
      ctx[22]))) {
        option.selected = option_selected_value;
      }
    },
    d: function d(detaching) {
      if (detaching) detach(option);
    }
  };
} // (94:8) {#each options as option}


function create_each_block$1(ctx) {
  var option;
  var t0_value = optionDescription(
  /*option*/
  ctx[22]) + "";
  var t0;
  var t1;
  var option_value_value;
  var option_selected_value;
  return {
    c: function c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = option_value_value =
      /*option*/
      ctx[22];
      option.value = option.__value;
      option.selected = option_selected_value =
      /*isSelected*/
      ctx[10](
      /*option*/
      ctx[22]);
      attr(option, "data-testid", "dialog-input__option");
    },
    m: function m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p: function p(ctx, dirty) {
      if (dirty &
      /*options*/
      64 && t0_value !== (t0_value = optionDescription(
      /*option*/
      ctx[22]) + "")) set_data(t0, t0_value);

      if (dirty &
      /*options*/
      64 && option_value_value !== (option_value_value =
      /*option*/
      ctx[22])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }

      if (dirty &
      /*options*/
      64 && option_selected_value !== (option_selected_value =
      /*isSelected*/
      ctx[10](
      /*option*/
      ctx[22]))) {
        option.selected = option_selected_value;
      }
    },
    d: function d(detaching) {
      if (detaching) detach(option);
    }
  };
}

function create_fragment$3(ctx) {
  var div;
  var t;
  var if_block0 =
  /*type*/
  ctx[7] !== "radio" && create_if_block_6(ctx);

  function select_block_type(ctx, dirty) {
    if (
    /*type*/
    ctx[7] === "textarea") return create_if_block$3;
    if (
    /*type*/
    ctx[7] === "checkbox") return create_if_block_1$1;
    if (
    /*type*/
    ctx[7] === "file") return create_if_block_2$1;
    if (
    /*type*/
    ctx[7] === "select") return create_if_block_3;
    if (
    /*type*/
    ctx[7] === "radio") return create_if_block_5;
    return create_else_block_1;
  }

  var current_block_type = select_block_type(ctx);
  var if_block1 = current_block_type(ctx);
  return {
    c: function c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t = space();
      if_block1.c();
      attr(div, "class",
      /*formElementClass*/
      ctx[3]);
      attr(div, "data-testid", "dialog-input__form-element");
    },
    m: function m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t);
      if_block1.m(div, null);
    },
    p: function p(ctx, _ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          dirty = _ref2[0];

      if (
      /*type*/
      ctx[7] !== "radio") if_block0.p(ctx, dirty);
      if_block1.p(ctx, dirty);

      if (dirty &
      /*formElementClass*/
      8) {
        attr(div, "class",
        /*formElementClass*/
        ctx[3]);
      }
    },
    i: noop,
    o: noop,
    d: function d(detaching) {
      if (detaching) detach(div);
      if (if_block0) if_block0.d();
      if_block1.d();
    }
  };
}

function instance$3($$self, $$props, $$invalidate) {
  var omit_props_names = ["value", "label", "id", "formElementClass", "inputLabelClass", "inputClass", "options"];
  var $$restProps = compute_rest_props($$props, omit_props_names);
  var _$$props = $$props,
      _$$props$value = _$$props.value,
      value = _$$props$value === void 0 ? inputInitialValueMapping({
    props: $$props
  }) : _$$props$value;
  var _$$props2 = $$props,
      _$$props2$label = _$$props2.label,
      label = _$$props2$label === void 0 ? "" : _$$props2$label;
  var _$$props3 = $$props,
      _$$props3$id = _$$props3.id,
      id = _$$props3$id === void 0 ? randomId() : _$$props3$id;
  var _$$props4 = $$props,
      _$$props4$formElement = _$$props4.formElementClass,
      formElementClass = _$$props4$formElement === void 0 ? "" : _$$props4$formElement;
  var _$$props5 = $$props,
      _$$props5$inputLabelC = _$$props5.inputLabelClass,
      inputLabelClass = _$$props5$inputLabelC === void 0 ? "" : _$$props5$inputLabelC;
  var _$$props6 = $$props,
      _$$props6$inputClass = _$$props6.inputClass,
      inputClass = _$$props6$inputClass === void 0 ? "" : _$$props6$inputClass;
  var _$$props7 = $$props,
      _$$props7$options = _$$props7.options,
      options = _$$props7$options === void 0 ? [] : _$$props7$options;
  /**
  * workaround: type cannot be set dinamicaly
  */

  var _$$restProps = $$restProps,
      type = _$$restProps.type,
      required = _$$restProps.required,
      multiple = _$$restProps.multiple;
  /**
  * Compare function based on multiple attribute
  */

  var optionCompare = getOptionCompare(multiple);
  /**
  * Selected logic for select
  * @param {object} option - the option
  */

  function isSelected(option) {
    if (!value) return false;
    return optionCompare(value, option);
  }

  var $$binding_groups = [[]];

  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
    $$invalidate(6, options);
  }

  function input_change_handler() {
    value = this.checked;
    $$invalidate(0, value);
    $$invalidate(6, options);
  }

  function input_change_handler_1() {
    value = this.files;
    $$invalidate(0, value);
    $$invalidate(6, options);
  }

  function select_change_handler() {
    value = select_multiple_value(this);
    $$invalidate(0, value);
    $$invalidate(6, options);
  }

  function select_change_handler_1() {
    value = select_value(this);
    $$invalidate(0, value);
    $$invalidate(6, options);
  }

  function input_change_handler_2() {
    value = this.__value;
    $$invalidate(0, value);
    $$invalidate(6, options);
  }

  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
    $$invalidate(6, options);
  }

  $$self.$$set = function ($$new_props) {
    $$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ('label' in $$new_props) $$invalidate(1, label = $$new_props.label);
    if ('id' in $$new_props) $$invalidate(2, id = $$new_props.id);
    if ('formElementClass' in $$new_props) $$invalidate(3, formElementClass = $$new_props.formElementClass);
    if ('inputLabelClass' in $$new_props) $$invalidate(4, inputLabelClass = $$new_props.inputLabelClass);
    if ('inputClass' in $$new_props) $$invalidate(5, inputClass = $$new_props.inputClass);
    if ('options' in $$new_props) $$invalidate(6, options = $$new_props.options);
  };

  $$props = exclude_internal_props($$props);
  return [value, label, id, formElementClass, inputLabelClass, inputClass, options, type, required, multiple, isSelected, $$restProps, textarea_input_handler, input_change_handler, input_change_handler_1, select_change_handler, select_change_handler_1, input_change_handler_2, $$binding_groups, input_input_handler];
}

var DialogInput = /*#__PURE__*/function (_SvelteComponent) {
  _inherits(DialogInput, _SvelteComponent);

  var _super = _createSuper$3(DialogInput);

  function DialogInput(options) {
    var _this;

    _classCallCheck(this, DialogInput);

    _this = _super.call(this);
    init(_assertThisInitialized(_this), options, instance$3, create_fragment$3, safe_not_equal, {
      value: 0,
      label: 1,
      id: 2,
      formElementClass: 3,
      inputLabelClass: 4,
      inputClass: 5,
      options: 6
    });
    return _this;
  }

  return _createClass(DialogInput);
}(SvelteComponent);

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */


function writable(value) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
  var stop;
  var subscribers = new Set();

  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;

      if (stop) {
        // store is ready
        var run_queue = !subscriber_queue.length;

        var _iterator = _createForOfIteratorHelper(subscribers),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var subscriber = _step.value;
            subscriber[1]();
            subscriber_queue.push(subscriber, value);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (run_queue) {
          for (var i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }

          subscriber_queue.length = 0;
        }
      }
    }
  }

  function update(fn) {
    set(fn(value));
  }

  function subscribe(run) {
    var invalidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
    var subscriber = [run, invalidate];
    subscribers.add(subscriber);

    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }

    run(value);
    return function () {
      subscribers.delete(subscriber);

      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }

  return {
    set: set,
    update: update,
    subscribe: subscribe
  };
}

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function get_each_context(ctx, list, i) {
  var child_ctx = ctx.slice();
  child_ctx[18] = list[i].component;
  child_ctx[19] = list[i].props;
  child_ctx[20] = list;
  child_ctx[21] = i;
  return child_ctx;
} // (62:6) {#each inputs as { component, props }


function create_each_block(ctx) {
  var switch_instance;
  var updating_value;
  var switch_instance_anchor;
  var current;
  var switch_instance_spread_levels = [
  /*props*/
  ctx[19]];

  function switch_instance_value_binding(value) {
    /*switch_instance_value_binding*/
    ctx[17](value,
    /*idx*/
    ctx[21]);
  }

  var switch_value =
  /*component*/
  ctx[18];

  function switch_props(ctx) {
    var switch_instance_props = {};

    for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }

    if (
    /*$form$*/
    ctx[2][
    /*idx*/
    ctx[21]] !== void 0) {
      switch_instance_props.value =
      /*$form$*/
      ctx[2][
      /*idx*/
      ctx[21]];
    }

    return {
      props: switch_instance_props
    };
  }

  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
    binding_callbacks.push(function () {
      return bind(switch_instance, 'value', switch_instance_value_binding);
    });
  }

  return {
    c: function c() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }

      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function p(new_ctx, dirty) {
      ctx = new_ctx;
      var switch_instance_changes = dirty &
      /*inputs*/
      1 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
      /*props*/
      ctx[19])]) : {};

      if (!updating_value && dirty &
      /*$form$*/
      4) {
        updating_value = true;
        switch_instance_changes.value =
        /*$form$*/
        ctx[2][
        /*idx*/
        ctx[21]];
        add_flush_callback(function () {
          return updating_value = false;
        });
      }

      if (switch_value !== (switch_value =
      /*component*/
      ctx[18])) {
        if (switch_instance) {
          group_outros();
          var old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, function () {
            destroy_component(old_component, 1);
          });
          check_outros();
        }

        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx));
          binding_callbacks.push(function () {
            return bind(switch_instance, 'value', switch_instance_value_binding);
          });
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) detach(switch_instance_anchor);
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
} // (61:4) <svelte:fragment slot="body">


function create_body_slot(ctx) {
  var each_1_anchor;
  var current;
  var each_value =
  /*inputs*/
  ctx[0];
  var each_blocks = [];

  for (var i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }

  var out = function out(i) {
    return transition_out(each_blocks[i], 1, 1, function () {
      each_blocks[i] = null;
    });
  };

  return {
    c: function c() {
      for (var _i = 0; _i < each_blocks.length; _i += 1) {
        each_blocks[_i].c();
      }

      each_1_anchor = empty();
    },
    m: function m(target, anchor) {
      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
        each_blocks[_i2].m(target, anchor);
      }

      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p: function p(ctx, dirty) {
      if (dirty &
      /*inputs, $form$*/
      5) {
        each_value =
        /*inputs*/
        ctx[0];

        var _i3;

        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
          var child_ctx = get_each_context(ctx, each_value, _i3);

          if (each_blocks[_i3]) {
            each_blocks[_i3].p(child_ctx, dirty);

            transition_in(each_blocks[_i3], 1);
          } else {
            each_blocks[_i3] = create_each_block(child_ctx);

            each_blocks[_i3].c();

            transition_in(each_blocks[_i3], 1);

            each_blocks[_i3].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }

        group_outros();

        for (_i3 = each_value.length; _i3 < each_blocks.length; _i3 += 1) {
          out(_i3);
        }

        check_outros();
      }
    },
    i: function i(local) {
      if (current) return;

      for (var _i4 = 0; _i4 < each_value.length; _i4 += 1) {
        transition_in(each_blocks[_i4]);
      }

      current = true;
    },
    o: function o(local) {
      each_blocks = each_blocks.filter(Boolean);

      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
        transition_out(each_blocks[_i5]);
      }

      current = false;
    },
    d: function d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching) detach(each_1_anchor);
    }
  };
} // (75:8) {#if resetButton}


function create_if_block$2(ctx) {
  var button;
  var mounted;
  var dispose;
  return {
    c: function c() {
      button = element("button");
      attr(button, "type", "button");
      attr(button, "class",
      /*resetButtonClass*/
      ctx[8]);
      attr(button, "aria-label", "Reset form");
      attr(button, "data-testid", "prompt__reset-button");
    },
    m: function m(target, anchor) {
      insert(target, button, anchor);
      button.innerHTML =
      /*resetButtonText*/
      ctx[9];

      if (!mounted) {
        dispose = listen(button, "click",
        /*handleReset*/
        ctx[14]);
        mounted = true;
      }
    },
    p: noop,
    d: function d(detaching) {
      if (detaching) detach(button);
      mounted = false;
      dispose();
    }
  };
} // (66:4) <svelte:fragment slot="footer">


function create_footer_slot(ctx) {
  var div0;
  var button0;
  var t0;
  var t1;
  var div1;
  var button1;
  var mounted;
  var dispose;
  var if_block =
  /*resetButton*/
  ctx[7] && create_if_block$2(ctx);
  return {
    c: function c() {
      div0 = element("div");
      button0 = element("button");
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
      div1 = element("div");
      button1 = element("button");
      attr(button0, "type", "button");
      attr(button0, "class",
      /*cancelButtonClass*/
      ctx[5]);
      attr(button0, "aria-label", "Cancel");
      attr(button0, "data-testid", "prompt__cancel-button");
      attr(div0, "class", "dialog__button-container");
      attr(button1, "type", "submit");
      attr(button1, "class",
      /*submitButtonClass*/
      ctx[10]);
      attr(button1, "aria-label", "Submit");
      attr(button1, "data-testid", "prompt__submit-button");
      attr(div1, "class", "dialog__button-container");
    },
    m: function m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, button0);
      button0.innerHTML =
      /*cancelButtonText*/
      ctx[6];
      append(div0, t0);
      if (if_block) if_block.m(div0, null);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      append(div1, button1);
      button1.innerHTML =
      /*submitButtonText*/
      ctx[11];

      if (!mounted) {
        dispose = [listen(button0, "click",
        /*click_handler*/
        ctx[15]), listen(button1, "click",
        /*click_handler_1*/
        ctx[16])];
        mounted = true;
      }
    },
    p: function p(ctx, dirty) {
      if (
      /*resetButton*/
      ctx[7]) if_block.p(ctx, dirty);
    },
    d: function d(detaching) {
      if (detaching) detach(div0);
      if (if_block) if_block.d();
      if (detaching) detach(t1);
      if (detaching) detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}

function create_fragment$2(ctx) {
  var form;
  var dialogcontent;
  var current;
  var mounted;
  var dispose;
  dialogcontent = new DialogContent({
    props: {
      $$slots: {
        footer: [create_footer_slot],
        body: [create_body_slot]
      },
      $$scope: {
        ctx: ctx
      }
    }
  });
  return {
    c: function c() {
      form = element("form");
      create_component(dialogcontent.$$.fragment);
      attr(form, "data-testid", "prompt__form");
      attr(form, "class",
      /*formClass*/
      ctx[4]);
      toggle_class(form, "touched",
      /*touched*/
      ctx[1]);
    },
    m: function m(target, anchor) {
      insert(target, form, anchor);
      mount_component(dialogcontent, form, null);
      current = true;

      if (!mounted) {
        dispose = listen(form, "submit", prevent_default(
        /*handleSubmit*/
        ctx[13]));
        mounted = true;
      }
    },
    p: function p(ctx, _ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          dirty = _ref2[0];

      var dialogcontent_changes = {};

      if (dirty &
      /*$$scope, touched, inputs, $form$*/
      4194311) {
        dialogcontent_changes.$$scope = {
          dirty: dirty,
          ctx: ctx
        };
      }

      dialogcontent.$set(dialogcontent_changes);

      if (dirty &
      /*touched*/
      2) {
        toggle_class(form, "touched",
        /*touched*/
        ctx[1]);
      }
    },
    i: function i(local) {
      if (current) return;
      transition_in(dialogcontent.$$.fragment, local);
      current = true;
    },
    o: function o(local) {
      transition_out(dialogcontent.$$.fragment, local);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) detach(form);
      destroy_component(dialogcontent);
      mounted = false;
      dispose();
    }
  };
}

function instance$2($$self, $$props, $$invalidate) {
  var $form$;
  var _$$props$inputs = $$props.inputs,
      inputs = _$$props$inputs === void 0 ? [] : _$$props$inputs;
  /** flag touched class on submit to show errors in inputs */

  var touched = false;
  /** retrieve close function from context */

  var close = getClose();
  /** retrieve options from context */

  var _getOptions = getOptions(),
      formClass = _getOptions.formClass,
      cancelButtonClass = _getOptions.cancelButtonClass,
      cancelButtonText = _getOptions.cancelButtonText,
      resetButton = _getOptions.resetButton,
      resetButtonClass = _getOptions.resetButtonClass,
      resetButtonText = _getOptions.resetButtonText,
      submitButtonClass = _getOptions.submitButtonClass,
      submitButtonText = _getOptions.submitButtonText;
  /** maps inputs and create form observable */


  var form$ = writable(inputs.map(inputInitialValueMapping));
  component_subscribe($$self, form$, function (value) {
    return $$invalidate(2, $form$ = value);
  });
  /**
  * Calls close with form values
  */

  function handleSubmit() {
    close(get_store_value(form$));
  }
  /**
  * Reset the form values to the initial mapping and reset touched to false
  */


  function handleReset() {
    form$.set(inputs.map(inputInitialValueMapping));
    $$invalidate(1, touched = false);
  }

  var click_handler = function click_handler() {
    return close(null);
  };

  var click_handler_1 = function click_handler_1() {
    $$invalidate(1, touched = true);
  };

  function switch_instance_value_binding(value, idx) {
    if ($$self.$$.not_equal($form$[idx], value)) {
      $form$[idx] = value;
      form$.set($form$);
    }
  }

  $$self.$$set = function ($$props) {
    if ('inputs' in $$props) $$invalidate(0, inputs = $$props.inputs);
  };

  return [inputs, touched, $form$, close, formClass, cancelButtonClass, cancelButtonText, resetButton, resetButtonClass, resetButtonText, submitButtonClass, submitButtonText, form$, handleSubmit, handleReset, click_handler, click_handler_1, switch_instance_value_binding];
}

var Prompt = /*#__PURE__*/function (_SvelteComponent) {
  _inherits(Prompt, _SvelteComponent);

  var _super = _createSuper$2(Prompt);

  function Prompt(options) {
    var _this;

    _classCallCheck(this, Prompt);

    _this = _super.call(this);
    init(_assertThisInitialized(_this), options, instance$2, create_fragment$2, safe_not_equal, {
      inputs: 0
    });
    return _this;
  }

  return _createClass(Prompt);
}(SvelteComponent);

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var commonDefaultOptions = {
  props: {},
  //
  transitions: {
    bgIn: {
      transition: fade,
      props: {}
    },
    bgOut: {
      transition: fade,
      props: {}
    },
    in: {
      transition: fly,
      props: {
        y: 200,
        duration: 500
      }
    },
    out: {
      transition: fly,
      props: {
        y: 200,
        duration: 500
      }
    }
  },
  //
  onShow: noop,
  onShown: noop,
  onHide: noop,
  onHidden: noop,
  //
  overlayClass: "dialog__overlay",
  dialogClass: "dialog__container",
  closeButtonClass: "dialog__close-button",
  closeButtonText: "",
  //
  headerClass: "dialog__header",
  titleClass: "dialog__title",
  titleId: "dialog-title-id",
  dividerClass: "dialog-content__divider",
  bodyClass: "dialog__body",
  footerClass: "dialog__footer dialog__footer--space-evenly",
  title: "",
  text: "",
  //
  dismissButtonText: "ok",
  confirmButtonText: "yes",
  declineButtonText: "no",
  dismissButtonClass: "dialog__button dialog__button--primary",
  confirmButtonClass: "dialog__button dialog__button--primary",
  declineButtonClass: "dialog__button dialog__button--decline"
};
var defaultDialogOptions = _objectSpread$1(_objectSpread$1({}, commonDefaultOptions), {}, {
  //
  content: DialogContent,
  //
  closeButton: true,
  closeOnBg: true,
  closeOnEsc: true
});
var defaultAlertOptions = _objectSpread$1(_objectSpread$1({}, commonDefaultOptions), {}, {
  //
  content: Alert,
  //
  closeButton: false,
  closeOnBg: false,
  closeOnEsc: false
});
var defaultConfirmOptions = _objectSpread$1(_objectSpread$1({}, commonDefaultOptions), {}, {
  //
  content: Confirm,
  //
  closeButton: false,
  closeOnBg: false,
  closeOnEsc: false,
  title: "are you sure you want to continue?"
});
var defaultPromptOptions = _objectSpread$1(_objectSpread$1({}, commonDefaultOptions), {}, {
  //
  content: Prompt,
  //
  closeButton: false,
  closeOnBg: false,
  closeOnEsc: false,
  footerClass: "dialog__footer dialog__footer--space-between dialog__footer--mobile-responsive",
  //
  inputComponent: DialogInput,
  inputProps: null,
  resetButton: true,
  formClass: "dialog__form",
  formElementClass: "dialog__form-element",
  inputLabelClass: "dialog__input-label",
  inputClass: "dialog__input",
  submitButtonText: "submit",
  cancelButtonText: "cancel",
  resetButtonText: "reset",
  submitButtonClass: "dialog__button dialog__button--primary",
  cancelButtonClass: "dialog__button dialog__button--decline",
  resetButtonClass: "dialog__button dialog__button--primary"
});
var commonContextualOptions = {
  dialogClass: "dialog__container dialog__container--no-padding",
  titleClass: "dialog__title dialog__title--xx-large",
  bodyClass: "dialog__body dialog__body--contextual",
  footerClass: "dialog__footer dialog__footer--space-evenly dialog__footer--contextual"
};
var defaultErrorOptions = _objectSpread$1(_objectSpread$1(_objectSpread$1({}, defaultAlertOptions), commonContextualOptions), {}, {
  title: "Error!",
  headerClass: "dialog__header dialog__header--error",
  dismissButtonClass: "dialog__button dialog__button--error"
});
var defaultSuccessOptions = _objectSpread$1(_objectSpread$1(_objectSpread$1({}, defaultAlertOptions), commonContextualOptions), {}, {
  title: "Success!",
  headerClass: "dialog__header dialog__header--success",
  dismissButtonClass: "dialog__button dialog__button--success"
});
var defaultWarningOptions = _objectSpread$1(_objectSpread$1(_objectSpread$1({}, defaultAlertOptions), commonContextualOptions), {}, {
  title: "Warning!",
  headerClass: "dialog__header dialog__header--warning",
  dismissButtonClass: "dialog__button dialog__button--warning"
});
/** default options for each dialog type */

var defaultDialogConfigOptions = {
  global: defaultDialogOptions,
  alert: defaultAlertOptions,
  confirm: defaultConfirmOptions,
  prompt: defaultPromptOptions,
  error: defaultErrorOptions,
  success: defaultSuccessOptions,
  warning: defaultWarningOptions
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var customConfig = {};
/**
 * Sets the user configurations for dialogs
 * @param {object} options - options to set
 * @param {object} options.global - global options
 * @param {object} options.alert - alert options
 * @param {object} options.confirm - confirm options
 * @param {object} options.prompt - prompt options
 * @param {object} options.error - error options
 * @param {object} options.success - success options
 * @param {object} options.warning - warning options
 */

var config = function config(options) {
  customConfig = options;
};
/**
 * Resolves the options to be passed at a dialog
 * @param {string} type - configuration type to retrieve
 * @param {object} options - options passed in callers
 * @returns {object} - the resolved options
 */

var getOpts = function getOpts(type) {
  var _customConfig$type, _customConfig$global;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  /** retrieve configurations for the iven type */
  var defaults = defaultDialogConfigOptions[type];
  var custom = (_customConfig$type = customConfig[type]) !== null && _customConfig$type !== void 0 ? _customConfig$type : {};
  var customGlobal = (_customConfig$global = customConfig.global) !== null && _customConfig$global !== void 0 ? _customConfig$global : {};
  /**
   * Merge props separately for nested properties.
   * It's not necessary to clone deep, props
   * should be overwritten completely
   */

  var props = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaults.props), customGlobal.props), custom.props), options.props);
  /**
   * Merge transitions configuration and
   * resolve the string transitions
   */


  var transitions = resolveConfigTransitions(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaults.transitions), customGlobal.transitions), custom.transitions), options.transitions));
  /** merge all the options */

  return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaults), customGlobal), custom), options), {}, {
    props: props,
    transitions: transitions
  });
};

var trapFocusList = [];
var focusableSelector = "a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]";

if (typeof window !== "undefined") {
  var isNext = function isNext(event) {
    return event.key === "Tab" && !event.shiftKey;
  };

  var isPrevious = function isPrevious(event) {
    return event.key === "Tab" && event.shiftKey;
  };

  var trapFocusListener = function trapFocusListener(event) {
    /** if the target windows, then focus should work */
    if (event.target === window) {
      return;
    }

    var eventTarget = event.target;
    /** if the target is not a trapped node child, then the parent could't be focused. */

    var parentNode = trapFocusList.find(function (node) {
      return node.contains(eventTarget);
    });

    if (!parentNode) {
      return;
    }
    /**
     * Search for all focusable children of the node.
     * If there aren't any, then keep focusing the node itself.
     */


    var focusable = parentNode.querySelectorAll(focusableSelector);

    if (!focusable.length) {
      event.preventDefault();
      return;
    }
    /** traps the focus in the focusables */


    var first = focusable[0];
    var last = focusable[focusable.length - 1];

    if (isNext(event) && event.target === last) {
      event.preventDefault();
      first.focus();
    } else if (isPrevious(event) && event.target === first) {
      event.preventDefault();
      last.focus();
    }
  };

  document.addEventListener("keydown", trapFocusListener);
}
/**
 * Focus trap svelte action
 * https://gist.github.com/JulienPradet/20dbb7ca06cbd9e2ec499bb2206aab55
 * @param {Element} node - the target html element
 * @returns {object} - the object containing the destroy function
 */


var focusTrap = function focusTrap(node) {
  /** makes the current node focusable by javascript */
  node.setAttribute("tabindex", "-1");
  /** search for a focusable in node children. If not present, fous the node */

  var firstFocusable = node.querySelector(focusableSelector);
  firstFocusable ? firstFocusable.focus() : node.focus();
  /** adds the node in the trapped elements */

  trapFocusList.push(node);
  return {
    destroy: function destroy() {
      /** remove the tabindex attribute and remove the node from the trapped elements */
      node.removeAttribute("tabindex");
      trapFocusList = trapFocusList.filter(function (element) {
        return element !== node;
      });
    }
  };
};

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function create_if_block_2(ctx) {
  var button;
  var mounted;
  var dispose;
  return {
    c: function c() {
      button = element("button");
      attr(button, "class",
      /*closeButtonClass*/
      ctx[5]);
      attr(button, "aria-label", "Close dialog");
      attr(button, "data-testid", "dialog-core__close-button");
    },
    m: function m(target, anchor) {
      insert(target, button, anchor);
      button.innerHTML =
      /*closeButtonText*/
      ctx[6];

      if (!mounted) {
        dispose = listen(button, "click",
        /*click_handler*/
        ctx[23]);
        mounted = true;
      }
    },
    p: noop,
    d: function d(detaching) {
      if (detaching) detach(button);
      mounted = false;
      dispose();
    }
  };
} // (155:4) {:else}


function create_else_block(ctx) {
  var switch_instance;
  var switch_instance_anchor;
  var current;
  var switch_instance_spread_levels = [
  /*props*/
  ctx[8]];
  var switch_value =
  /*content*/
  ctx[7];

  function switch_props(ctx) {
    var switch_instance_props = {};

    for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }

    return {
      props: switch_instance_props
    };
  }

  if (switch_value) {
    switch_instance = new switch_value(switch_props());
  }

  return {
    c: function c() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }

      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function p(ctx, dirty) {
      var switch_instance_changes = dirty[0] &
      /*props*/
      256 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
      /*props*/
      ctx[8])]) : {};

      if (switch_value !== (switch_value =
      /*content*/
      ctx[7])) {
        if (switch_instance) {
          group_outros();
          var old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, function () {
            destroy_component(old_component, 1);
          });
          check_outros();
        }

        if (switch_value) {
          switch_instance = new switch_value(switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function d(detaching) {
      if (detaching) detach(switch_instance_anchor);
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
} // (153:42) 


function create_if_block_1(ctx) {
  var html_tag;
  var html_anchor;
  return {
    c: function c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function m(target, anchor) {
      html_tag.m(
      /*content*/
      ctx[7], target, anchor);
      insert(target, html_anchor, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function d(detaching) {
      if (detaching) detach(html_anchor);
      if (detaching) html_tag.d();
    }
  };
} // (151:4) {#if $$slots.default}


function create_if_block$1(ctx) {
  var current;
  var default_slot_template =
  /*#slots*/
  ctx[22].default;
  var default_slot = create_slot(default_slot_template, ctx,
  /*$$scope*/
  ctx[21], null);
  return {
    c: function c() {
      if (default_slot) default_slot.c();
    },
    m: function m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }

      current = true;
    },
    p: function p(ctx, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] &
        /*$$scope*/
        2097152)) {
          update_slot_base(default_slot, default_slot_template, ctx,
          /*$$scope*/
          ctx[21], !current ? get_all_dirty_from_scope(
          /*$$scope*/
          ctx[21]) : get_slot_changes(default_slot_template,
          /*$$scope*/
          ctx[21], dirty, null), null);
        }
      }
    },
    i: function i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}

function create_fragment$1(ctx) {
  var div1;
  var div0;
  var t;
  var current_block_type_index;
  var if_block1;
  var div0_intro;
  var div0_outro;
  var div1_intro;
  var div1_outro;
  var current;
  var mounted;
  var dispose;
  var if_block0 =
  /*closeButton*/
  ctx[4] && create_if_block_2(ctx);
  var if_block_creators = [create_if_block$1, create_if_block_1, create_else_block];
  var if_blocks = [];

  function select_block_type(ctx, dirty) {
    if (
    /*$$slots*/
    ctx[19].default) return 0;
    if (typeof
    /*content*/
    ctx[7] === "string") return 1;
    return 2;
  }

  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c: function c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0) if_block0.c();
      t = space();
      if_block1.c();
      attr(div0, "class",
      /*dialogClass*/
      ctx[2]);
      attr(div0, "role", "dialog");
      attr(div0, "aria-modal", "true");
      attr(div0, "aria-labelledby",
      /*titleId*/
      ctx[3]);
      attr(div0, "data-testid", "dialog-core__dialog");
      attr(div1, "class",
      /*overlayClass*/
      ctx[1]);
      attr(div1, "data-testid", "dialog-core__overlay");
      attr(div1, "tabindex", "-1");
    },
    m: function m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0) if_block0.m(div0, null);
      append(div0, t);
      if_blocks[current_block_type_index].m(div0, null);
      current = true;

      if (!mounted) {
        dispose = [listen(window, "keydown",
        /*handleKeydown*/
        ctx[17]), listen(div0, "introstart",
        /*show*/
        ctx[13]), listen(div0, "introend",
        /*shown*/
        ctx[14]), listen(div0, "outrostart",
        /*hide*/
        ctx[15]), listen(div0, "outroend",
        /*hidden*/
        ctx[16]), listen(div0, "click", handleDialogClick), listen(div1, "click",
        /*handleBgClick*/
        ctx[18]), action_destroyer(focusTrap.call(null, div1))];
        mounted = true;
      }
    },
    p: function p(ctx, dirty) {
      if (
      /*closeButton*/
      ctx[4]) if_block0.p(ctx, dirty);
      var previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);

      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, function () {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];

        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block1.c();
        } else {
          if_block1.p(ctx, dirty);
        }

        transition_in(if_block1, 1);
        if_block1.m(div0, null);
      }
    },
    i: function i(local) {
      if (current) return;
      transition_in(if_block1);
      add_render_callback(function () {
        if (div0_outro) div0_outro.end(1);
        div0_intro = create_in_transition(div0,
        /*dialogInTransition*/
        ctx[11], {});
        div0_intro.start();
      });
      add_render_callback(function () {
        if (div1_outro) div1_outro.end(1);
        div1_intro = create_in_transition(div1,
        /*bgInTransition*/
        ctx[9], {});
        div1_intro.start();
      });
      current = true;
    },
    o: function o(local) {
      transition_out(if_block1);
      if (div0_intro) div0_intro.invalidate();
      div0_outro = create_out_transition(div0,
      /*dialogOutTransition*/
      ctx[12], {});
      if (div1_intro) div1_intro.invalidate();
      div1_outro = create_out_transition(div1,
      /*bgOutTransition*/
      ctx[10], {});
      current = false;
    },
    d: function d(detaching) {
      if (detaching) detach(div1);
      if (if_block0) if_block0.d();
      if_blocks[current_block_type_index].d();
      if (detaching && div0_outro) div0_outro.end();
      if (detaching && div1_outro) div1_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}

function handleDialogClick(event) {
  event.stopPropagation();
}

function instance$1($$self, $$props, $$invalidate) {
  var _$$props$$$slots = $$props.$$slots,
      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
      $$scope = $$props.$$scope;
  var $$slots = compute_slots(slots);
  var dispatch = createEventDispatcher();
  var close = $$props.close;
  var opts = $$props.opts;
  var _opts = opts,
      transitions = _opts.transitions,
      onShow = _opts.onShow,
      onShown = _opts.onShown,
      onHide = _opts.onHide,
      onHidden = _opts.onHidden,
      closeOnEsc = _opts.closeOnEsc,
      closeOnBg = _opts.closeOnBg,
      overlayClass = _opts.overlayClass,
      dialogClass = _opts.dialogClass,
      titleId = _opts.titleId,
      closeButton = _opts.closeButton,
      closeButtonClass = _opts.closeButtonClass,
      closeButtonText = _opts.closeButtonText,
      content = _opts.content,
      props = _opts.props;
  /** puts the close function in the context*/

  setClose(close);
  /** puts the options in the context*/

  setOptions(opts);
  /** apply background in transition */

  function bgInTransition(node, _) {
    return applyTransition(node, transitions.bgIn);
  }
  /** apply background out transition */


  function bgOutTransition(node, _) {
    return applyTransition(node, transitions.bgOut);
  }
  /** apply dialog in transition */


  function dialogInTransition(node, _) {
    return applyTransition(node, transitions.in);
  }
  /** apply dialog out transition */


  function dialogOutTransition(node, _) {
    return applyTransition(node, transitions.out);
  }
  /** call onShow callback and dispatch show event */


  function show() {
    onShow();
    dispatch("show");
  }
  /** call onShown callback and dispatch shown event */


  function shown() {
    onShown();
    dispatch("shown");
  }
  /** call onHide callback and dispatch hide event */


  function hide() {
    onHide();
    dispatch("hide");
  }
  /** call onHidden callback and dispatch hidden event */


  function hidden() {
    onHidden();
    dispatch("hidden");
  }
  /**
  * if closeOnEsc option is true, close the dialog on Escape keydown
  * @param event
  */


  function handleKeydown(event) {
    if (closeOnEsc && event.key === "Escape") {
      event.preventDefault();
      close();
    }
  }
  /**
  * if closeOnBg option is true, close the dialog on background click
  * @param event
  */


  function handleBgClick() {
    if (closeOnBg) {
      close();
    }
  }

  var click_handler = function click_handler() {
    return close();
  };

  $$self.$$set = function ($$props) {
    if ('close' in $$props) $$invalidate(0, close = $$props.close);
    if ('opts' in $$props) $$invalidate(20, opts = $$props.opts);
    if ('$$scope' in $$props) $$invalidate(21, $$scope = $$props.$$scope);
  };

  return [close, overlayClass, dialogClass, titleId, closeButton, closeButtonClass, closeButtonText, content, props, bgInTransition, bgOutTransition, dialogInTransition, dialogOutTransition, show, shown, hide, hidden, handleKeydown, handleBgClick, $$slots, opts, $$scope, slots, click_handler];
}

var DialogCore = /*#__PURE__*/function (_SvelteComponent) {
  _inherits(DialogCore, _SvelteComponent);

  var _super = _createSuper$1(DialogCore);

  function DialogCore(options) {
    var _this;

    _classCallCheck(this, DialogCore);

    _this = _super.call(this);
    init(_assertThisInitialized(_this), options, instance$1, create_fragment$1, safe_not_equal, {
      close: 0,
      opts: 20
    }, null, [-1, -1]);
    return _this;
  }

  return _createClass(DialogCore);
}(SvelteComponent);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var get_default_slot_changes = function get_default_slot_changes(dirty) {
  return {
    data: dirty &
    /*_data*/
    4
  };
};

var get_default_slot_context = function get_default_slot_context(ctx) {
  return {
    close:
    /*close*/
    ctx[0],
    data:
    /*_data*/
    ctx[2]
  };
}; // (96:0) {#if visible}


function create_if_block(ctx) {
  var dialogcore;
  var current;
  dialogcore = new DialogCore({
    props: {
      close:
      /*close*/
      ctx[0],
      opts:
      /*opts*/
      ctx[3],
      $$slots: {
        default: [create_default_slot]
      },
      $$scope: {
        ctx: ctx
      }
    }
  });
  dialogcore.$on("show",
  /*show_handler*/
  ctx[8]);
  dialogcore.$on("shown",
  /*shown_handler*/
  ctx[9]);
  dialogcore.$on("hidden",
  /*hidden_handler*/
  ctx[10]);
  return {
    c: function c() {
      create_component(dialogcore.$$.fragment);
    },
    m: function m(target, anchor) {
      mount_component(dialogcore, target, anchor);
      current = true;
    },
    p: function p(ctx, dirty) {
      var dialogcore_changes = {};
      if (dirty &
      /*opts*/
      8) dialogcore_changes.opts =
      /*opts*/
      ctx[3];

      if (dirty &
      /*$$scope, _data*/
      2052) {
        dialogcore_changes.$$scope = {
          dirty: dirty,
          ctx: ctx
        };
      }

      dialogcore.$set(dialogcore_changes);
    },
    i: function i(local) {
      if (current) return;
      transition_in(dialogcore.$$.fragment, local);
      current = true;
    },
    o: function o(local) {
      transition_out(dialogcore.$$.fragment, local);
      current = false;
    },
    d: function d(detaching) {
      destroy_component(dialogcore, detaching);
    }
  };
} // (97:2) <DialogCore {close} {opts} on:show on:shown on:hidden>


function create_default_slot(ctx) {
  var current;
  var default_slot_template =
  /*#slots*/
  ctx[7].default;
  var default_slot = create_slot(default_slot_template, ctx,
  /*$$scope*/
  ctx[11], get_default_slot_context);
  return {
    c: function c() {
      if (default_slot) default_slot.c();
    },
    m: function m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }

      current = true;
    },
    p: function p(ctx, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty &
        /*$$scope, _data*/
        2052)) {
          update_slot_base(default_slot, default_slot_template, ctx,
          /*$$scope*/
          ctx[11], !current ? get_all_dirty_from_scope(
          /*$$scope*/
          ctx[11]) : get_slot_changes(default_slot_template,
          /*$$scope*/
          ctx[11], dirty, get_default_slot_changes), get_default_slot_context);
        }
      }
    },
    i: function i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}

function create_fragment(ctx) {
  var if_block_anchor;
  var current;
  var if_block =
  /*visible*/
  ctx[1] && create_if_block(ctx);
  return {
    c: function c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m: function m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p: function p(ctx, _ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          dirty = _ref2[0];

      if (
      /*visible*/
      ctx[1]) {
        if (if_block) {
          if_block.p(ctx, dirty);

          if (dirty &
          /*visible*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, function () {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function o(local) {
      transition_out(if_block);
      current = false;
    },
    d: function d(detaching) {
      if (if_block) if_block.d(detaching);
      if (detaching) detach(if_block_anchor);
    }
  };
}

function instance($$self, $$props, $$invalidate) {
  var opts;
  var _$$props$$$slots = $$props.$$slots,
      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
      $$scope = $$props.$$scope;
  var dispatch = createEventDispatcher();
  var _$$props$options = $$props.options,
      options = _$$props$options === void 0 ? {} : _$$props$options;
  /** flag for render logic */

  var visible = false;
  /** internal reference at data passed to open function */

  var _data = null;

  function open(data) {
    $$invalidate(2, _data = data);
    $$invalidate(1, visible = true);
  }

  function close(data) {
    dispatch("hide", data);
    $$invalidate(1, visible = false);
  }

  function data() {
    return _data;
  }

  function show_handler(event) {
    bubble.call(this, $$self, event);
  }

  function shown_handler(event) {
    bubble.call(this, $$self, event);
  }

  function hidden_handler(event) {
    bubble.call(this, $$self, event);
  }

  $$self.$$set = function ($$props) {
    if ('options' in $$props) $$invalidate(4, options = $$props.options);
    if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
  };

  $$self.$$.update = function () {
    if ($$self.$$.dirty &
    /*options*/
    16) {
      /** merged options */
      $$invalidate(3, opts = getOpts("global", options));
    }
  };

  return [close, visible, _data, opts, options, open, data, slots, show_handler, shown_handler, hidden_handler, $$scope];
}

var Dialog = /*#__PURE__*/function (_SvelteComponent) {
  _inherits(Dialog, _SvelteComponent);

  var _super = _createSuper(Dialog);

  function Dialog(options) {
    var _this;

    _classCallCheck(this, Dialog);

    _this = _super.call(this);
    init(_assertThisInitialized(_this), options, instance, create_fragment, safe_not_equal, {
      options: 4,
      open: 5,
      close: 0,
      data: 6
    });
    return _this;
  }

  _createClass(Dialog, [{
    key: "open",
    get: function get() {
      return this.$$.ctx[5];
    }
  }, {
    key: "close",
    get: function get() {
      return this.$$.ctx[0];
    }
  }, {
    key: "data",
    get: function get() {
      return this.$$.ctx[6];
    }
  }]);

  return Dialog;
}(SvelteComponent);

/**
 * Renders a DialogCore with html body as target
 * @param {object} opts - configuration object
 * @returns {Promise} - the promise associated with the rendered DialogCore
 */

var createDialog = function createDialog(opts) {
  var close;
  /** create the Promise and et a ref of the resolve method */

  var promise = new Promise(function (resolve) {
    close = resolve;
  });
  /**
   * Create a DialogCore instance with options and resolve ref.
   * Target is set to the document body, intro make the
   * transitions work on instance creatrion.
   */

  var dialog = new DialogCore({
    target: document.body,
    intro: true,
    props: {
      close: close,
      opts: opts
    }
  });
  /**
   * Retrun the Promise associated with the resolve ref
   * passed as a prop.
   * outroAndDestroy make the transitions work on instance
   * destruction.
   */

  return promise.finally(function () {
    outroAndDestroy(dialog);
  });
};

/**
 * Renders a modal
 * @param {(string|function|object)} options - the dialog options
 * @param {object} props - the props of a custom component content
 * @returns {Promise} - the promise associated with the rendered DialogCore
 */

var modal = function modal(options, props) {
  var opts;

  if (typeof options === "string" || typeof options === "function") {
    /** if options is a string or a SvelteComponent, use it as content */
    opts = getOpts("global");
    opts.content = options;
    /** used by SvelteComponent, ignored by string content */

    if (props) {
      opts.props = props;
    }
  } else {
    /** if options is an object, it's merged in configuration */
    opts = getOpts("global", options);
  }

  return createDialog(opts);
};
/**
 * Renders an alert
 * @param {(string|object)} options - the dialog options
 * @returns {Promise} - the promise associated with the rendered DialogCore
 */

var alert = function alert(options) {
  var opts;

  if (typeof options === "string") {
    /** if options is a string, it's used as title option */
    opts = getOpts("alert");
    opts.title = options;
  } else {
    /** if options is an object, it's merged in configuration */
    opts = getOpts("alert", options);
  }

  return createDialog(opts);
};
/**
 * Renders a confirm
 * @param {(string|object)} options - the dialog options
 * @returns {Promise} - the promise associated with the rendered DialogCore
 */

var confirm = function confirm(options) {
  var opts;

  if (typeof options === "string") {
    /** if options is a string, it's used as title option */
    opts = getOpts("confirm");
    opts.title = options;
  } else {
    /** if options is an object, it's merged in configuration */
    opts = getOpts("confirm", options);
  }

  return createDialog(opts);
};
/**
 * Renders a prompt
 * @param {(string|object|function)} input - the inputs to be shown in the prompt
 * @param {(object)} options - the dialog options
 * @returns {Promise} - the promise associated with the rendered DialogCore
 */

var prompt = function prompt(input, options) {
  /** puts input in an array if is not an array already, then map the inputs array */
  var inputs = (Array.isArray(input) ? input : [input]).map(promptInputMapping);
  var opts = getOpts("prompt", options);
  /** set the inputs props of the option */

  opts.props.inputs = getInputsWithProps(inputs, opts);
  return createDialog(opts);
};
/**
 * Renders an error
 * @param {(string|object)} options - the dialog options
 * @returns {Promise} - the promise associated with the rendered DialogCore
 */

var error = function error(options) {
  var opts;

  if (typeof options === "string") {
    /** if options is a string, it's used as text option */
    opts = getOpts("error");
    opts.text = options;
  } else {
    /** if options is an object, it's merged in configuration */
    opts = getOpts("error", options);
  }

  return createDialog(opts);
};
/**
 * Renders a success
 * @param {(string|object)} options - the dialog options
 * @returns {Promise} - the promise associated with the rendered DialogCore
 */

var success = function success(options) {
  var opts;

  if (typeof options === "string") {
    /** if options is a string, it's used as text option */
    opts = getOpts("success");
    opts.text = options;
  } else {
    /** if options is an object, it's merged in configuration */
    opts = getOpts("success", options);
  }

  return createDialog(opts);
};
/**
 * Renders a warning
 * @param {(string|object)} options - the dialog options
 * @returns {Promise} - the promise associated with the rendered DialogCore
 */

var warning = function warning(options) {
  var opts;

  if (typeof options === "string") {
    /** if options is a string, it's used as text option */
    opts = getOpts("warning");
    opts.text = options;
  } else {
    /** if options is an object, it's merged in configuration */
    opts = getOpts("warning", options);
  }

  return createDialog(opts);
};

var dialogs = {
  alert: alert,
  confirm: confirm,
  modal: modal,
  prompt: prompt,
  error: error,
  success: success,
  warning: warning,
  config: config
};

export { Alert, Confirm, Dialog, DialogContent, DialogInput, Prompt, dialogs, getClose, getOptions };
