import {
  derived,
  writable
} from "./chunk-7SIBWDBT.js";
import "./chunk-6A2TAOKG.js";
import {
  HtmlTag,
  SvelteComponentDev,
  add_location,
  afterUpdate,
  append_dev,
  append_styles,
  attr_dev,
  beforeUpdate,
  binding_callbacks,
  bubble,
  check_outros,
  component_subscribe,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_store_value,
  group_outros,
  init,
  insert_dev,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onMount,
  outro_and_destroy_block,
  prevent_default,
  run_all,
  safe_not_equal,
  set_data_dev,
  set_input_value,
  set_store_value,
  set_style,
  space,
  src_url_equal,
  subscribe,
  svg_element,
  text as text2,
  to_number,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-4NZVM4V3.js";
import "./chunk-HYZYPRER.js";

// node_modules/d3-dispatch/src/dispatch.js
var noop2 = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _)
      copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop2, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
    name = name.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

// node_modules/d3-selection/src/selectorAll.js
function empty2() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty2 : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function")
    select = arrayAll(select);
  else
    select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key2) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key2.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key2.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value2, key2) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key2 ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value2 !== "function")
    value2 = constant_default(value2);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value2.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key2);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare)
    compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node)
        return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value2) {
  return function() {
    this.setAttribute(name, value2);
  };
}
function attrConstantNS(fullname, value2) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value2);
  };
}
function attrFunction(name, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name, value2) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value2 == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value2 === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value2));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value2, priority) {
  return function() {
    this.style.setProperty(name, value2, priority);
  };
}
function styleFunction(name, value2, priority) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v, priority);
  };
}
function style_default(name, value2, priority) {
  return arguments.length > 1 ? this.each((value2 == null ? styleRemove : typeof value2 === "function" ? styleFunction : styleConstant)(name, value2, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value2) {
  return function() {
    this[name] = value2;
  };
}
function propertyFunction(name, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null)
      delete this[name];
    else
      this[name] = v;
  };
}
function property_default(name, value2) {
  return arguments.length > 1 ? this.each((value2 == null ? propertyRemove : typeof value2 === "function" ? propertyFunction : propertyConstant)(name, value2)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value2) {
  return function() {
    (value2.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value2) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value2 === "function" ? classedFunction : value2 ? classedTrue : classedFalse)(names, value2));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value2) {
  return function() {
    this.textContent = value2;
  };
}
function textFunction(value2) {
  return function() {
    var v = value2.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value2) {
  return arguments.length ? this.each(value2 == null ? textRemove : (typeof value2 === "function" ? textFunction : textConstant)(value2)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value2) {
  return function() {
    this.innerHTML = value2;
  };
}
function htmlFunction(value2) {
  return function() {
    var v = value2.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value2) {
  return arguments.length ? this.each(value2 == null ? htmlRemove : (typeof value2 === "function" ? htmlFunction : htmlConstant)(value2)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value2) {
  return arguments.length ? this.property("__data__", value2) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value2, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value2);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value2;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value: value2, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function on_default(typename, value2, options) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value2 ? onAdd : onRemove;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value2, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function dispatch_default2(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/local.js
var nextId = 0;
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id2 = this._;
    while (!(id2 in node))
      if (!(node = node.parentNode))
        return;
    return node[id2];
  },
  set: function(node, value2) {
    return node[this._] = value2;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent)
    event = sourceEvent;
  return event;
}

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// node_modules/d3-selection/src/selectAll.js
function selectAll_default2(selector) {
  return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([array(selector)], root);
}

// node_modules/d3-drag/src/noevent.js
var nonpassivecapture = { capture: true, passive: false };
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}

// node_modules/d3-drag/src/event.js
function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x,
  y,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x, enumerable: true, configurable: true },
    y: { value: y, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value2 = this._.on.apply(this._, arguments);
  return value2 === this._ ? this : value2;
};

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key2 in definition)
    prototype[key2] = definition[key2];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex(value2) {
  value2 = clampi(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
  if (s) {
    if (r === max)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b)
    x = z = y;
  else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
      lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x) {
  return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh2 + B * sinh2)),
      255 * (l + a * (C * cosh2 + D * sinh2)),
      255 * (l + a * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default3 = (x) => () => x;

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default3(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default3(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start2, end) {
    var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e2, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e2,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value2) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
  return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value2) {
  if (value2 == null)
    return identity;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value2);
  if (!(value2 = svgNode.transform.baseVal.consolidate()))
    return identity;
  value2 = value2.matrix;
  return decompose_default(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start2, end) {
    var h = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.h = h(t);
      start2.s = s(t);
      start2.l = l(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start2, end) {
    var h = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c = nogamma(start2.c, end.c), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.h = h(t);
      start2.c = c(t);
      start2.l = l(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y) {
    y = +y;
    function cubehelix3(start2, end) {
      var h = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.h = h(t);
        start2.s = s(t);
        start2.l = l(Math.pow(t, y));
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e2;
  while (t) {
    if ((e2 = clockNow - t._time) >= 0)
      t._call.call(void 0, e2);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t22, time = Infinity;
  while (t12) {
    if (t12._call) {
      if (time > t12._time)
        time = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED)
    throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2]))
    throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self) {
  var schedules = node.__transition, tween;
  schedules[id2] = self;
  self.timer = timer(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed)
      start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name)
        continue;
      if (o.state === STARTED)
        return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING)
      return;
    self.state = STARTED;
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty3 = true, i;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty3 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty3)
    delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value2) {
  var tween0, tween1;
  if (typeof value2 !== "function")
    throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value: value2 }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value2) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value2 == null ? tweenRemove : tweenFunction)(id2, name, value2));
}
function tweenValue(transition2, name, value2) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value2.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a, b) {
  var c;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value2(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value2(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value2) {
  var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value2 === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value2)) : value2 == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value2));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value2) {
  var t02, i0;
  function tween() {
    var i = value2.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t02;
  }
  tween._value = value2;
  return tween;
}
function attrTween(name, value2) {
  var t02, i0;
  function tween() {
    var i = value2.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && attrInterpolate(name, i);
    return t02;
  }
  tween._value = value2;
  return tween;
}
function attrTween_default(name, value2) {
  var key2 = "attr." + name;
  if (arguments.length < 2)
    return (key2 = this.tween(key2)) && key2._value;
  if (value2 == null)
    return this.tween(key2, null);
  if (typeof value2 !== "function")
    throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key2, (fullname.local ? attrTweenNS : attrTween)(fullname, value2));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value2) {
  return function() {
    init2(this, id2).delay = +value2.apply(this, arguments);
  };
}
function delayConstant(id2, value2) {
  return value2 = +value2, function() {
    init2(this, id2).delay = value2;
  };
}
function delay_default(value2) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value2 === "function" ? delayFunction : delayConstant)(id2, value2)) : get2(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value2) {
  return function() {
    set2(this, id2).duration = +value2.apply(this, arguments);
  };
}
function durationConstant(id2, value2) {
  return value2 = +value2, function() {
    set2(this, id2).duration = value2;
  };
}
function duration_default(value2) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value2 === "function" ? durationFunction : durationConstant)(id2, value2)) : get2(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value2) {
  if (typeof value2 !== "function")
    throw new Error();
  return function() {
    set2(this, id2).ease = value2;
  };
}
function ease_default(value2) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value2)) : get2(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (typeof v !== "function")
      throw new Error();
    set2(this, id2).ease = v;
  };
}
function easeVarying_default(value2) {
  if (typeof value2 !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value2));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init2 : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children2 = select.call(node, node.__data__, i, group), child, inherit2 = get2(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule_default(child, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value2(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key2 = "style." + name, event = "end." + key2, remove2;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key2] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value2, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value2 == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value2 === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value2))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value2), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value2, priority) {
  var t, i0;
  function tween() {
    var i = value2.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value2;
  return tween;
}
function styleTween_default(name, value2, priority) {
  var key2 = "style." + (name += "");
  if (arguments.length < 2)
    return (key2 = this.tween(key2)) && key2._value;
  if (value2 == null)
    return this.tween(key2, null);
  if (typeof value2 !== "function")
    throw new Error();
  return this.tween(key2, styleTween(name, value2, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value2) {
  return function() {
    this.textContent = value2;
  };
}
function textFunction2(value2) {
  return function() {
    var value1 = value2(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value2) {
  return this.tween("text", typeof value2 === "function" ? textFunction2(tweenValue(this, "text", value2)) : textConstant2(value2 == null ? "" : value2 + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value2) {
  var t02, i0;
  function tween() {
    var i = value2.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && textInterpolate(i);
    return t02;
  }
  tween._value = value2;
  return tween;
}
function textTween_default(value2) {
  var key2 = "text";
  if (arguments.length < 1)
    return (key2 = this.tween(key2)) && key2._value;
  if (value2 == null)
    return this.tween(key2, null);
  if (typeof value2 !== "function")
    throw new Error();
  return this.tween(key2, textTween(value2));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get2(node, id0);
        schedule_default(node, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0)
      resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default3,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = function custom(e2) {
  e2 = +e2;
  function polyIn2(t) {
    return Math.pow(t, e2);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent);
var polyOut = function custom2(e2) {
  e2 = +e2;
  function polyOut2(t) {
    return 1 - Math.pow(1 - t, e2);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent);
var polyInOut = function custom3(e2) {
  e2 = +e2;
  function polyInOut2(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e2) : 2 - Math.pow(2 - t, e2)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent);

// node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;

// node_modules/d3-ease/src/math.js
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 9765625e-10) * 1.0009775171065494;
}

// node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;

// node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = function custom4(s) {
  s = +s;
  function backIn2(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s) {
  s = +s;
  function backOut2(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s) {
  s = +s;
  function backInOut2(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);

// node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = function custom7(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticIn2(t) {
    return a * tpmt(- --t) * Math.sin((s - t) / p);
  }
  elasticIn2.amplitude = function(a2) {
    return custom7(a2, p * tau);
  };
  elasticIn2.period = function(p2) {
    return custom7(a, p2);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticOut2(t) {
    return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
  }
  elasticOut2.amplitude = function(a2) {
    return custom8(a2, p * tau);
  };
  elasticOut2.period = function(p2) {
    return custom8(a, p2);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticInOut2(t) {
    return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p) : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
  }
  elasticInOut2.amplitude = function(a2) {
    return custom9(a2, p * tau);
  };
  elasticInOut2.period = function(p2) {
    return custom9(a, p2);
  };
  return elasticInOut2;
}(amplitude, period);

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule_default(node, name, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-zoom/src/constant.js
var constant_default4 = (x) => () => x;

// node_modules/d3-zoom/src/event.js
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}

// node_modules/d3-zoom/src/transform.js
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity2 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity2;
  return node.__zoom;
}

// node_modules/d3-zoom/src/noevent.js
function nopropagation2(event) {
  event.stopImmediatePropagation();
}
function noevent_default2(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-zoom/src/zoom.js
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e2 = this;
  if (e2 instanceof SVGElement) {
    e2 = e2.ownerSVGElement || e2;
    if (e2.hasAttribute("viewBox")) {
      e2 = e2.viewBox.baseVal;
      return [[e2.x, e2.y], [e2.x + e2.width, e2.y + e2.height]];
    }
    return [[0, 0], [e2.width.baseVal.value, e2.height.baseVal.value]];
  }
  return [[0, 0], [e2.clientWidth, e2.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity2;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom_default2() {
  var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom.transform = function(collection, transform2, point, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform2, point, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom.scaleBy = function(selection2, k, p, event) {
    zoom.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };
  zoom.scaleTo = function(selection2, k, p, event) {
    zoom.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t02 = this.__zoom, p0 = p == null ? centroid(e2) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t02.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t02, k1), p0, p1), e2, translateExtent);
    }, p, event);
  };
  zoom.translateBy = function(selection2, x, y, event) {
    zoom.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom.translateTo = function(selection2, x, y, p, event) {
    zoom.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e2) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity2.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e2, translateExtent);
    }, p, event);
  };
  function scale(transform2, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x = p0[0] - p1[0] * transform2.k, y = p0[1] - p1[1] * transform2.k;
    return x === transform2.x && y === transform2.y ? transform2 : new Transform(transform2.k, x, y);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule(transition2, transform2, point, event) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e2 = extent.apply(that, args), p = point == null ? centroid(e2) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e2[1][0] - e2[0][0], e2[1][1] - e2[0][1]), a = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1)
          t = b;
        else {
          var l = i(t), k = w / l[2];
          t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event)
        this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key2, transform2) {
      if (this.mouse && key2 !== "mouse")
        this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key2 !== "touch")
        this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key2 !== "touch")
        this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = select_default2(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var g = gesture(this, args).event(event), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer_default(event);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k)
      return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt_default(this);
      g.start();
    }
    noevent_default2(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments))
      return;
    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer_default(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    nodrag_default(event.view);
    nopropagation2(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt_default(this);
    g.start();
    function mousemoved(event2) {
      noevent_default2(event2);
      if (!g.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g.moved);
      noevent_default2(event2);
      g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var t02 = this.__zoom, p0 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t02.invert(p0), k1 = t02.k * (event.shiftKey ? 0.5 : 2), t12 = constrain(translate(scale(t02, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent_default2(event);
    if (duration > 0)
      select_default2(this).transition().duration(duration).call(schedule, t12, p0, event);
    else
      select_default2(this).call(zoom.transform, t12, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;
    nopropagation2(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0)
        g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2])
        g.touch1 = p, g.taps = 0;
    }
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2)
        touchfirst = p[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
      interrupt_default(this);
      g.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;
    noevent_default2(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer_default(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier)
        g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0)
      p = g.touch0[0], l = g.touch0[1];
    else
      return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
    nopropagation2(event);
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier)
        delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        delete g.touch1;
    }
    if (g.touch1 && !g.touch0)
      g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0)
      g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t = pointer_default(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = select_default2(this).on("dblclick.zoom");
          if (p)
            p.apply(this, arguments);
        }
      }
    }
  }
  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant_default4(+_), zoom) : wheelDelta;
  };
  zoom.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant_default4(!!_), zoom) : filter2;
  };
  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default4(!!_), zoom) : touchable;
  };
  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant_default4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };
  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };
  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };
  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };
  zoom.on = function() {
    var value2 = listeners.on.apply(listeners, arguments);
    return value2 === listeners ? zoom : value2;
  };
  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };
  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };
  return zoom;
}

// node_modules/svelvet/Edges/EdgeText.svelte
var file = "node_modules/svelvet/Edges/EdgeText.svelte";
function create_else_block(ctx) {
  let g;
  let rect;
  let rect_fill_value;
  let rect_x_value;
  let rect_y_value;
  let rect_height_value;
  let text_1;
  let t;
  let text_1_fill_value;
  const block = {
    c: function create2() {
      g = svg_element("g");
      rect = svg_element("rect");
      text_1 = svg_element("text");
      t = text2(
        /*label*/
        ctx[0]
      );
      attr_dev(rect, "class", "EdgeTextBg");
      attr_dev(rect, "data-testid", "edge-text-bg");
      attr_dev(rect, "fill", rect_fill_value = /*labelBgColor*/
      ctx[5] ? (
        /*labelBgColor*/
        ctx[5]
      ) : "white");
      attr_dev(rect, "x", rect_x_value = /*textCenterX*/
      ctx[3] - /*labelPx*/
      ctx[1] / 2);
      attr_dev(rect, "y", rect_y_value = /*textCenterY*/
      ctx[2] - shiftRectY);
      attr_dev(
        rect,
        "width",
        /*labelPx*/
        ctx[1]
      );
      attr_dev(rect, "height", rect_height_value = 16);
      add_location(rect, file, 26, 4, 779);
      attr_dev(text_1, "class", "EdgeText");
      attr_dev(
        text_1,
        "x",
        /*textCenterX*/
        ctx[3]
      );
      attr_dev(
        text_1,
        "y",
        /*textCenterY*/
        ctx[2]
      );
      attr_dev(text_1, "font-size", "12px");
      attr_dev(text_1, "dominant-baseline", "central");
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "fill", text_1_fill_value = /*labelTextColor*/
      ctx[4] ? (
        /*labelTextColor*/
        ctx[4]
      ) : "black");
      add_location(text_1, file, 35, 4, 1016);
      add_location(g, file, 25, 2, 771);
    },
    m: function mount(target, anchor) {
      insert_dev(target, g, anchor);
      append_dev(g, rect);
      append_dev(g, text_1);
      append_dev(text_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelBgColor*/
      32 && rect_fill_value !== (rect_fill_value = /*labelBgColor*/
      ctx2[5] ? (
        /*labelBgColor*/
        ctx2[5]
      ) : "white")) {
        attr_dev(rect, "fill", rect_fill_value);
      }
      if (dirty & /*textCenterX, labelPx*/
      10 && rect_x_value !== (rect_x_value = /*textCenterX*/
      ctx2[3] - /*labelPx*/
      ctx2[1] / 2)) {
        attr_dev(rect, "x", rect_x_value);
      }
      if (dirty & /*textCenterY*/
      4 && rect_y_value !== (rect_y_value = /*textCenterY*/
      ctx2[2] - shiftRectY)) {
        attr_dev(rect, "y", rect_y_value);
      }
      if (dirty & /*labelPx*/
      2) {
        attr_dev(
          rect,
          "width",
          /*labelPx*/
          ctx2[1]
        );
      }
      if (dirty & /*label*/
      1)
        set_data_dev(
          t,
          /*label*/
          ctx2[0]
        );
      if (dirty & /*textCenterX*/
      8) {
        attr_dev(
          text_1,
          "x",
          /*textCenterX*/
          ctx2[3]
        );
      }
      if (dirty & /*textCenterY*/
      4) {
        attr_dev(
          text_1,
          "y",
          /*textCenterY*/
          ctx2[2]
        );
      }
      if (dirty & /*labelTextColor*/
      16 && text_1_fill_value !== (text_1_fill_value = /*labelTextColor*/
      ctx2[4] ? (
        /*labelTextColor*/
        ctx2[4]
      ) : "black")) {
        attr_dev(text_1, "fill", text_1_fill_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(25:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let t_value = null + "";
  let t;
  const block = {
    c: function create2() {
      t = text2(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(23:0) {#if typeof label === 'undefined' || !label}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (typeof /*label*/
    ctx2[0] === "undefined" || !/*label*/
    ctx2[0])
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create2() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var shiftRectY = 7;
function instance($$self2, $$props2, $$invalidate2) {
  let label;
  let labelBgColor;
  let labelTextColor;
  let centerX;
  let centerY;
  let pxRatio;
  let textCenterX;
  let textCenterY;
  let spaces;
  let newLength;
  let labelPx;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("EdgeText", slots2, []);
  let { edgeTextProps } = $$props2;
  $$self2.$$.on_mount.push(function() {
    if (edgeTextProps === void 0 && !("edgeTextProps" in $$props2 || $$self2.$$.bound[$$self2.$$.props["edgeTextProps"]])) {
      console.warn("<EdgeText> was created without expected prop 'edgeTextProps'");
    }
  });
  const writable_props2 = ["edgeTextProps"];
  Object.keys($$props2).forEach((key2) => {
    if (!~writable_props2.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<EdgeText> was created with unknown prop '${key2}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("edgeTextProps" in $$props3)
      $$invalidate2(6, edgeTextProps = $$props3.edgeTextProps);
  };
  $$self2.$capture_state = () => ({
    edgeTextProps,
    shiftRectY,
    pxRatio,
    newLength,
    labelPx,
    spaces,
    label,
    centerY,
    textCenterY,
    centerX,
    textCenterX,
    labelTextColor,
    labelBgColor
  });
  $$self2.$inject_state = ($$props3) => {
    if ("edgeTextProps" in $$props3)
      $$invalidate2(6, edgeTextProps = $$props3.edgeTextProps);
    if ("pxRatio" in $$props3)
      $$invalidate2(7, pxRatio = $$props3.pxRatio);
    if ("newLength" in $$props3)
      $$invalidate2(8, newLength = $$props3.newLength);
    if ("labelPx" in $$props3)
      $$invalidate2(1, labelPx = $$props3.labelPx);
    if ("spaces" in $$props3)
      $$invalidate2(9, spaces = $$props3.spaces);
    if ("label" in $$props3)
      $$invalidate2(0, label = $$props3.label);
    if ("centerY" in $$props3)
      $$invalidate2(10, centerY = $$props3.centerY);
    if ("textCenterY" in $$props3)
      $$invalidate2(2, textCenterY = $$props3.textCenterY);
    if ("centerX" in $$props3)
      $$invalidate2(11, centerX = $$props3.centerX);
    if ("textCenterX" in $$props3)
      $$invalidate2(3, textCenterX = $$props3.textCenterX);
    if ("labelTextColor" in $$props3)
      $$invalidate2(4, labelTextColor = $$props3.labelTextColor);
    if ("labelBgColor" in $$props3)
      $$invalidate2(5, labelBgColor = $$props3.labelBgColor);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*edgeTextProps*/
    64) {
      $:
        $$invalidate2(0, { label, labelBgColor, labelTextColor, centerX, centerY } = edgeTextProps, label, ($$invalidate2(5, labelBgColor), $$invalidate2(6, edgeTextProps)), ($$invalidate2(4, labelTextColor), $$invalidate2(6, edgeTextProps)), ($$invalidate2(11, centerX), $$invalidate2(6, edgeTextProps)), ($$invalidate2(10, centerY), $$invalidate2(6, edgeTextProps)));
    }
    if ($$self2.$$.dirty & /*label*/
    1) {
      $:
        $$invalidate2(7, pxRatio = label.length < 3 ? 9 : 7);
    }
    if ($$self2.$$.dirty & /*centerX*/
    2048) {
      $:
        $$invalidate2(3, textCenterX = centerX);
    }
    if ($$self2.$$.dirty & /*centerY*/
    1024) {
      $:
        $$invalidate2(2, textCenterY = centerY);
    }
    if ($$self2.$$.dirty & /*label*/
    1) {
      $:
        $$invalidate2(9, spaces = label.split(" ").length - 1);
    }
    if ($$self2.$$.dirty & /*label, spaces*/
    513) {
      $:
        $$invalidate2(8, newLength = label.length - spaces);
    }
    if ($$self2.$$.dirty & /*newLength, pxRatio*/
    384) {
      $:
        $$invalidate2(1, labelPx = newLength * pxRatio);
    }
  };
  return [
    label,
    labelPx,
    textCenterY,
    textCenterX,
    labelTextColor,
    labelBgColor,
    edgeTextProps,
    pxRatio,
    newLength,
    spaces,
    centerY,
    centerX
  ];
}
var EdgeText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { edgeTextProps: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EdgeText",
      options,
      id: create_fragment.name
    });
  }
  get edgeTextProps() {
    throw new Error("<EdgeText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set edgeTextProps(value2) {
    throw new Error("<EdgeText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EdgeText_default = EdgeText;

// node_modules/svelvet/Edges/BaseEdge.svelte
var file2 = "node_modules/svelvet/Edges/BaseEdge.svelte";
function add_css(target) {
  append_styles(target, "svelte-qtkn5z", ".animate.svelte-qtkn5z{stroke-dasharray:5;animation:svelte-qtkn5z-dash 50000s linear}@keyframes svelte-qtkn5z-dash{from{stroke-dashoffset:1000000}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFzZUVkZ2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXVERSxRQUFRLGNBQUMsQ0FBQSxBQUNQLGdCQUFnQixDQUFFLENBQUMsQ0FDbkIsU0FBUyxDQUFFLGtCQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQUFDL0IsQ0FBQSxBQUNBLFdBQVcsa0JBQUssQ0FBQSxBQUNkLElBQUksQUFBQyxDQUFBLEFBQ0gsaUJBQWlCLENBQUUsT0FBTyxBQUM1QixDQUFBLEFBQ0YsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJCYXNlRWRnZS5zdmVsdGUiXX0= */");
}
function create_else_block2(ctx) {
  let path_1;
  let path_1_class_value;
  let path_1_stroke_value;
  const block = {
    c: function create2() {
      path_1 = svg_element("path");
      attr_dev(path_1, "class", path_1_class_value = null_to_empty(
        /*animate*/
        ctx[3] ? "animate" : ""
      ) + " svelte-qtkn5z");
      attr_dev(
        path_1,
        "d",
        /*path*/
        ctx[4]
      );
      attr_dev(path_1, "fill", "transparent");
      attr_dev(path_1, "stroke", path_1_stroke_value = /*edgeColor*/
      ctx[1] ? (
        /*edgeColor*/
        ctx[1]
      ) : "gray");
      attr_dev(path_1, "aria-label", "svg-path");
      add_location(path_1, file2, 41, 2, 891);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path_1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*animate*/
      8 && path_1_class_value !== (path_1_class_value = null_to_empty(
        /*animate*/
        ctx2[3] ? "animate" : ""
      ) + " svelte-qtkn5z")) {
        attr_dev(path_1, "class", path_1_class_value);
      }
      if (dirty & /*path*/
      16) {
        attr_dev(
          path_1,
          "d",
          /*path*/
          ctx2[4]
        );
      }
      if (dirty & /*edgeColor*/
      2 && path_1_stroke_value !== (path_1_stroke_value = /*edgeColor*/
      ctx2[1] ? (
        /*edgeColor*/
        ctx2[1]
      ) : "gray")) {
        attr_dev(path_1, "stroke", path_1_stroke_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(41:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let path_1;
  let path_1_class_value;
  let path_1_stroke_value;
  const block = {
    c: function create2() {
      path_1 = svg_element("path");
      attr_dev(path_1, "class", path_1_class_value = null_to_empty(
        /*animate*/
        ctx[3] ? "animate" : ""
      ) + " svelte-qtkn5z");
      attr_dev(
        path_1,
        "d",
        /*path*/
        ctx[4]
      );
      attr_dev(path_1, "fill", "transparent");
      attr_dev(path_1, "stroke", path_1_stroke_value = /*edgeColor*/
      ctx[1] ? (
        /*edgeColor*/
        ctx[1]
      ) : "gray");
      attr_dev(path_1, "marker-end", "url(#arrow)");
      attr_dev(path_1, "aria-label", "svg-path");
      add_location(path_1, file2, 32, 2, 698);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path_1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*animate*/
      8 && path_1_class_value !== (path_1_class_value = null_to_empty(
        /*animate*/
        ctx2[3] ? "animate" : ""
      ) + " svelte-qtkn5z")) {
        attr_dev(path_1, "class", path_1_class_value);
      }
      if (dirty & /*path*/
      16) {
        attr_dev(
          path_1,
          "d",
          /*path*/
          ctx2[4]
        );
      }
      if (dirty & /*edgeColor*/
      2 && path_1_stroke_value !== (path_1_stroke_value = /*edgeColor*/
      ctx2[1] ? (
        /*edgeColor*/
        ctx2[1]
      ) : "gray")) {
        attr_dev(path_1, "stroke", path_1_stroke_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(32:0) {#if arrow}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let edgetext;
  let current;
  edgetext = new EdgeText_default({
    props: { edgeTextProps: (
      /*edgeTextProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(edgetext.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(edgetext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const edgetext_changes = {};
      if (dirty & /*edgeTextProps*/
      1)
        edgetext_changes.edgeTextProps = /*edgeTextProps*/
        ctx2[0];
      edgetext.$set(edgetext_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(edgetext.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(edgetext.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(edgetext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(51:0) {#if edgeTextProps.label}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let defs;
  let marker;
  let polygon;
  let t02;
  let t12;
  let if_block1_anchor;
  let current;
  function select_block_type(ctx2, dirty) {
    if (/*arrow*/
    ctx2[2])
      return create_if_block_1;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*edgeTextProps*/
    ctx[0].label && create_if_block2(ctx)
  );
  const block = {
    c: function create2() {
      defs = svg_element("defs");
      marker = svg_element("marker");
      polygon = svg_element("polygon");
      t02 = space();
      if_block0.c();
      t12 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr_dev(
        polygon,
        "points",
        /*defaultArrow*/
        ctx[5]
      );
      attr_dev(polygon, "fill", "gray");
      add_location(polygon, file2, 27, 4, 617);
      attr_dev(marker, "id", "arrow");
      attr_dev(marker, "markerWidth", "9");
      attr_dev(marker, "markerHeight", "9");
      attr_dev(marker, "refX", "8");
      attr_dev(marker, "refY", "4");
      attr_dev(marker, "orient", "auto");
      add_location(marker, file2, 26, 2, 528);
      add_location(defs, file2, 25, 0, 519);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, defs, anchor);
      append_dev(defs, marker);
      append_dev(marker, polygon);
      insert_dev(target, t02, anchor);
      if_block0.m(target, anchor);
      insert_dev(target, t12, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(t12.parentNode, t12);
        }
      }
      if (/*edgeTextProps*/
      ctx2[0].label) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*edgeTextProps*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(defs);
      if (detaching)
        detach_dev(t02);
      if_block0.d(detaching);
      if (detaching)
        detach_dev(t12);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self2, $$props2, $$invalidate2) {
  let path;
  let animate;
  let arrow;
  let label;
  let labelBgColor;
  let labelTextColor;
  let edgeColor;
  let centerX;
  let centerY;
  let edgeTextProps;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("BaseEdge", slots2, []);
  let { baseEdgeProps } = $$props2;
  const defaultArrow = `0 0, 9 4.5, 0 9`;
  $$self2.$$.on_mount.push(function() {
    if (baseEdgeProps === void 0 && !("baseEdgeProps" in $$props2 || $$self2.$$.bound[$$self2.$$.props["baseEdgeProps"]])) {
      console.warn("<BaseEdge> was created without expected prop 'baseEdgeProps'");
    }
  });
  const writable_props2 = ["baseEdgeProps"];
  Object.keys($$props2).forEach((key2) => {
    if (!~writable_props2.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<BaseEdge> was created with unknown prop '${key2}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("baseEdgeProps" in $$props3)
      $$invalidate2(6, baseEdgeProps = $$props3.baseEdgeProps);
  };
  $$self2.$capture_state = () => ({
    EdgeText: EdgeText_default,
    baseEdgeProps,
    defaultArrow,
    centerY,
    centerX,
    labelTextColor,
    labelBgColor,
    label,
    edgeTextProps,
    edgeColor,
    arrow,
    animate,
    path
  });
  $$self2.$inject_state = ($$props3) => {
    if ("baseEdgeProps" in $$props3)
      $$invalidate2(6, baseEdgeProps = $$props3.baseEdgeProps);
    if ("centerY" in $$props3)
      $$invalidate2(7, centerY = $$props3.centerY);
    if ("centerX" in $$props3)
      $$invalidate2(8, centerX = $$props3.centerX);
    if ("labelTextColor" in $$props3)
      $$invalidate2(9, labelTextColor = $$props3.labelTextColor);
    if ("labelBgColor" in $$props3)
      $$invalidate2(10, labelBgColor = $$props3.labelBgColor);
    if ("label" in $$props3)
      $$invalidate2(11, label = $$props3.label);
    if ("edgeTextProps" in $$props3)
      $$invalidate2(0, edgeTextProps = $$props3.edgeTextProps);
    if ("edgeColor" in $$props3)
      $$invalidate2(1, edgeColor = $$props3.edgeColor);
    if ("arrow" in $$props3)
      $$invalidate2(2, arrow = $$props3.arrow);
    if ("animate" in $$props3)
      $$invalidate2(3, animate = $$props3.animate);
    if ("path" in $$props3)
      $$invalidate2(4, path = $$props3.path);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*baseEdgeProps*/
    64) {
      $:
        $$invalidate2(4, { path, animate, arrow, label, labelBgColor, labelTextColor, edgeColor, centerX, centerY } = baseEdgeProps, path, ($$invalidate2(3, animate), $$invalidate2(6, baseEdgeProps)), ($$invalidate2(2, arrow), $$invalidate2(6, baseEdgeProps)), ($$invalidate2(11, label), $$invalidate2(6, baseEdgeProps)), ($$invalidate2(10, labelBgColor), $$invalidate2(6, baseEdgeProps)), ($$invalidate2(9, labelTextColor), $$invalidate2(6, baseEdgeProps)), ($$invalidate2(1, edgeColor), $$invalidate2(6, baseEdgeProps)), ($$invalidate2(8, centerX), $$invalidate2(6, baseEdgeProps)), ($$invalidate2(7, centerY), $$invalidate2(6, baseEdgeProps)));
    }
    if ($$self2.$$.dirty & /*label, labelBgColor, labelTextColor, centerX, centerY*/
    3968) {
      $:
        $$invalidate2(0, edgeTextProps = {
          label,
          labelBgColor,
          labelTextColor,
          centerX,
          centerY
        });
    }
  };
  return [
    edgeTextProps,
    edgeColor,
    arrow,
    animate,
    path,
    defaultArrow,
    baseEdgeProps,
    centerY,
    centerX,
    labelTextColor,
    labelBgColor,
    label
  ];
}
var BaseEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { baseEdgeProps: 6 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BaseEdge",
      options,
      id: create_fragment2.name
    });
  }
  get baseEdgeProps() {
    throw new Error("<BaseEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set baseEdgeProps(value2) {
    throw new Error("<BaseEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BaseEdge_default = BaseEdge;

// node_modules/svelvet/types/utils.js
var Position;
(function(Position2) {
  Position2["Left"] = "left";
  Position2["Right"] = "right";
  Position2["Top"] = "top";
  Position2["Bottom"] = "bottom";
})(Position || (Position = {}));

// node_modules/svelvet/Edges/SimpleBezierEdge.svelte
function create_fragment3(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: { baseEdgeProps: (
      /*baseEdgeProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*baseEdgeProps*/
      1)
        baseedge_changes.baseEdgeProps = /*baseEdgeProps*/
        ctx2[0];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function calculateControlOffset(distance, curvature) {
  if (distance >= 0) {
    return 0.5 * distance;
  } else {
    return curvature * 25 * Math.sqrt(-distance);
  }
}
function instance3($$self2, $$props2, $$invalidate2) {
  let params;
  let path;
  let centerX;
  let centerY;
  let baseEdgeProps;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("SimpleBezierEdge", slots2, []);
  function getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {
    let ctX, ctY;
    switch (pos) {
      case Position.Left:
        {
          ctX = x1 - calculateControlOffset(x1 - x2, c);
          ctY = y1;
        }
        break;
      case Position.Right:
        {
          ctX = x1 + calculateControlOffset(x2 - x1, c);
          ctY = y1;
        }
        break;
      case Position.Top:
        {
          ctX = x1;
          ctY = y1 - calculateControlOffset(y1 - y2, c);
        }
        break;
      case Position.Bottom:
        {
          ctX = x1;
          ctY = y1 + calculateControlOffset(y2 - y1, c);
        }
        break;
    }
    return [ctX, ctY];
  }
  function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {
    const [sourceControlX, sourceControlY] = getControlWithCurvature({
      pos: sourcePosition,
      x1: sourceX,
      y1: sourceY,
      x2: targetX,
      y2: targetY,
      c: curvature
    });
    const [targetControlX, targetControlY] = getControlWithCurvature({
      pos: targetPosition,
      x1: targetX,
      y1: targetY,
      x2: sourceX,
      y2: sourceY,
      c: curvature
    });
    return `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`;
  }
  function getSimpleBezierCenter({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {
    const [sourceControlX, sourceControlY] = getControlWithCurvature({
      pos: sourcePosition,
      x1: sourceX,
      y1: sourceY,
      x2: targetX,
      y2: targetY,
      c: curvature
    });
    const [targetControlX, targetControlY] = getControlWithCurvature({
      pos: targetPosition,
      x1: targetX,
      y1: targetY,
      x2: sourceX,
      y2: sourceY,
      c: curvature
    });
    const centerX2 = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;
    const centerY2 = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;
    const xOffset = Math.abs(centerX2 - sourceX);
    const yOffset = Math.abs(centerY2 - sourceY);
    return [centerX2, centerY2, xOffset, yOffset];
  }
  let { edge } = $$props2;
  $$self2.$$.on_mount.push(function() {
    if (edge === void 0 && !("edge" in $$props2 || $$self2.$$.bound[$$self2.$$.props["edge"]])) {
      console.warn("<SimpleBezierEdge> was created without expected prop 'edge'");
    }
  });
  const writable_props2 = ["edge"];
  Object.keys($$props2).forEach((key2) => {
    if (!~writable_props2.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<SimpleBezierEdge> was created with unknown prop '${key2}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("edge" in $$props3)
      $$invalidate2(1, edge = $$props3.edge);
  };
  $$self2.$capture_state = () => ({
    BaseEdge: BaseEdge_default,
    Position,
    calculateControlOffset,
    getControlWithCurvature,
    getSimpleBezierPath,
    getSimpleBezierCenter,
    edge,
    centerY,
    centerX,
    path,
    baseEdgeProps,
    params
  });
  $$self2.$inject_state = ($$props3) => {
    if ("edge" in $$props3)
      $$invalidate2(1, edge = $$props3.edge);
    if ("centerY" in $$props3)
      $$invalidate2(2, centerY = $$props3.centerY);
    if ("centerX" in $$props3)
      $$invalidate2(3, centerX = $$props3.centerX);
    if ("path" in $$props3)
      $$invalidate2(4, path = $$props3.path);
    if ("baseEdgeProps" in $$props3)
      $$invalidate2(0, baseEdgeProps = $$props3.baseEdgeProps);
    if ("params" in $$props3)
      $$invalidate2(5, params = $$props3.params);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*edge*/
    2) {
      $:
        $$invalidate2(5, params = {
          sourceX: edge.sourceX,
          sourceY: edge.sourceY,
          sourcePosition: edge.sourcePosition,
          targetX: edge.targetX,
          targetY: edge.targetY,
          targetPosition: edge.targetPosition,
          curvature: 0.25
        });
    }
    if ($$self2.$$.dirty & /*params*/
    32) {
      $:
        $$invalidate2(4, path = getSimpleBezierPath(params));
    }
    if ($$self2.$$.dirty & /*params*/
    32) {
      $:
        $$invalidate2(3, [centerX, centerY] = getSimpleBezierCenter(params), centerX, ($$invalidate2(2, centerY), $$invalidate2(5, params), $$invalidate2(1, edge)));
    }
    if ($$self2.$$.dirty & /*edge, path, centerX, centerY*/
    30) {
      $:
        $$invalidate2(0, baseEdgeProps = { ...edge, path, centerX, centerY });
    }
  };
  return [baseEdgeProps, edge, centerY, centerX, path, params];
}
var SimpleBezierEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { edge: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SimpleBezierEdge",
      options,
      id: create_fragment3.name
    });
  }
  get edge() {
    throw new Error("<SimpleBezierEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set edge(value2) {
    throw new Error("<SimpleBezierEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SimpleBezierEdge_default = SimpleBezierEdge;

// node_modules/svelvet/Edges/StraightEdge.svelte
function create_fragment4(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: { baseEdgeProps: (
      /*baseEdgeProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*baseEdgeProps*/
      1)
        baseedge_changes.baseEdgeProps = /*baseEdgeProps*/
        ctx2[0];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self2, $$props2, $$invalidate2) {
  let xOffset;
  let yOffset;
  let centerX;
  let centerY;
  let path;
  let baseEdgeProps;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("StraightEdge", slots2, []);
  let { edge } = $$props2;
  $$self2.$$.on_mount.push(function() {
    if (edge === void 0 && !("edge" in $$props2 || $$self2.$$.bound[$$self2.$$.props["edge"]])) {
      console.warn("<StraightEdge> was created without expected prop 'edge'");
    }
  });
  const writable_props2 = ["edge"];
  Object.keys($$props2).forEach((key2) => {
    if (!~writable_props2.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<StraightEdge> was created with unknown prop '${key2}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("edge" in $$props3)
      $$invalidate2(1, edge = $$props3.edge);
  };
  $$self2.$capture_state = () => ({
    BaseEdge: BaseEdge_default,
    edge,
    centerY,
    centerX,
    path,
    baseEdgeProps,
    yOffset,
    xOffset
  });
  $$self2.$inject_state = ($$props3) => {
    if ("edge" in $$props3)
      $$invalidate2(1, edge = $$props3.edge);
    if ("centerY" in $$props3)
      $$invalidate2(2, centerY = $$props3.centerY);
    if ("centerX" in $$props3)
      $$invalidate2(3, centerX = $$props3.centerX);
    if ("path" in $$props3)
      $$invalidate2(4, path = $$props3.path);
    if ("baseEdgeProps" in $$props3)
      $$invalidate2(0, baseEdgeProps = $$props3.baseEdgeProps);
    if ("yOffset" in $$props3)
      $$invalidate2(5, yOffset = $$props3.yOffset);
    if ("xOffset" in $$props3)
      $$invalidate2(6, xOffset = $$props3.xOffset);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*edge*/
    2) {
      $:
        $$invalidate2(6, xOffset = Math.abs(edge.targetX - edge.sourceX) / 2);
    }
    if ($$self2.$$.dirty & /*edge*/
    2) {
      $:
        $$invalidate2(5, yOffset = Math.abs(edge.targetY - edge.sourceY) / 2);
    }
    if ($$self2.$$.dirty & /*edge, xOffset*/
    66) {
      $:
        $$invalidate2(3, centerX = edge.targetX < edge.sourceX ? edge.targetX + xOffset : edge.targetX - xOffset);
    }
    if ($$self2.$$.dirty & /*edge, yOffset*/
    34) {
      $:
        $$invalidate2(2, centerY = edge.targetY < edge.sourceY ? edge.targetY + yOffset : edge.targetY - yOffset);
    }
    if ($$self2.$$.dirty & /*edge*/
    2) {
      $:
        $$invalidate2(4, path = `M ${edge.sourceX},${edge.sourceY}L ${edge.targetX},${edge.targetY}`);
    }
    if ($$self2.$$.dirty & /*edge, path, centerX, centerY*/
    30) {
      $:
        $$invalidate2(0, baseEdgeProps = { ...edge, path, centerX, centerY });
    }
  };
  return [baseEdgeProps, edge, centerY, centerX, path, yOffset, xOffset];
}
var StraightEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { edge: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StraightEdge",
      options,
      id: create_fragment4.name
    });
  }
  get edge() {
    throw new Error("<StraightEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set edge(value2) {
    throw new Error("<StraightEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StraightEdge_default = StraightEdge;

// node_modules/svelvet/Edges/utils.js
var LeftOrRight = [Position.Left, Position.Right];
var getCenter = ({ sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top }) => {
  const sourceIsLeftOrRight = LeftOrRight.includes(sourcePosition);
  const targetIsLeftOrRight = LeftOrRight.includes(targetPosition);
  const mixedEdge = sourceIsLeftOrRight && !targetIsLeftOrRight || targetIsLeftOrRight && !sourceIsLeftOrRight;
  if (mixedEdge) {
    const xOffset2 = sourceIsLeftOrRight ? Math.abs(targetX - sourceX) : 0;
    const centerX2 = sourceX > targetX ? sourceX - xOffset2 : sourceX + xOffset2;
    const yOffset2 = sourceIsLeftOrRight ? 0 : Math.abs(targetY - sourceY);
    const centerY2 = sourceY < targetY ? sourceY + yOffset2 : sourceY - yOffset2;
    return [centerX2, centerY2, xOffset2, yOffset2];
  }
  const xOffset = Math.abs(targetX - sourceX) / 2;
  const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
  const yOffset = Math.abs(targetY - sourceY) / 2;
  const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY, xOffset, yOffset];
};

// node_modules/svelvet/stores/store.js
var svelvetStores = {};
var coreSvelvetStore = {
  nodesStore: writable([]),
  edgesStore: writable([]),
  widthStore: writable(600),
  heightStore: writable(600),
  backgroundStore: writable(false),
  movementStore: writable(true),
  nodeSelected: writable(false),
  nodeIdSelected: writable(-1),
  d3Scale: writable(1),
  snapgrid: writable(false),
  snapResize: writable(30),
  backgroundColor: writable(),
  hoveredElement: writable(null),
  initZoom: writable(4),
  initLocation: writable({ x: 0, y: 0 }),
  isLocked: writable(false),
  boundary: writable(false),
  nodeLinkStore: writable(false),
  nodeCreateStore: writable(false),
  nodeEditStore: writable(false),
  shareable: writable(false),
  deleteNodes: writable(false)
};
function findOrCreateStore(key2) {
  const existing = svelvetStores[key2];
  if (existing) {
    return existing;
  }
  const onNodeMove = (e2, nodeID) => {
    const bound = get_store_value(coreSvelvetStore.boundary);
    if (bound) {
      coreSvelvetStore.nodesStore.update((n) => {
        const correctNode = n.find((node) => node.id === nodeID);
        const scale = get_store_value(coreSvelvetStore.d3Scale);
        if (correctNode.childNodes) {
          n.forEach((child) => {
            if (correctNode.childNodes.includes(child.id)) {
              child.position.x = Math.min(Math.max(child.position.x + e2.movementX / scale, 1), bound.x - 50);
              child.position.y = Math.min(Math.max(child.position.y + e2.movementY / scale, 1), bound.y - 50);
            }
          });
          correctNode.position.x = Math.min(Math.max(correctNode.position.x + e2.movementX / scale, 1), bound.x - 50);
          correctNode.position.y = Math.min(Math.max(correctNode.position.y + e2.movementY / scale, 1), bound.y - 50);
        } else {
          correctNode.position.x = Math.min(Math.max(correctNode.position.x + e2.movementX / scale, 1), bound.x - 50);
          correctNode.position.y = Math.min(Math.max(correctNode.position.y + e2.movementY / scale, 1), bound.y - 50);
        }
        return [...n];
      });
    } else {
      coreSvelvetStore.nodesStore.update((n) => {
        const correctNode = n.find((node) => node.id === nodeID);
        const scale = get_store_value(coreSvelvetStore.d3Scale);
        if (correctNode.childNodes) {
          n.forEach((child) => {
            if (correctNode.childNodes.includes(child.id)) {
              child.position.x += e2.movementX / scale;
              child.position.y += e2.movementY / scale;
            }
          });
          correctNode.position.x += e2.movementX / scale;
          correctNode.position.y += e2.movementY / scale;
        } else {
          correctNode.position.x += e2.movementX / scale;
          correctNode.position.y += e2.movementY / scale;
        }
        return [...n];
      });
    }
    ;
  };
  const onEdgeMove = (event, edgeID) => {
    coreSvelvetStore.edgesStore.update((e2) => {
      const correctEdge = e2.find((edge) => edge.id === edgeID);
      const scale = get_store_value(coreSvelvetStore.d3Scale);
      if (!correctEdge.target) {
        correctEdge.targetX += event.movementX / scale;
        correctEdge.targetY += event.movementY / scale;
      }
      if (!correctEdge.source) {
        correctEdge.sourceX += event.movementX / scale;
        correctEdge.sourceY += event.movementY / scale;
      }
      return [...e2];
    });
  };
  const onTouchMove = (e2, nodeID) => {
    coreSvelvetStore.nodesStore.update((n) => {
      n.forEach((node) => {
        if (node.id === nodeID) {
          const { x, y, width: width2, height: height2 } = e2.target.getBoundingClientRect();
          const offsetX = (e2.touches[0].clientX - x) / width2 * e2.target.offsetWidth;
          const offsetY = (e2.touches[0].clientY - y) / height2 * e2.target.offsetHeight;
          node.position.x += offsetX - node.width / 2;
          node.position.y += offsetY - node.height / 2;
        }
      });
      return [...n];
    });
  };
  const deleteNode = (e2, $nodeIdSelected) => {
    const answer = confirm("Are you sure you want to delete this node?");
    if (answer) {
      coreSvelvetStore.nodesStore.update((n) => {
        return n.filter((node) => node.id !== $nodeIdSelected);
      });
      coreSvelvetStore.edgesStore.update((e3) => {
        return e3.filter((edge) => edge.source !== $nodeIdSelected && edge.target !== $nodeIdSelected);
      });
    }
  };
  const renderEdge = (e2, node, role, position) => {
    e2.preventDefault();
    const uniq = (Math.random() + 1).toString(36).substring(7) + "-" + (Math.random() + 1).toString(36).substring(7);
    const [x, y] = setNewEdgeProps(role, position, node);
    const newEdge = role === "source" ? {
      id: uniq,
      // generate unique id
      source: node.id,
      // the source is the node that the anchor is on
      target: null,
      // until the mouse is released the target will be set to null
      targetX: x,
      targetY: y,
      animate: true
    } : {
      id: uniq,
      // generate unique id
      source: null,
      // until the mouse is released the source will be set to null
      target: node.id,
      // the target is the node that the anchor is on
      sourceX: x,
      sourceY: y,
      animate: true
    };
    coreSvelvetStore.edgesStore.set([...get_store_value(derivedEdges2), newEdge]);
    return newEdge;
  };
  const renderNewNode = (event, node, edge, role, position) => {
    const nodeIds = get_store_value(coreSvelvetStore.nodesStore).map((n) => n.id);
    const highestId = Math.max(...nodeIds);
    event.preventDefault();
    let pos = position === "bottom" ? { x: edge.targetX, y: edge.targetY } : { x: edge.sourceX, y: edge.sourceY };
    const newNode = {
      id: highestId + 1,
      // set the id to one higher than the highest in the current array
      position: pos,
      // the position (top left corner) is at the target coords of the edge for now
      data: node.data ? { ...node.data } : { label: "" },
      // need ways to change the rest of the properties
      width: node.width,
      height: node.height,
      className: node.className || "",
      bgColor: node.bgColor,
      // image: node.image,
      // src: node.src,
      textColor: node.textColor,
      borderRadius: node.borderRadius,
      borderColor: node.borderColor,
      delete: node.delete
    };
    if (position === "left") {
      if (role === "source") {
        newNode.sourcePosition = "left";
        newNode.targetPosition = "right";
        edge.target = newNode.id;
        newNode.position.x = edge.targetX - newNode.width / 2;
        newNode.position.y = edge.targetY;
      } else {
        newNode.sourcePosition = "right";
        newNode.targetPosition = "left";
        edge.source = newNode.id;
        newNode.position.x = edge.sourceX - newNode.width / 2;
        newNode.position.y = edge.sourceY - newNode.height;
      }
    } else if (position === "right") {
      if (role === "source") {
        newNode.sourcePosition = "right";
        newNode.targetPosition = "left";
        edge.target = newNode.id;
        newNode.position.x = edge.targetX - newNode.width / 2;
        newNode.position.y = edge.targetY;
      } else {
        newNode.sourcePosition = "left";
        newNode.targetPosition = "right";
        edge.source = newNode.id;
        newNode.position.x = edge.sourceX - newNode.width / 2;
        newNode.position.y = edge.sourceY - newNode.height;
      }
    } else {
      if (role === "source") {
        edge.target = newNode.id;
        newNode.position.x = edge.targetX - newNode.width / 2;
        newNode.position.y = edge.targetY;
      } else {
        edge.source = newNode.id;
        newNode.position.x = edge.sourceX - newNode.width / 2;
        newNode.position.y = edge.sourceY - newNode.height;
      }
    }
    coreSvelvetStore.nodesStore.set([...get_store_value(nodesStore2), newNode]);
  };
  const getStyles = (e2, node) => {
    let width2, height2, innerText;
    const styleRules = document.styleSheets[1].cssRules;
    Object.values(styleRules).forEach((rule) => {
      if (rule.selectorText === `.${node.className}`) {
        const initialText = rule.cssText;
        const i = initialText.indexOf("{");
        innerText = initialText.substring(i + 1, initialText.length - 1);
        const arr = innerText.split(" ");
        arr.forEach((str, i2) => {
          if (str === "width:") {
            width2 = str.concat(arr[i2 + 1]);
            const w = parseInt(arr[i2 + 1]);
            width2 = w;
          }
          if (str === "height:") {
            height2 = str.concat(arr[i2 + 1]);
            const h = parseInt(arr[i2 + 1]);
            height2 = h;
          }
        });
      }
    });
    const newStore2 = get_store_value(coreSvelvetStore.nodesStore).map((n) => {
      if (node.id === n.id) {
        n.width = width2 || node.width;
        n.height = height2 || node.height;
        return n;
      } else
        return n;
    });
    coreSvelvetStore.nodesStore.set(newStore2);
    return [width2, height2, innerText];
  };
  const nodeIdSelected = coreSvelvetStore.nodeIdSelected;
  const onNodeClick = (e2, nodeID) => {
    get_store_value(nodesStore2).forEach((node) => {
      var _a;
      if (node.id === get_store_value(nodeIdSelected)) {
        (_a = node.clickCallback) == null ? void 0 : _a.call(node, node);
      }
    });
  };
  const edgesStore = coreSvelvetStore.edgesStore;
  const nodesStore2 = coreSvelvetStore.nodesStore;
  const derivedEdges2 = derived([nodesStore2, edgesStore], ([$nodesStore2, $edgesStore]) => {
    $edgesStore.forEach((edge) => {
      let sourceNode = {
        id: 0,
        position: { x: 25, y: 475 },
        data: { label: "9" },
        width: 175,
        height: 40,
        targetPosition: "right",
        sourcePosition: "left"
      };
      let targetNode = {
        id: 10,
        position: { x: 750, y: 475 },
        data: { label: "10" },
        width: 175,
        height: 40,
        targetPosition: "right",
        sourcePosition: "left"
      };
      $nodesStore2.forEach((node) => {
        if (edge.source === node.id) {
          sourceNode = node;
        }
        if (edge.target === node.id) {
          targetNode = node;
        }
      });
      if (!$nodesStore2.some((node) => node.id === edge.target))
        targetNode = null;
      if (!$nodesStore2.some((node) => node.id === edge.source))
        sourceNode = null;
      if (sourceNode) {
        let left = sourceNode.position.x;
        let top = sourceNode.position.y;
        let middle = sourceNode.width / 2;
        if (sourceNode.sourcePosition === "bottom" || sourceNode.sourcePosition === void 0) {
          edge.sourceX = left + middle;
          edge.sourceY = top + sourceNode.height;
          edge.sourcePosition = "bottom";
        } else if (sourceNode.sourcePosition === "top") {
          edge.sourceX = left + middle;
          edge.sourceY = top;
          edge.sourcePosition = sourceNode.sourcePosition;
        } else if (sourceNode.sourcePosition === "left") {
          edge.sourceX = left;
          edge.sourceY = top + sourceNode.height / 2;
          edge.sourcePosition = sourceNode.sourcePosition;
        } else if (sourceNode.sourcePosition === "right") {
          edge.sourceX = left + sourceNode.width;
          edge.sourceY = top + sourceNode.height / 2;
          edge.sourcePosition = sourceNode.sourcePosition;
        }
      }
      if (targetNode) {
        let left = targetNode.position.x;
        let top = targetNode.position.y;
        let middle = targetNode.width / 2;
        if (targetNode.targetPosition === "top" || targetNode.targetPosition === void 0) {
          edge.targetX = left + middle;
          edge.targetY = top;
          edge.targetPosition = "top";
        } else if (targetNode.targetPosition === "bottom") {
          edge.targetX = left + middle;
          edge.targetY = top + targetNode.height;
          edge.targetPosition = targetNode.targetPosition;
        } else if (targetNode.targetPosition === "left") {
          edge.targetX = left;
          edge.targetY = top + targetNode.height / 2;
          edge.targetPosition = targetNode.targetPosition;
        } else if (targetNode.targetPosition === "right") {
          edge.targetX = left + targetNode.width;
          edge.targetY = top + targetNode.height / 2;
          edge.targetPosition = targetNode.targetPosition;
        }
      }
    });
    return [...$edgesStore];
  });
  const setAnchorPosition = (position, nodeWidth, nodeHeight, width2, height2) => {
    let top;
    let left;
    if (position === "top") {
      top = -height2 / 2;
      left = nodeWidth / 2 - width2 / 2;
    }
    if (position === "bottom") {
      top = nodeHeight - height2 / 2;
      left = nodeWidth / 2 - width2 / 2;
    }
    if (position === "left") {
      top = nodeHeight / 2 - height2 / 2;
      left = -width2 / 2;
    }
    if (position === "right") {
      top = nodeHeight / 2 - height2 / 2;
      left = nodeWidth - width2 / 2;
    }
    return [top, left];
  };
  const setNewEdgeProps = (role, position, node) => {
    let left = node.position.x;
    let top = node.position.y;
    let middle = node.width / 2;
    let x;
    let y;
    if (role === "source") {
      if (position === "top") {
        x = left + middle;
        y = top;
      } else if (position === "bottom") {
        x = left + middle;
        y = top + node.height;
      } else if (position === "left") {
        x = left;
        y = top + node.height / 2;
      } else if (position === "right") {
        x = left + node.width;
        y = top + node.height / 2;
      }
      return [x, y];
    } else {
      if (position === "top") {
        x = left + middle;
        y = top;
      } else if (position === "bottom") {
        x = left + middle;
        y = top + node.height;
      } else if (position === "left") {
        x = left;
        y = top + node.height / 2;
      } else if (position === "right") {
        x = left + node.width;
        y = top + node.height / 2;
      }
      return [x, y];
    }
  };
  const svelvetStore2 = {
    ...coreSvelvetStore,
    onTouchMove,
    onEdgeMove,
    onNodeMove,
    onNodeClick,
    setAnchorPosition,
    setNewEdgeProps,
    renderEdge,
    renderNewNode,
    getStyles,
    deleteNode,
    derivedEdges: derivedEdges2
  };
  svelvetStores[key2] = svelvetStore2;
  return svelvetStore2;
}

// node_modules/svelvet/Edges/EdgeAnchor.svelte
var file3 = "node_modules/svelvet/Edges/EdgeAnchor.svelte";
function add_css2(target) {
  append_styles(target, "svelte-q792jn", ".Anchor.svelte-q792jn,.Anchor-inert.svelte-q792jn{position:absolute;border-radius:50%;cursor:crosshair;background-color:rgb(105, 99, 99);transform:translateZ(-10px)}.Anchor.svelte-q792jn:hover{transform:scale(1.8) translateZ(-10px);background-color:#FF4742;box-shadow:1px 1px 3px 1px rgba(0, 0, 0, 0.2)}.Anchor-inert.svelte-q792jn{cursor:move}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWRnZUFuY2hvci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBbUlFLHFCQUFPLENBQUUsYUFBYSxjQUFDLENBQUEsQUFDckIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsTUFBTSxDQUFFLFNBQVMsQ0FDakIsZ0JBQWdCLENBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FDbEMsU0FBUyxDQUFFLFdBQVcsS0FBSyxDQUFDLEFBQzlCLENBQUEsQUFFQSxxQkFBTyxNQUFNLEFBQUMsQ0FBQSxBQUNaLFNBQVMsQ0FBRSxNQUFNLEdBQUcsQ0FBQyxDQUFDLFdBQVcsS0FBSyxDQUFDLENBQ3ZDLGdCQUFnQixDQUFFLE9BQU8sQ0FDekIsVUFBVSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxBQUNoRCxDQUFBLEFBRUEsYUFBYSxjQUFDLENBQUEsQUFDWixNQUFNLENBQUUsSUFBSSxBQUNkLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRWRnZUFuY2hvci5zdmVsdGUiXX0= */");
}
function create_else_block3(ctx) {
  let div;
  let div_style_value;
  const block = {
    c: function create2() {
      div = element("div");
      attr_dev(div, "class", "Anchor-inert svelte-q792jn");
      attr_dev(div, "style", div_style_value = `
    height:${/*anchorHeight*/
      ctx[16]}px;
    width:${/*anchorWidth*/
      ctx[15]}px;
    top: ${/*top*/
      ctx[5]}px;
    left:${/*left*/
      ctx[6]}px;
  `);
      add_location(div, file3, 117, 0, 3588);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*top, left*/
      96 && div_style_value !== (div_style_value = `
    height:${/*anchorHeight*/
      ctx2[16]}px;
    width:${/*anchorWidth*/
      ctx2[15]}px;
    top: ${/*top*/
      ctx2[5]}px;
    left:${/*left*/
      ctx2[6]}px;
  `)) {
        attr_dev(div, "style", div_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(117:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div;
  let div_style_value;
  let mounted;
  let dispose;
  const block = {
    c: function create2() {
      div = element("div");
      attr_dev(div, "class", "Anchor svelte-q792jn");
      attr_dev(div, "style", div_style_value = `
      height:${/*anchorHeight*/
      ctx[16]}px;
      width:${/*anchorWidth*/
      ctx[15]}px;
      top: ${/*top*/
      ctx[5]}px;
      left:${/*left*/
      ctx[6]}px;
    `);
      add_location(div, file3, 80, 2, 2543);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "mousedown",
            /*mousedown_handler*/
            ctx[29],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseup",
            /*mouseup_handler_1*/
            ctx[30],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[31],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[32],
            false,
            false,
            false
          ),
          listen_dev(div, "keydown", keydown_handler, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*top, left*/
      96 && div_style_value !== (div_style_value = `
      height:${/*anchorHeight*/
      ctx2[16]}px;
      width:${/*anchorWidth*/
      ctx2[15]}px;
      top: ${/*top*/
      ctx2[5]}px;
      left:${/*left*/
      ctx2[6]}px;
    `)) {
        attr_dev(div, "style", div_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(79:0) {#if $nodeLinkStore}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let if_block_anchor;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (/*$nodeLinkStore*/
    ctx2[14])
      return create_if_block3;
    return create_else_block3;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create2() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "mousemove",
            /*mousemove_handler*/
            ctx[27],
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "mouseup",
            /*mouseup_handler*/
            ctx[28],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var keydown_handler = () => {
  return;
};
function instance5($$self2, $$props2, $$invalidate2) {
  let store;
  let $hoveredElement;
  let $nodeCreateStore;
  let $derivedEdges2;
  let $nodeLinkStore;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("EdgeAnchor", slots2, []);
  let { key: key2 } = $$props2;
  let { node } = $$props2;
  let { position } = $$props2;
  let { role } = $$props2;
  let { width: width2 } = $$props2;
  let { height: height2 } = $$props2;
  let newEdge;
  let hovered = false;
  let anchorWidth = 13;
  let anchorHeight = 13;
  let top;
  let left;
  const { onEdgeMove, setAnchorPosition, renderEdge, renderNewNode, hoveredElement, derivedEdges: derivedEdges2, nodeLinkStore, nodeCreateStore } = findOrCreateStore(key2);
  validate_store(hoveredElement, "hoveredElement");
  component_subscribe($$self2, hoveredElement, (value2) => $$invalidate2(11, $hoveredElement = value2));
  validate_store(derivedEdges2, "derivedEdges");
  component_subscribe($$self2, derivedEdges2, (value2) => $$invalidate2(13, $derivedEdges2 = value2));
  validate_store(nodeLinkStore, "nodeLinkStore");
  component_subscribe($$self2, nodeLinkStore, (value2) => $$invalidate2(14, $nodeLinkStore = value2));
  validate_store(nodeCreateStore, "nodeCreateStore");
  component_subscribe($$self2, nodeCreateStore, (value2) => $$invalidate2(12, $nodeCreateStore = value2));
  let moving = false;
  let moved = false;
  let edgeShouldMove = false;
  beforeUpdate(() => {
    $$invalidate2(5, top = setAnchorPosition(position, width2, height2, anchorWidth, anchorHeight)[0]);
    $$invalidate2(6, left = setAnchorPosition(position, width2, height2, anchorWidth, anchorHeight)[1]);
  });
  $$self2.$$.on_mount.push(function() {
    if (key2 === void 0 && !("key" in $$props2 || $$self2.$$.bound[$$self2.$$.props["key"]])) {
      console.warn("<EdgeAnchor> was created without expected prop 'key'");
    }
    if (node === void 0 && !("node" in $$props2 || $$self2.$$.bound[$$self2.$$.props["node"]])) {
      console.warn("<EdgeAnchor> was created without expected prop 'node'");
    }
    if (position === void 0 && !("position" in $$props2 || $$self2.$$.bound[$$self2.$$.props["position"]])) {
      console.warn("<EdgeAnchor> was created without expected prop 'position'");
    }
    if (role === void 0 && !("role" in $$props2 || $$self2.$$.bound[$$self2.$$.props["role"]])) {
      console.warn("<EdgeAnchor> was created without expected prop 'role'");
    }
    if (width2 === void 0 && !("width" in $$props2 || $$self2.$$.bound[$$self2.$$.props["width"]])) {
      console.warn("<EdgeAnchor> was created without expected prop 'width'");
    }
    if (height2 === void 0 && !("height" in $$props2 || $$self2.$$.bound[$$self2.$$.props["height"]])) {
      console.warn("<EdgeAnchor> was created without expected prop 'height'");
    }
  });
  const writable_props2 = ["key", "node", "position", "role", "width", "height"];
  Object.keys($$props2).forEach((key3) => {
    if (!~writable_props2.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<EdgeAnchor> was created with unknown prop '${key3}'`);
  });
  const mousemove_handler = (e2) => {
    e2.preventDefault();
    if (newEdge && edgeShouldMove) {
      onEdgeMove(e2, newEdge.id);
      $$invalidate2(8, moved = true);
    }
  };
  const mouseup_handler = (e2) => {
    $$invalidate2(9, edgeShouldMove = false);
    if (newEdge && moved) {
      $$invalidate2(3, newEdge.animate = false, newEdge);
      if ($hoveredElement) {
        if (role === "target")
          $$invalidate2(3, newEdge.source = $hoveredElement.id, newEdge);
        else
          $$invalidate2(3, newEdge.target = $hoveredElement.id, newEdge);
        $$invalidate2(10, store), $$invalidate2(24, key2);
      } else if ($nodeCreateStore) {
        renderNewNode(e2, node, newEdge, role, position);
      } else {
        store.edgesStore.set($derivedEdges2.filter((e3) => e3.id !== newEdge.id));
      }
    }
    $$invalidate2(3, newEdge = null);
    $$invalidate2(8, moved = false);
    $$invalidate2(7, moving = false);
  };
  const mousedown_handler2 = (e2) => {
    e2.preventDefault();
    e2.stopPropagation();
    $$invalidate2(9, edgeShouldMove = true);
  };
  const mouseup_handler_1 = (e2) => {
    e2.preventDefault();
    $$invalidate2(9, edgeShouldMove = false);
    $$invalidate2(7, moving = false);
    $$invalidate2(8, moved = false);
  };
  const mouseenter_handler = (e2) => {
    $$invalidate2(4, hovered = true);
    store.hoveredElement.set(node);
  };
  const mouseleave_handler = (e2) => {
    if (edgeShouldMove)
      $$invalidate2(3, newEdge = renderEdge(e2, node, role, position));
    store.edgesStore.set($derivedEdges2);
    $$invalidate2(4, hovered = false);
    store.hoveredElement.set(null);
  };
  $$self2.$$set = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(24, key2 = $$props3.key);
    if ("node" in $$props3)
      $$invalidate2(0, node = $$props3.node);
    if ("position" in $$props3)
      $$invalidate2(1, position = $$props3.position);
    if ("role" in $$props3)
      $$invalidate2(2, role = $$props3.role);
    if ("width" in $$props3)
      $$invalidate2(25, width2 = $$props3.width);
    if ("height" in $$props3)
      $$invalidate2(26, height2 = $$props3.height);
  };
  $$self2.$capture_state = () => ({
    findOrCreateStore,
    beforeUpdate,
    afterUpdate,
    key: key2,
    node,
    position,
    role,
    width: width2,
    height: height2,
    newEdge,
    hovered,
    anchorWidth,
    anchorHeight,
    top,
    left,
    onEdgeMove,
    setAnchorPosition,
    renderEdge,
    renderNewNode,
    hoveredElement,
    derivedEdges: derivedEdges2,
    nodeLinkStore,
    nodeCreateStore,
    moving,
    moved,
    edgeShouldMove,
    store,
    $hoveredElement,
    $nodeCreateStore,
    $derivedEdges: $derivedEdges2,
    $nodeLinkStore
  });
  $$self2.$inject_state = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(24, key2 = $$props3.key);
    if ("node" in $$props3)
      $$invalidate2(0, node = $$props3.node);
    if ("position" in $$props3)
      $$invalidate2(1, position = $$props3.position);
    if ("role" in $$props3)
      $$invalidate2(2, role = $$props3.role);
    if ("width" in $$props3)
      $$invalidate2(25, width2 = $$props3.width);
    if ("height" in $$props3)
      $$invalidate2(26, height2 = $$props3.height);
    if ("newEdge" in $$props3)
      $$invalidate2(3, newEdge = $$props3.newEdge);
    if ("hovered" in $$props3)
      $$invalidate2(4, hovered = $$props3.hovered);
    if ("anchorWidth" in $$props3)
      $$invalidate2(15, anchorWidth = $$props3.anchorWidth);
    if ("anchorHeight" in $$props3)
      $$invalidate2(16, anchorHeight = $$props3.anchorHeight);
    if ("top" in $$props3)
      $$invalidate2(5, top = $$props3.top);
    if ("left" in $$props3)
      $$invalidate2(6, left = $$props3.left);
    if ("moving" in $$props3)
      $$invalidate2(7, moving = $$props3.moving);
    if ("moved" in $$props3)
      $$invalidate2(8, moved = $$props3.moved);
    if ("edgeShouldMove" in $$props3)
      $$invalidate2(9, edgeShouldMove = $$props3.edgeShouldMove);
    if ("store" in $$props3)
      $$invalidate2(10, store = $$props3.store);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty[0] & /*key*/
    16777216) {
      $:
        $$invalidate2(10, store = findOrCreateStore(key2));
    }
  };
  return [
    node,
    position,
    role,
    newEdge,
    hovered,
    top,
    left,
    moving,
    moved,
    edgeShouldMove,
    store,
    $hoveredElement,
    $nodeCreateStore,
    $derivedEdges2,
    $nodeLinkStore,
    anchorWidth,
    anchorHeight,
    onEdgeMove,
    renderEdge,
    renderNewNode,
    hoveredElement,
    derivedEdges2,
    nodeLinkStore,
    nodeCreateStore,
    key2,
    width2,
    height2,
    mousemove_handler,
    mouseup_handler,
    mousedown_handler2,
    mouseup_handler_1,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var EdgeAnchor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        key: 24,
        node: 0,
        position: 1,
        role: 2,
        width: 25,
        height: 26
      },
      add_css2,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EdgeAnchor",
      options,
      id: create_fragment5.name
    });
  }
  get key() {
    throw new Error("<EdgeAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value2) {
    throw new Error("<EdgeAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get node() {
    throw new Error("<EdgeAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value2) {
    throw new Error("<EdgeAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<EdgeAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value2) {
    throw new Error("<EdgeAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<EdgeAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value2) {
    throw new Error("<EdgeAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<EdgeAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value2) {
    throw new Error("<EdgeAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<EdgeAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value2) {
    throw new Error("<EdgeAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EdgeAnchor_default = EdgeAnchor;

// node_modules/svelvet/Edges/SmoothStepEdge.svelte
function create_fragment6(ctx) {
  let baseedge;
  let current;
  baseedge = new BaseEdge_default({
    props: { baseEdgeProps: (
      /*baseEdgeProps*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(baseedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(baseedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const baseedge_changes = {};
      if (dirty & /*baseEdgeProps*/
      1)
        baseedge_changes.baseEdgeProps = /*baseEdgeProps*/
        ctx2[0];
      baseedge.$set(baseedge_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(baseedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(baseedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(baseedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self2, $$props2, $$invalidate2) {
  let params;
  let centerX;
  let centerY;
  let path;
  let baseEdgeProps;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("SmoothStepEdge", slots2, []);
  const bottomLeftCorner = (x, y, size) => `L ${x},${y - size}Q ${x},${y} ${x + size},${y}`;
  const leftBottomCorner = (x, y, size) => `L ${x + size},${y}Q ${x},${y} ${x},${y - size}`;
  const bottomRightCorner = (x, y, size) => `L ${x},${y - size}Q ${x},${y} ${x - size},${y}`;
  const rightBottomCorner = (x, y, size) => `L ${x - size},${y}Q ${x},${y} ${x},${y - size}`;
  const leftTopCorner = (x, y, size) => `L ${x + size},${y}Q ${x},${y} ${x},${y + size}`;
  const topLeftCorner = (x, y, size) => `L ${x},${y + size}Q ${x},${y} ${x + size},${y}`;
  const topRightCorner = (x, y, size) => `L ${x},${y + size}Q ${x},${y} ${x - size},${y}`;
  const rightTopCorner = (x, y, size) => `L ${x - size},${y}Q ${x},${y} ${x},${y + size}`;
  function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius: borderRadius2 = 5, centerX: centerX2, centerY: centerY2 }) {
    const [_centerX, _centerY, offsetX, offsetY] = getCenter({ sourceX, sourceY, targetX, targetY });
    const cornerWidth = Math.min(borderRadius2, Math.abs(targetX - sourceX));
    const cornerHeight = Math.min(borderRadius2, Math.abs(targetY - sourceY));
    const cornerSize = Math.min(cornerWidth, cornerHeight, offsetX, offsetY);
    const leftAndRight = [Position.Left, Position.Right];
    const cX = typeof centerX2 !== "undefined" ? centerX2 : _centerX;
    const cY = typeof centerY2 !== "undefined" ? centerY2 : _centerY;
    let firstCornerPath = null;
    let secondCornerPath = null;
    if (sourceX <= targetX) {
      firstCornerPath = sourceY <= targetY ? bottomLeftCorner(sourceX, cY, cornerSize) : topLeftCorner(sourceX, cY, cornerSize);
      secondCornerPath = sourceY <= targetY ? rightTopCorner(targetX, cY, cornerSize) : rightBottomCorner(targetX, cY, cornerSize);
    } else {
      firstCornerPath = sourceY < targetY ? bottomRightCorner(sourceX, cY, cornerSize) : topRightCorner(sourceX, cY, cornerSize);
      secondCornerPath = sourceY < targetY ? leftTopCorner(targetX, cY, cornerSize) : leftBottomCorner(targetX, cY, cornerSize);
    }
    if (leftAndRight.includes(sourcePosition) && leftAndRight.includes(targetPosition)) {
      if (sourceX <= targetX) {
        firstCornerPath = sourceY <= targetY ? rightTopCorner(cX, sourceY, cornerSize) : rightBottomCorner(cX, sourceY, cornerSize);
        secondCornerPath = sourceY <= targetY ? bottomLeftCorner(cX, targetY, cornerSize) : topLeftCorner(cX, targetY, cornerSize);
      } else if (sourcePosition === Position.Right && targetPosition === Position.Left || sourcePosition === Position.Left && targetPosition === Position.Right || sourcePosition === Position.Left && targetPosition === Position.Left) {
        firstCornerPath = sourceY <= targetY ? leftTopCorner(cX, sourceY, cornerSize) : leftBottomCorner(cX, sourceY, cornerSize);
        secondCornerPath = sourceY <= targetY ? bottomRightCorner(cX, targetY, cornerSize) : topRightCorner(cX, targetY, cornerSize);
      }
    } else if (leftAndRight.includes(sourcePosition) && !leftAndRight.includes(targetPosition)) {
      if (sourceX <= targetX) {
        firstCornerPath = sourceY <= targetY ? rightTopCorner(targetX, sourceY, cornerSize) : rightBottomCorner(targetX, sourceY, cornerSize);
      } else {
        firstCornerPath = sourceY <= targetY ? leftTopCorner(targetX, sourceY, cornerSize) : leftBottomCorner(targetX, sourceY, cornerSize);
      }
      secondCornerPath = "";
    } else if (!leftAndRight.includes(sourcePosition) && leftAndRight.includes(targetPosition)) {
      if (sourceX <= targetX) {
        firstCornerPath = sourceY <= targetY ? bottomLeftCorner(sourceX, targetY, cornerSize) : topLeftCorner(sourceX, targetY, cornerSize);
      } else {
        firstCornerPath = sourceY <= targetY ? bottomRightCorner(sourceX, targetY, cornerSize) : topRightCorner(sourceX, targetY, cornerSize);
      }
      secondCornerPath = "";
    }
    return `M ${sourceX},${sourceY}${firstCornerPath}${secondCornerPath}L ${targetX},${targetY}`;
  }
  let { edge } = $$props2;
  let { borderRadius = 5 } = $$props2;
  $$self2.$$.on_mount.push(function() {
    if (edge === void 0 && !("edge" in $$props2 || $$self2.$$.bound[$$self2.$$.props["edge"]])) {
      console.warn("<SmoothStepEdge> was created without expected prop 'edge'");
    }
  });
  const writable_props2 = ["edge", "borderRadius"];
  Object.keys($$props2).forEach((key2) => {
    if (!~writable_props2.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<SmoothStepEdge> was created with unknown prop '${key2}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("edge" in $$props3)
      $$invalidate2(2, edge = $$props3.edge);
    if ("borderRadius" in $$props3)
      $$invalidate2(3, borderRadius = $$props3.borderRadius);
  };
  $$self2.$capture_state = () => ({
    BaseEdge: BaseEdge_default,
    getCenter,
    Position,
    EdgeAnchor: EdgeAnchor_default,
    bottomLeftCorner,
    leftBottomCorner,
    bottomRightCorner,
    rightBottomCorner,
    leftTopCorner,
    topLeftCorner,
    topRightCorner,
    rightTopCorner,
    getSmoothStepPath,
    edge,
    borderRadius,
    centerY,
    centerX,
    path,
    baseEdgeProps,
    params
  });
  $$self2.$inject_state = ($$props3) => {
    if ("edge" in $$props3)
      $$invalidate2(2, edge = $$props3.edge);
    if ("borderRadius" in $$props3)
      $$invalidate2(3, borderRadius = $$props3.borderRadius);
    if ("centerY" in $$props3)
      $$invalidate2(4, centerY = $$props3.centerY);
    if ("centerX" in $$props3)
      $$invalidate2(5, centerX = $$props3.centerX);
    if ("path" in $$props3)
      $$invalidate2(6, path = $$props3.path);
    if ("baseEdgeProps" in $$props3)
      $$invalidate2(0, baseEdgeProps = $$props3.baseEdgeProps);
    if ("params" in $$props3)
      $$invalidate2(7, params = $$props3.params);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*edge, borderRadius*/
    12) {
      $:
        $$invalidate2(7, params = {
          sourceX: edge.sourceX,
          sourceY: edge.sourceY,
          targetX: edge.targetX,
          targetY: edge.targetY,
          sourcePosition: edge.sourcePosition,
          targetPosition: edge.targetPosition,
          borderRadius
        });
    }
    if ($$self2.$$.dirty & /*params*/
    128) {
      $:
        $$invalidate2(5, [centerX, centerY] = getCenter(params), centerX, ($$invalidate2(4, centerY), $$invalidate2(7, params), $$invalidate2(2, edge), $$invalidate2(3, borderRadius)));
    }
    if ($$self2.$$.dirty & /*params*/
    128) {
      $:
        $$invalidate2(6, path = getSmoothStepPath(params));
    }
    if ($$self2.$$.dirty & /*edge, path, centerX, centerY*/
    116) {
      $:
        $$invalidate2(0, baseEdgeProps = { ...edge, path, centerX, centerY });
    }
  };
  return [
    baseEdgeProps,
    getSmoothStepPath,
    edge,
    borderRadius,
    centerY,
    centerX,
    path,
    params
  ];
}
var SmoothStepEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      getSmoothStepPath: 1,
      edge: 2,
      borderRadius: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SmoothStepEdge",
      options,
      id: create_fragment6.name
    });
  }
  get getSmoothStepPath() {
    return this.$$.ctx[1];
  }
  set getSmoothStepPath(value2) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get edge() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set edge(value2) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderRadius() {
    throw new Error("<SmoothStepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderRadius(value2) {
    throw new Error("<SmoothStepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SmoothStepEdge_default = SmoothStepEdge;

// node_modules/svelvet/Edges/StepEdge.svelte
function create_fragment7(ctx) {
  let smoothstepedge;
  let current;
  smoothstepedge = new SmoothStepEdge_default({
    props: { edge: (
      /*edge*/
      ctx[0]
    ), borderRadius: 0 },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(smoothstepedge.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(smoothstepedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const smoothstepedge_changes = {};
      if (dirty & /*edge*/
      1)
        smoothstepedge_changes.edge = /*edge*/
        ctx2[0];
      smoothstepedge.$set(smoothstepedge_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(smoothstepedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(smoothstepedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(smoothstepedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("StepEdge", slots2, []);
  let { edge } = $$props2;
  $$self2.$$.on_mount.push(function() {
    if (edge === void 0 && !("edge" in $$props2 || $$self2.$$.bound[$$self2.$$.props["edge"]])) {
      console.warn("<StepEdge> was created without expected prop 'edge'");
    }
  });
  const writable_props2 = ["edge"];
  Object.keys($$props2).forEach((key2) => {
    if (!~writable_props2.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<StepEdge> was created with unknown prop '${key2}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("edge" in $$props3)
      $$invalidate2(0, edge = $$props3.edge);
  };
  $$self2.$capture_state = () => ({ SmoothStepEdge: SmoothStepEdge_default, edge });
  $$self2.$inject_state = ($$props3) => {
    if ("edge" in $$props3)
      $$invalidate2(0, edge = $$props3.edge);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [edge];
}
var StepEdge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { edge: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StepEdge",
      options,
      id: create_fragment7.name
    });
  }
  get edge() {
    throw new Error("<StepEdge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set edge(value2) {
    throw new Error("<StepEdge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StepEdge_default = StepEdge;

// node_modules/svelvet/Nodes/EditModal.svelte
var file4 = "node_modules/svelvet/Nodes/EditModal.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1fc5nq", ".btn-container.svelte-1fc5nq{display:flex;justify-content:space-between;margin-top:.5rem}label.svelte-1fc5nq{font-size:.8rem;font-weight:bold;margin-bottom:.15rem}button.svelte-1fc5nq{border-radius:.5rem;background-color:white;box-shadow:1px 1px 3px 1px rgba(0, 0, 0, 0.4);margin:.2rem}input.svelte-1fc5nq{height:1.6rem;border-color:#e45b56}.bgci.svelte-1fc5nq{height:2rem;width:5rem;padding:0;border:none;background-color:none}button.svelte-1fc5nq:hover{cursor:pointer;background-color:#e45b56;color:white}form.svelte-1fc5nq{display:flex;flex-direction:column;align-items:center;justify-content:center}.edit-modal.svelte-1fc5nq{position:absolute;padding:0 1rem 1rem 1rem;display:none;flex-direction:column;align-items:center;border:1px solid #333333;border-radius:2rem;background-color:#FFFFFF;z-index:10;user-select:text;box-shadow:1px 1px 3px 1px rgba(0, 0, 0, 0.4);color:#333333}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWRpdE1vZGFsLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFnRkUsY0FBYyxjQUFDLENBQUEsQUFDYixPQUFPLENBQUUsSUFBSSxDQUNiLGVBQWUsQ0FBRSxhQUFhLENBQzlCLFVBQVUsQ0FBRSxLQUFLLEFBQ25CLENBQUEsQUFDQSxLQUFLLGNBQUMsQ0FBQSxBQUNKLFNBQVMsQ0FBRSxLQUFLLENBQ2hCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLGFBQWEsQ0FBRSxNQUFNLEFBQ3ZCLENBQUEsQUFFQSxNQUFNLGNBQUMsQ0FBQSxBQUNMLGFBQWEsQ0FBRSxLQUFLLENBQ3BCLGdCQUFnQixDQUFFLEtBQUssQ0FDdkIsVUFBVSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUM5QyxNQUFNLENBQUUsS0FBSyxBQUNmLENBQUEsQUFFQSxLQUFLLGNBQUMsQ0FBQSxBQUNKLE1BQU0sQ0FBRSxNQUFNLENBQ2QsWUFBWSxDQUFFLE9BQU8sQUFDdkIsQ0FBQSxBQUVBLEtBQUssY0FBQyxDQUFBLEFBQ0osTUFBTSxDQUFFLElBQUksQ0FDWixLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxDQUFDLENBQ1YsTUFBTSxDQUFFLElBQUksQ0FDWixnQkFBZ0IsQ0FBRSxJQUFJLEFBQ3hCLENBQUEsQUFFQSxvQkFBTSxNQUFNLEFBQUMsQ0FBQSxBQUNYLE1BQU0sQ0FBRSxPQUFPLENBQ2YsZ0JBQWdCLENBQUUsT0FBTyxDQUN6QixLQUFLLENBQUUsS0FBSyxBQUNkLENBQUEsQUFFQSxJQUFJLGNBQUMsQ0FBQSxBQUNILE9BQU8sQ0FBRSxJQUFJLENBQ2IsY0FBYyxDQUFFLE1BQU0sQ0FDdEIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsZUFBZSxDQUFFLE1BQU0sQUFDekIsQ0FBQSxBQUNBLFdBQVcsY0FBQyxDQUFBLEFBQ1YsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsT0FBTyxDQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FDekIsT0FBTyxDQUFFLElBQUksQ0FDYixjQUFjLENBQUUsTUFBTSxDQUN0QixXQUFXLENBQUUsTUFBTSxDQUNuQixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQ3pCLGFBQWEsQ0FBRSxJQUFJLENBQ25CLGdCQUFnQixDQUFFLE9BQU8sQ0FDekIsT0FBTyxDQUFFLEVBQUUsQ0FDWCxXQUFXLENBQUUsSUFBSSxDQUNqQixVQUFVLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQzlDLEtBQUssQ0FBRSxPQUFPLEFBQ2hCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRWRpdE1vZGFsLnN2ZWx0ZSJdfQ== */");
}
function create_if_block4(ctx) {
  let form;
  let label0;
  let t12;
  let input0;
  let input0_id_value;
  let input0_placeholder_value;
  let t22;
  let label1;
  let t4;
  let input1;
  let input1_id_value;
  let input1_placeholder_value;
  let t5;
  let label2;
  let t7;
  let input2;
  let input2_id_value;
  let input2_placeholder_value;
  let t8;
  let label3;
  let t10;
  let input3;
  let input3_id_value;
  let t11;
  let input4;
  let input4_placeholder_value;
  let t122;
  let label4;
  let t14;
  let input5;
  let input5_id_value;
  let input5_placeholder_value;
  let mounted;
  let dispose;
  const block = {
    c: function create2() {
      form = element("form");
      label0 = element("label");
      label0.textContent = "Label";
      t12 = space();
      input0 = element("input");
      t22 = space();
      label1 = element("label");
      label1.textContent = "Width";
      t4 = space();
      input1 = element("input");
      t5 = space();
      label2 = element("label");
      label2.textContent = "Height";
      t7 = space();
      input2 = element("input");
      t8 = space();
      label3 = element("label");
      label3.textContent = "Background Color";
      t10 = space();
      input3 = element("input");
      t11 = space();
      input4 = element("input");
      t122 = space();
      label4 = element("label");
      label4.textContent = "Custom Class";
      t14 = space();
      input5 = element("input");
      attr_dev(label0, "for", "label-input");
      attr_dev(label0, "class", "svelte-1fc5nq");
      add_location(label0, file4, 53, 4, 1456);
      attr_dev(input0, "type", "text");
      attr_dev(input0, "id", input0_id_value = "label-input-" + /*key*/
      ctx[0]);
      attr_dev(input0, "placeholder", input0_placeholder_value = /*currentNode*/
      ctx[7].data.label ? (
        /*currentNode*/
        ctx[7].data.label
      ) : "None");
      attr_dev(input0, "class", "svelte-1fc5nq");
      add_location(input0, file4, 54, 4, 1499);
      attr_dev(label1, "for", "width-input");
      attr_dev(label1, "class", "svelte-1fc5nq");
      add_location(label1, file4, 55, 4, 1661);
      attr_dev(input1, "type", "number");
      attr_dev(input1, "id", input1_id_value = "width-input-" + /*key*/
      ctx[0]);
      attr_dev(input1, "placeholder", input1_placeholder_value = /*currentNode*/
      ctx[7].width);
      attr_dev(input1, "class", "svelte-1fc5nq");
      add_location(input1, file4, 56, 4, 1704);
      attr_dev(label2, "for", "height-input");
      attr_dev(label2, "class", "svelte-1fc5nq");
      add_location(label2, file4, 57, 4, 1806);
      attr_dev(input2, "type", "number");
      attr_dev(input2, "id", input2_id_value = "height-input-" + /*key*/
      ctx[0]);
      attr_dev(input2, "placeholder", input2_placeholder_value = /*currentNode*/
      ctx[7].height);
      attr_dev(input2, "class", "svelte-1fc5nq");
      add_location(input2, file4, 58, 4, 1851);
      attr_dev(label3, "for", "bg-color-input");
      attr_dev(label3, "class", "svelte-1fc5nq");
      add_location(label3, file4, 59, 4, 1956);
      attr_dev(input3, "type", "color");
      attr_dev(input3, "id", input3_id_value = "bg-color-input-" + /*key*/
      ctx[0]);
      attr_dev(input3, "class", "bgci svelte-1fc5nq");
      add_location(input3, file4, 60, 4, 2013);
      attr_dev(input4, "type", "text");
      attr_dev(input4, "placeholder", input4_placeholder_value = /*currentNode*/
      ctx[7].bgColor);
      attr_dev(input4, "class", "svelte-1fc5nq");
      add_location(input4, file4, 61, 4, 2107);
      attr_dev(label4, "for", "custom-class-input");
      attr_dev(label4, "class", "svelte-1fc5nq");
      add_location(label4, file4, 62, 4, 2196);
      attr_dev(input5, "type", "text");
      attr_dev(input5, "id", input5_id_value = "custom-class-input-" + /*key*/
      ctx[0]);
      attr_dev(input5, "placeholder", input5_placeholder_value = /*currentNode*/
      ctx[7].className ? (
        /*currentNode*/
        ctx[7].className
      ) : "None");
      attr_dev(input5, "class", "svelte-1fc5nq");
      add_location(input5, file4, 63, 4, 2253);
      attr_dev(form, "class", "svelte-1fc5nq");
      add_location(form, file4, 52, 2, 1424);
    },
    m: function mount(target, anchor) {
      insert_dev(target, form, anchor);
      append_dev(form, label0);
      append_dev(form, t12);
      append_dev(form, input0);
      set_input_value(
        input0,
        /*label*/
        ctx[2]
      );
      append_dev(form, t22);
      append_dev(form, label1);
      append_dev(form, t4);
      append_dev(form, input1);
      set_input_value(
        input1,
        /*width*/
        ctx[3]
      );
      append_dev(form, t5);
      append_dev(form, label2);
      append_dev(form, t7);
      append_dev(form, input2);
      set_input_value(
        input2,
        /*height*/
        ctx[4]
      );
      append_dev(form, t8);
      append_dev(form, label3);
      append_dev(form, t10);
      append_dev(form, input3);
      set_input_value(
        input3,
        /*backgroundColor*/
        ctx[6]
      );
      append_dev(form, t11);
      append_dev(form, input4);
      set_input_value(
        input4,
        /*backgroundColor*/
        ctx[6]
      );
      append_dev(form, t122);
      append_dev(form, label4);
      append_dev(form, t14);
      append_dev(form, input5);
      set_input_value(
        input5,
        /*customClass*/
        ctx[5]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[14]
          ),
          listen_dev(
            input0,
            "input",
            /*changeLabel*/
            ctx[12],
            false,
            false,
            false
          ),
          listen_dev(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[15]
          ),
          listen_dev(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[16]
          ),
          listen_dev(
            input3,
            "input",
            /*input3_input_handler*/
            ctx[17]
          ),
          listen_dev(
            input4,
            "input",
            /*input4_input_handler*/
            ctx[18]
          ),
          listen_dev(
            input5,
            "input",
            /*input5_input_handler*/
            ctx[19]
          ),
          listen_dev(
            form,
            "submit",
            /*editNode*/
            ctx[11],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*key*/
      1 && input0_id_value !== (input0_id_value = "label-input-" + /*key*/
      ctx2[0])) {
        attr_dev(input0, "id", input0_id_value);
      }
      if (dirty & /*currentNode*/
      128 && input0_placeholder_value !== (input0_placeholder_value = /*currentNode*/
      ctx2[7].data.label ? (
        /*currentNode*/
        ctx2[7].data.label
      ) : "None")) {
        attr_dev(input0, "placeholder", input0_placeholder_value);
      }
      if (dirty & /*label*/
      4 && input0.value !== /*label*/
      ctx2[2]) {
        set_input_value(
          input0,
          /*label*/
          ctx2[2]
        );
      }
      if (dirty & /*key*/
      1 && input1_id_value !== (input1_id_value = "width-input-" + /*key*/
      ctx2[0])) {
        attr_dev(input1, "id", input1_id_value);
      }
      if (dirty & /*currentNode*/
      128 && input1_placeholder_value !== (input1_placeholder_value = /*currentNode*/
      ctx2[7].width)) {
        attr_dev(input1, "placeholder", input1_placeholder_value);
      }
      if (dirty & /*width*/
      8 && to_number(input1.value) !== /*width*/
      ctx2[3]) {
        set_input_value(
          input1,
          /*width*/
          ctx2[3]
        );
      }
      if (dirty & /*key*/
      1 && input2_id_value !== (input2_id_value = "height-input-" + /*key*/
      ctx2[0])) {
        attr_dev(input2, "id", input2_id_value);
      }
      if (dirty & /*currentNode*/
      128 && input2_placeholder_value !== (input2_placeholder_value = /*currentNode*/
      ctx2[7].height)) {
        attr_dev(input2, "placeholder", input2_placeholder_value);
      }
      if (dirty & /*height*/
      16 && to_number(input2.value) !== /*height*/
      ctx2[4]) {
        set_input_value(
          input2,
          /*height*/
          ctx2[4]
        );
      }
      if (dirty & /*key*/
      1 && input3_id_value !== (input3_id_value = "bg-color-input-" + /*key*/
      ctx2[0])) {
        attr_dev(input3, "id", input3_id_value);
      }
      if (dirty & /*backgroundColor*/
      64) {
        set_input_value(
          input3,
          /*backgroundColor*/
          ctx2[6]
        );
      }
      if (dirty & /*currentNode*/
      128 && input4_placeholder_value !== (input4_placeholder_value = /*currentNode*/
      ctx2[7].bgColor)) {
        attr_dev(input4, "placeholder", input4_placeholder_value);
      }
      if (dirty & /*backgroundColor*/
      64 && input4.value !== /*backgroundColor*/
      ctx2[6]) {
        set_input_value(
          input4,
          /*backgroundColor*/
          ctx2[6]
        );
      }
      if (dirty & /*key*/
      1 && input5_id_value !== (input5_id_value = "custom-class-input-" + /*key*/
      ctx2[0])) {
        attr_dev(input5, "id", input5_id_value);
      }
      if (dirty & /*currentNode*/
      128 && input5_placeholder_value !== (input5_placeholder_value = /*currentNode*/
      ctx2[7].className ? (
        /*currentNode*/
        ctx2[7].className
      ) : "None")) {
        attr_dev(input5, "placeholder", input5_placeholder_value);
      }
      if (dirty & /*customClass*/
      32 && input5.value !== /*customClass*/
      ctx2[5]) {
        set_input_value(
          input5,
          /*customClass*/
          ctx2[5]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(52:2) {#if currentNode}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let div1;
  let h4;
  let t12;
  let t22;
  let div0;
  let button0;
  let t4;
  let button1;
  let div0_class_value;
  let div1_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*currentNode*/
    ctx[7] && create_if_block4(ctx)
  );
  const block = {
    c: function create2() {
      div1 = element("div");
      h4 = element("h4");
      h4.textContent = "Edit Attributes";
      t12 = space();
      if (if_block)
        if_block.c();
      t22 = space();
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "Delete Node";
      t4 = space();
      button1 = element("button");
      button1.textContent = "Submit";
      add_location(h4, file4, 50, 2, 1377);
      attr_dev(button0, "class", "svelte-1fc5nq");
      add_location(button0, file4, 67, 4, 2471);
      attr_dev(button1, "class", "svelte-1fc5nq");
      add_location(button1, file4, 72, 4, 2650);
      attr_dev(div0, "class", div0_class_value = "btn-container-" + /*key*/
      ctx[0] + " btn-container svelte-1fc5nq");
      add_location(div0, file4, 66, 2, 2419);
      attr_dev(div1, "class", div1_class_value = "edit-modal edit-modal-" + /*key*/
      ctx[0] + " svelte-1fc5nq");
      add_location(div1, file4, 49, 0, 1333);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, h4);
      append_dev(div1, t12);
      if (if_block)
        if_block.m(div1, null);
      append_dev(div1, t22);
      append_dev(div1, div0);
      append_dev(div0, button0);
      append_dev(div0, t4);
      append_dev(div0, button1);
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler*/
            ctx[20],
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*editNode*/
            ctx[11],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (/*currentNode*/
      ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(div1, t22);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*key*/
      1 && div0_class_value !== (div0_class_value = "btn-container-" + /*key*/
      ctx2[0] + " btn-container svelte-1fc5nq")) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty & /*key*/
      1 && div1_class_value !== (div1_class_value = "edit-modal edit-modal-" + /*key*/
      ctx2[0] + " svelte-1fc5nq")) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self2, $$props2, $$invalidate2) {
  let store;
  let $nodesStore2;
  let $nodeIdSelected;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("EditModal", slots2, []);
  let { key: key2 } = $$props2;
  let label;
  let width2;
  let height2;
  let customClass;
  let backgroundColor;
  let currentNode;
  const { nodesStore: nodesStore2, nodeIdSelected, deleteNode } = findOrCreateStore(key2);
  validate_store(nodesStore2, "nodesStore");
  component_subscribe($$self2, nodesStore2, (value2) => $$invalidate2(13, $nodesStore2 = value2));
  validate_store(nodeIdSelected, "nodeIdSelected");
  component_subscribe($$self2, nodeIdSelected, (value2) => $$invalidate2(1, $nodeIdSelected = value2));
  const editNode = (e2) => {
    e2.preventDefault();
    const currentNode2 = $nodesStore2.filter((n) => n.id === $nodeIdSelected)[0];
    if (label)
      currentNode2.data.label = label;
    if (width2)
      currentNode2.width = +width2;
    if (height2)
      currentNode2.height = +height2;
    if (customClass)
      currentNode2.className = customClass;
    if (backgroundColor)
      currentNode2.bgColor = backgroundColor;
    $$invalidate2(3, width2 = "");
    $$invalidate2(4, height2 = "");
    $$invalidate2(5, customClass = "");
    $$invalidate2(2, label = "");
    store.nodesStore.set($nodesStore2);
    document.querySelector(`.edit-modal-${key2}`).style.display = "none";
  };
  const changeLabel = (e2) => {
    const currentNode2 = $nodesStore2.filter((n) => n.id === $nodeIdSelected)[0];
    currentNode2.data.label = e2.target.value;
    store.nodesStore.set($nodesStore2);
  };
  $$self2.$$.on_mount.push(function() {
    if (key2 === void 0 && !("key" in $$props2 || $$self2.$$.bound[$$self2.$$.props["key"]])) {
      console.warn("<EditModal> was created without expected prop 'key'");
    }
  });
  const writable_props2 = ["key"];
  Object.keys($$props2).forEach((key3) => {
    if (!~writable_props2.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<EditModal> was created with unknown prop '${key3}'`);
  });
  function input0_input_handler() {
    label = this.value;
    $$invalidate2(2, label);
  }
  function input1_input_handler() {
    width2 = to_number(this.value);
    $$invalidate2(3, width2);
  }
  function input2_input_handler() {
    height2 = to_number(this.value);
    $$invalidate2(4, height2);
  }
  function input3_input_handler() {
    backgroundColor = this.value;
    $$invalidate2(6, backgroundColor);
  }
  function input4_input_handler() {
    backgroundColor = this.value;
    $$invalidate2(6, backgroundColor);
  }
  function input5_input_handler() {
    customClass = this.value;
    $$invalidate2(5, customClass);
  }
  const click_handler = (e2) => {
    deleteNode(e2, $nodeIdSelected);
    document.querySelector(`.edit-modal-${key2}`).style.display = "none";
  };
  $$self2.$$set = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(0, key2 = $$props3.key);
  };
  $$self2.$capture_state = () => ({
    findOrCreateStore,
    key: key2,
    label,
    width: width2,
    height: height2,
    customClass,
    backgroundColor,
    currentNode,
    nodesStore: nodesStore2,
    nodeIdSelected,
    deleteNode,
    editNode,
    changeLabel,
    store,
    $nodesStore: $nodesStore2,
    $nodeIdSelected
  });
  $$self2.$inject_state = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(0, key2 = $$props3.key);
    if ("label" in $$props3)
      $$invalidate2(2, label = $$props3.label);
    if ("width" in $$props3)
      $$invalidate2(3, width2 = $$props3.width);
    if ("height" in $$props3)
      $$invalidate2(4, height2 = $$props3.height);
    if ("customClass" in $$props3)
      $$invalidate2(5, customClass = $$props3.customClass);
    if ("backgroundColor" in $$props3)
      $$invalidate2(6, backgroundColor = $$props3.backgroundColor);
    if ("currentNode" in $$props3)
      $$invalidate2(7, currentNode = $$props3.currentNode);
    if ("store" in $$props3)
      store = $$props3.store;
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*key*/
    1) {
      $:
        store = findOrCreateStore(key2);
    }
    if ($$self2.$$.dirty & /*$nodesStore, $nodeIdSelected*/
    8194) {
      $:
        $$invalidate2(7, currentNode = $nodesStore2.filter((n) => n.id === $nodeIdSelected)[0]);
    }
  };
  return [
    key2,
    $nodeIdSelected,
    label,
    width2,
    height2,
    customClass,
    backgroundColor,
    currentNode,
    nodesStore2,
    nodeIdSelected,
    deleteNode,
    editNode,
    changeLabel,
    $nodesStore2,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler,
    input4_input_handler,
    input5_input_handler,
    click_handler
  ];
}
var EditModal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { key: 0 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EditModal",
      options,
      id: create_fragment8.name
    });
  }
  get key() {
    throw new Error("<EditModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value2) {
    throw new Error("<EditModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EditModal_default = EditModal;

// node_modules/svelvet/Containers/Minimap/GreyNodeBoundless.svelte
var file5 = "node_modules/svelvet/Containers/Minimap/GreyNodeBoundless.svelte";
function add_css4(target) {
  append_styles(target, "svelte-14qfyer", ".nodes.svelte-14qfyer{position:absolute;background-color:black;color:black;opacity:20%;z-index:9;border-radius:.1rem}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JleU5vZGVCb3VuZGxlc3Muc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTBCQSxxQkFBTSxDQUFBLEFBQ0YsU0FBUyxRQUFRLENBQ2pCLGdCQUFnQixDQUFFLEtBQUssQ0FDdkIsS0FBSyxDQUFFLEtBQUssQ0FDWixPQUFPLENBQUUsR0FBRyxDQUNaLE9BQU8sQ0FBRSxDQUFDLENBQ1YsYUFBYSxDQUFFLEtBQUssQUFDeEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJHcmV5Tm9kZUJvdW5kbGVzcy5zdmVsdGUiXX0= */");
}
function create_fragment9(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create2() {
      div = element("div");
      attr_dev(div, "class", div_class_value = "nodes nodes-" + /*key*/
      ctx[0] + " svelte-14qfyer");
      set_style(
        div,
        "top",
        /*top*/
        ctx[1] + "px"
      );
      set_style(
        div,
        "left",
        /*left*/
        ctx[2] + "px"
      );
      set_style(
        div,
        "height",
        /*nHeight*/
        ctx[4] + "px"
      );
      set_style(
        div,
        "width",
        /*nWidth*/
        ctx[3] + "px"
      );
      add_location(div, file5, 23, 0, 699);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*key*/
      1 && div_class_value !== (div_class_value = "nodes nodes-" + /*key*/
      ctx2[0] + " svelte-14qfyer")) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & /*top*/
      2) {
        set_style(
          div,
          "top",
          /*top*/
          ctx2[1] + "px"
        );
      }
      if (dirty & /*left*/
      4) {
        set_style(
          div,
          "left",
          /*left*/
          ctx2[2] + "px"
        );
      }
      if (dirty & /*nHeight*/
      16) {
        set_style(
          div,
          "height",
          /*nHeight*/
          ctx2[4] + "px"
        );
      }
      if (dirty & /*nWidth*/
      8) {
        set_style(
          div,
          "width",
          /*nWidth*/
          ctx2[3] + "px"
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("GreyNodeBoundless", slots2, []);
  let { key: key2 } = $$props2;
  let { node } = $$props2;
  let { heightRatio } = $$props2;
  let { widthRatio } = $$props2;
  let { nodeXleftPosition } = $$props2;
  let { nodeYbottomPosition } = $$props2;
  let top = 0;
  let left = 0;
  let nWidth = 0;
  let nHeight = 0;
  $$self2.$$.on_mount.push(function() {
    if (key2 === void 0 && !("key" in $$props2 || $$self2.$$.bound[$$self2.$$.props["key"]])) {
      console.warn("<GreyNodeBoundless> was created without expected prop 'key'");
    }
    if (node === void 0 && !("node" in $$props2 || $$self2.$$.bound[$$self2.$$.props["node"]])) {
      console.warn("<GreyNodeBoundless> was created without expected prop 'node'");
    }
    if (heightRatio === void 0 && !("heightRatio" in $$props2 || $$self2.$$.bound[$$self2.$$.props["heightRatio"]])) {
      console.warn("<GreyNodeBoundless> was created without expected prop 'heightRatio'");
    }
    if (widthRatio === void 0 && !("widthRatio" in $$props2 || $$self2.$$.bound[$$self2.$$.props["widthRatio"]])) {
      console.warn("<GreyNodeBoundless> was created without expected prop 'widthRatio'");
    }
    if (nodeXleftPosition === void 0 && !("nodeXleftPosition" in $$props2 || $$self2.$$.bound[$$self2.$$.props["nodeXleftPosition"]])) {
      console.warn("<GreyNodeBoundless> was created without expected prop 'nodeXleftPosition'");
    }
    if (nodeYbottomPosition === void 0 && !("nodeYbottomPosition" in $$props2 || $$self2.$$.bound[$$self2.$$.props["nodeYbottomPosition"]])) {
      console.warn("<GreyNodeBoundless> was created without expected prop 'nodeYbottomPosition'");
    }
  });
  const writable_props2 = [
    "key",
    "node",
    "heightRatio",
    "widthRatio",
    "nodeXleftPosition",
    "nodeYbottomPosition"
  ];
  Object.keys($$props2).forEach((key3) => {
    if (!~writable_props2.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<GreyNodeBoundless> was created with unknown prop '${key3}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(0, key2 = $$props3.key);
    if ("node" in $$props3)
      $$invalidate2(5, node = $$props3.node);
    if ("heightRatio" in $$props3)
      $$invalidate2(6, heightRatio = $$props3.heightRatio);
    if ("widthRatio" in $$props3)
      $$invalidate2(7, widthRatio = $$props3.widthRatio);
    if ("nodeXleftPosition" in $$props3)
      $$invalidate2(8, nodeXleftPosition = $$props3.nodeXleftPosition);
    if ("nodeYbottomPosition" in $$props3)
      $$invalidate2(9, nodeYbottomPosition = $$props3.nodeYbottomPosition);
  };
  $$self2.$capture_state = () => ({
    key: key2,
    node,
    heightRatio,
    widthRatio,
    nodeXleftPosition,
    nodeYbottomPosition,
    top,
    left,
    nWidth,
    nHeight
  });
  $$self2.$inject_state = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(0, key2 = $$props3.key);
    if ("node" in $$props3)
      $$invalidate2(5, node = $$props3.node);
    if ("heightRatio" in $$props3)
      $$invalidate2(6, heightRatio = $$props3.heightRatio);
    if ("widthRatio" in $$props3)
      $$invalidate2(7, widthRatio = $$props3.widthRatio);
    if ("nodeXleftPosition" in $$props3)
      $$invalidate2(8, nodeXleftPosition = $$props3.nodeXleftPosition);
    if ("nodeYbottomPosition" in $$props3)
      $$invalidate2(9, nodeYbottomPosition = $$props3.nodeYbottomPosition);
    if ("top" in $$props3)
      $$invalidate2(1, top = $$props3.top);
    if ("left" in $$props3)
      $$invalidate2(2, left = $$props3.left);
    if ("nWidth" in $$props3)
      $$invalidate2(3, nWidth = $$props3.nWidth);
    if ("nHeight" in $$props3)
      $$invalidate2(4, nHeight = $$props3.nHeight);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*node, heightRatio, widthRatio, nodeYbottomPosition, nodeXleftPosition*/
    992) {
      $: {
        $$invalidate2(4, nHeight = Math.max(node.height * heightRatio, 5));
        $$invalidate2(3, nWidth = Math.max(node.width * widthRatio, 5));
        $$invalidate2(1, top = node.position.y * heightRatio - nodeYbottomPosition * heightRatio + 1);
        $$invalidate2(2, left = node.position.x * widthRatio - nodeXleftPosition * widthRatio + 1);
      }
    }
  };
  return [
    key2,
    top,
    left,
    nWidth,
    nHeight,
    node,
    heightRatio,
    widthRatio,
    nodeXleftPosition,
    nodeYbottomPosition
  ];
}
var GreyNodeBoundless = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance9,
      create_fragment9,
      safe_not_equal,
      {
        key: 0,
        node: 5,
        heightRatio: 6,
        widthRatio: 7,
        nodeXleftPosition: 8,
        nodeYbottomPosition: 9
      },
      add_css4
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GreyNodeBoundless",
      options,
      id: create_fragment9.name
    });
  }
  get key() {
    throw new Error("<GreyNodeBoundless>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value2) {
    throw new Error("<GreyNodeBoundless>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get node() {
    throw new Error("<GreyNodeBoundless>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value2) {
    throw new Error("<GreyNodeBoundless>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get heightRatio() {
    throw new Error("<GreyNodeBoundless>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set heightRatio(value2) {
    throw new Error("<GreyNodeBoundless>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get widthRatio() {
    throw new Error("<GreyNodeBoundless>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set widthRatio(value2) {
    throw new Error("<GreyNodeBoundless>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeXleftPosition() {
    throw new Error("<GreyNodeBoundless>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeXleftPosition(value2) {
    throw new Error("<GreyNodeBoundless>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeYbottomPosition() {
    throw new Error("<GreyNodeBoundless>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeYbottomPosition(value2) {
    throw new Error("<GreyNodeBoundless>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GreyNodeBoundless_default = GreyNodeBoundless;

// node_modules/svelvet/Containers/Minimap/MinimapBoundless.svelte
var file6 = "node_modules/svelvet/Containers/Minimap/MinimapBoundless.svelte";
function add_css5(target) {
  append_styles(target, "svelte-enqdqj", ".miniMap.svelte-enqdqj{height:100px;width:100px;background-color:rgb(237, 236, 236);border:solid black;border-width:1px;border-radius:.5rem;color:rgb(142, 142, 142);position:absolute;bottom:15px;right:15px;z-index:10;box-shadow:2px 2px 7px rgb(77, 77, 77);overflow:hidden}.viewBox.svelte-enqdqj{background-color:rgb(120, 120, 120);border:solid red 1px;position:absolute}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWluaW1hcEJvdW5kbGVzcy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBdUdJLFFBQVEsY0FBQyxDQUFBLEFBQ0wsTUFBTSxDQUFFLEtBQUssQ0FDYixLQUFLLENBQUUsS0FBSyxDQUNaLGdCQUFnQixDQUFFLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ3BDLE1BQU0sQ0FBRSxLQUFLLENBQUMsS0FBSyxDQUNuQixZQUFZLENBQUUsR0FBRyxDQUNqQixhQUFhLENBQUUsS0FBSyxDQUNwQixLQUFLLENBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDekIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsTUFBTSxDQUFFLElBQUksQ0FDWixLQUFLLENBQUUsSUFBSSxDQUNYLFFBQVEsRUFBRSxDQUNWLFVBQVUsQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUN2QyxRQUFRLENBQUUsTUFBTSxBQUNwQixDQUFBLEFBQ0Esc0JBQVEsQ0FBQSxBQUNKLGdCQUFnQixDQUFFLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ3BDLE1BQU0sQ0FBRSxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FDckIsUUFBUSxDQUFFLFFBQVEsQUFDdEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJNaW5pbWFwQm91bmRsZXNzLnN2ZWx0ZSJdfQ== */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let greynode;
  let current;
  greynode = new GreyNodeBoundless_default({
    props: {
      node: (
        /*node*/
        ctx[31]
      ),
      key: (
        /*key*/
        ctx[0]
      ),
      heightRatio: (
        /*heightRatio*/
        ctx[3]
      ),
      widthRatio: (
        /*widthRatio*/
        ctx[4]
      ),
      nodeXleftPosition: (
        /*nodeXleftPosition*/
        ctx[5]
      ),
      nodeYbottomPosition: (
        /*nodeYbottomPosition*/
        ctx[6]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(greynode.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(greynode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const greynode_changes = {};
      if (dirty[0] & /*$nodesStore*/
      128)
        greynode_changes.node = /*node*/
        ctx2[31];
      if (dirty[0] & /*key*/
      1)
        greynode_changes.key = /*key*/
        ctx2[0];
      if (dirty[0] & /*heightRatio*/
      8)
        greynode_changes.heightRatio = /*heightRatio*/
        ctx2[3];
      if (dirty[0] & /*widthRatio*/
      16)
        greynode_changes.widthRatio = /*widthRatio*/
        ctx2[4];
      if (dirty[0] & /*nodeXleftPosition*/
      32)
        greynode_changes.nodeXleftPosition = /*nodeXleftPosition*/
        ctx2[5];
      if (dirty[0] & /*nodeYbottomPosition*/
      64)
        greynode_changes.nodeYbottomPosition = /*nodeYbottomPosition*/
        ctx2[6];
      greynode.$set(greynode_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(greynode.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(greynode.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(greynode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(99:8) {#each $nodesStore as node}",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let t;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*$nodesStore*/
    ctx[7]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create2() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div0, "class", div0_class_value = "viewBox viewBox-" + /*key*/
      ctx[0] + " svelte-enqdqj");
      set_style(
        div0,
        "height",
        /*viewHeight*/
        ctx[8] + "px"
      );
      set_style(
        div0,
        "width",
        /*viewWidth*/
        ctx[9] + "px"
      );
      set_style(
        div0,
        "top",
        /*viewBottom*/
        ctx[11] + "px"
      );
      set_style(
        div0,
        "left",
        /*viewRight*/
        ctx[10] + "px"
      );
      add_location(div0, file6, 97, 8, 3967);
      attr_dev(div1, "class", div1_class_value = null_to_empty(`miniMap miniMap-${/*key*/
      ctx[0]}`) + " svelte-enqdqj");
      set_style(
        div1,
        "height",
        /*mapHeight*/
        ctx[2] + 20 + "px"
      );
      set_style(
        div1,
        "width",
        /*mapWidth*/
        ctx[1] + 20 + "px"
      );
      add_location(div1, file6, 96, 4, 3798);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div1, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      ctx[24](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*handleClick*/
            ctx[16],
            false,
            false,
            false
          ),
          listen_dev(div1, "keydown", keydown_handler2, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*key*/
      1 && div0_class_value !== (div0_class_value = "viewBox viewBox-" + /*key*/
      ctx2[0] + " svelte-enqdqj")) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*viewHeight*/
      256) {
        set_style(
          div0,
          "height",
          /*viewHeight*/
          ctx2[8] + "px"
        );
      }
      if (!current || dirty[0] & /*viewWidth*/
      512) {
        set_style(
          div0,
          "width",
          /*viewWidth*/
          ctx2[9] + "px"
        );
      }
      if (!current || dirty[0] & /*viewBottom*/
      2048) {
        set_style(
          div0,
          "top",
          /*viewBottom*/
          ctx2[11] + "px"
        );
      }
      if (!current || dirty[0] & /*viewRight*/
      1024) {
        set_style(
          div0,
          "left",
          /*viewRight*/
          ctx2[10] + "px"
        );
      }
      if (dirty[0] & /*$nodesStore, key, heightRatio, widthRatio, nodeXleftPosition, nodeYbottomPosition*/
      249) {
        each_value = /*$nodesStore*/
        ctx2[7];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty[0] & /*key*/
      1 && div1_class_value !== (div1_class_value = null_to_empty(`miniMap miniMap-${/*key*/
      ctx2[0]}`) + " svelte-enqdqj")) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*mapHeight*/
      4) {
        set_style(
          div1,
          "height",
          /*mapHeight*/
          ctx2[2] + 20 + "px"
        );
      }
      if (!current || dirty[0] & /*mapWidth*/
      2) {
        set_style(
          div1,
          "width",
          /*mapWidth*/
          ctx2[1] + 20 + "px"
        );
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local2) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_each(each_blocks, detaching);
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var keydown_handler2 = () => {
  return;
};
function instance10($$self2, $$props2, $$invalidate2) {
  let $heightStore2;
  let $widthStore2;
  let $nodesStore2;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("MinimapBoundless", slots2, []);
  let { key: key2 } = $$props2;
  let { d3Translate: d3Translate2 } = $$props2;
  const svelvetStore2 = findOrCreateStore(key2);
  const { nodesStore: nodesStore2, widthStore: widthStore2, heightStore: heightStore2 } = svelvetStore2;
  validate_store(nodesStore2, "nodesStore");
  component_subscribe($$self2, nodesStore2, (value2) => $$invalidate2(7, $nodesStore2 = value2));
  validate_store(widthStore2, "widthStore");
  component_subscribe($$self2, widthStore2, (value2) => $$invalidate2(23, $widthStore2 = value2));
  validate_store(heightStore2, "heightStore");
  component_subscribe($$self2, heightStore2, (value2) => $$invalidate2(22, $heightStore2 = value2));
  const dispatch2 = createEventDispatcher();
  let mapMax = 100;
  let mapWidth = mapMax;
  let mapHeight = mapMax;
  let nodeHeight = mapMax - 10;
  let nodeWidth = mapMax - 10;
  let viewHeight = 10;
  let viewWidth = 10;
  let viewRight = 10;
  let viewBottom = 10;
  let heightRatio = 1;
  let widthRatio = 1;
  let nodeXleftPosition = Infinity;
  let nodeYtopPosition = -Infinity;
  let nodeYbottomPosition = Infinity;
  let nodeXrightPosition = -Infinity;
  let map;
  let hasBeenClicked = false;
  const scaleW = (v) => v * (mapWidth / nodeWidth);
  const scaleH = (v) => v * (mapHeight / nodeHeight);
  function handleClick(event) {
    if (!hasBeenClicked) {
      let bounds = map.getBoundingClientRect();
      hasBeenClicked = true;
      dispatch2("message", {
        x: nodeXleftPosition + (event.clientX - bounds.left) / widthRatio,
        y: nodeYbottomPosition + (event.clientY - bounds.top) / heightRatio
      });
      setTimeout(
        () => {
          hasBeenClicked = false;
        },
        500
      );
    }
  }
  $$self2.$$.on_mount.push(function() {
    if (key2 === void 0 && !("key" in $$props2 || $$self2.$$.bound[$$self2.$$.props["key"]])) {
      console.warn("<MinimapBoundless> was created without expected prop 'key'");
    }
    if (d3Translate2 === void 0 && !("d3Translate" in $$props2 || $$self2.$$.bound[$$self2.$$.props["d3Translate"]])) {
      console.warn("<MinimapBoundless> was created without expected prop 'd3Translate'");
    }
  });
  const writable_props2 = ["key", "d3Translate"];
  Object.keys($$props2).forEach((key3) => {
    if (!~writable_props2.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<MinimapBoundless> was created with unknown prop '${key3}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      map = $$value;
      $$invalidate2(12, map);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(0, key2 = $$props3.key);
    if ("d3Translate" in $$props3)
      $$invalidate2(17, d3Translate2 = $$props3.d3Translate);
  };
  $$self2.$capture_state = () => ({
    findOrCreateStore,
    onMount,
    createEventDispatcher,
    GreyNode: GreyNodeBoundless_default,
    key: key2,
    d3Translate: d3Translate2,
    svelvetStore: svelvetStore2,
    nodesStore: nodesStore2,
    widthStore: widthStore2,
    heightStore: heightStore2,
    dispatch: dispatch2,
    mapMax,
    mapWidth,
    mapHeight,
    nodeHeight,
    nodeWidth,
    viewHeight,
    viewWidth,
    viewRight,
    viewBottom,
    heightRatio,
    widthRatio,
    nodeXleftPosition,
    nodeYtopPosition,
    nodeYbottomPosition,
    nodeXrightPosition,
    map,
    hasBeenClicked,
    scaleW,
    scaleH,
    handleClick,
    $heightStore: $heightStore2,
    $widthStore: $widthStore2,
    $nodesStore: $nodesStore2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(0, key2 = $$props3.key);
    if ("d3Translate" in $$props3)
      $$invalidate2(17, d3Translate2 = $$props3.d3Translate);
    if ("mapMax" in $$props3)
      mapMax = $$props3.mapMax;
    if ("mapWidth" in $$props3)
      $$invalidate2(1, mapWidth = $$props3.mapWidth);
    if ("mapHeight" in $$props3)
      $$invalidate2(2, mapHeight = $$props3.mapHeight);
    if ("nodeHeight" in $$props3)
      $$invalidate2(18, nodeHeight = $$props3.nodeHeight);
    if ("nodeWidth" in $$props3)
      $$invalidate2(19, nodeWidth = $$props3.nodeWidth);
    if ("viewHeight" in $$props3)
      $$invalidate2(8, viewHeight = $$props3.viewHeight);
    if ("viewWidth" in $$props3)
      $$invalidate2(9, viewWidth = $$props3.viewWidth);
    if ("viewRight" in $$props3)
      $$invalidate2(10, viewRight = $$props3.viewRight);
    if ("viewBottom" in $$props3)
      $$invalidate2(11, viewBottom = $$props3.viewBottom);
    if ("heightRatio" in $$props3)
      $$invalidate2(3, heightRatio = $$props3.heightRatio);
    if ("widthRatio" in $$props3)
      $$invalidate2(4, widthRatio = $$props3.widthRatio);
    if ("nodeXleftPosition" in $$props3)
      $$invalidate2(5, nodeXleftPosition = $$props3.nodeXleftPosition);
    if ("nodeYtopPosition" in $$props3)
      $$invalidate2(20, nodeYtopPosition = $$props3.nodeYtopPosition);
    if ("nodeYbottomPosition" in $$props3)
      $$invalidate2(6, nodeYbottomPosition = $$props3.nodeYbottomPosition);
    if ("nodeXrightPosition" in $$props3)
      $$invalidate2(21, nodeXrightPosition = $$props3.nodeXrightPosition);
    if ("map" in $$props3)
      $$invalidate2(12, map = $$props3.map);
    if ("hasBeenClicked" in $$props3)
      hasBeenClicked = $$props3.hasBeenClicked;
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty[0] & /*$nodesStore, nodeXleftPosition, nodeXrightPosition, nodeYbottomPosition, nodeYtopPosition, nodeHeight, nodeWidth, mapHeight, mapWidth, d3Translate, widthRatio, heightRatio, $widthStore, $heightStore*/
    16646398) {
      $: {
        $$invalidate2(5, nodeXleftPosition = Infinity);
        $$invalidate2(20, nodeYtopPosition = -Infinity);
        $$invalidate2(6, nodeYbottomPosition = Infinity);
        $$invalidate2(21, nodeXrightPosition = -Infinity);
        $nodesStore2.forEach((node) => {
          $$invalidate2(5, nodeXleftPosition = Math.min(nodeXleftPosition, node.position.x));
          $$invalidate2(21, nodeXrightPosition = Math.max(nodeXrightPosition, node.position.x));
          $$invalidate2(6, nodeYbottomPosition = Math.min(nodeYbottomPosition, node.position.y));
          $$invalidate2(20, nodeYtopPosition = Math.max(nodeYtopPosition, node.position.y));
        });
        $$invalidate2(18, nodeHeight = nodeYtopPosition - nodeYbottomPosition);
        $$invalidate2(19, nodeWidth = nodeXrightPosition - nodeXleftPosition);
        if (nodeHeight > nodeWidth) {
          $$invalidate2(2, mapHeight = 100);
          $$invalidate2(1, mapWidth = Math.max(nodeWidth.toFixed(0) * 100 / nodeHeight.toFixed(0), 25));
        } else if (nodeHeight < nodeWidth) {
          $$invalidate2(1, mapWidth = 100);
          $$invalidate2(2, mapHeight = Math.max(nodeHeight.toFixed(0) * 100 / nodeWidth.toFixed(0), 25));
        } else {
          $$invalidate2(2, mapHeight = 100);
          $$invalidate2(1, mapWidth = 100);
        }
        $$invalidate2(3, heightRatio = (mapHeight / nodeHeight).toFixed(2));
        $$invalidate2(4, widthRatio = (mapWidth / nodeWidth).toFixed(2));
        $$invalidate2(10, viewRight = scaleW(d3Translate2.x * widthRatio - d3Translate2.x / d3Translate2.k) - nodeXleftPosition * widthRatio);
        $$invalidate2(11, viewBottom = scaleH(d3Translate2.y * heightRatio - d3Translate2.y / d3Translate2.k) - nodeYbottomPosition * heightRatio);
        $$invalidate2(9, viewWidth = $widthStore2 * widthRatio / d3Translate2.k);
        $$invalidate2(8, viewHeight = $heightStore2 * heightRatio / d3Translate2.k);
      }
    }
  };
  return [
    key2,
    mapWidth,
    mapHeight,
    heightRatio,
    widthRatio,
    nodeXleftPosition,
    nodeYbottomPosition,
    $nodesStore2,
    viewHeight,
    viewWidth,
    viewRight,
    viewBottom,
    map,
    nodesStore2,
    widthStore2,
    heightStore2,
    handleClick,
    d3Translate2,
    nodeHeight,
    nodeWidth,
    nodeYtopPosition,
    nodeXrightPosition,
    $heightStore2,
    $widthStore2,
    div1_binding
  ];
}
var MinimapBoundless = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { key: 0, d3Translate: 17 }, add_css5, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MinimapBoundless",
      options,
      id: create_fragment10.name
    });
  }
  get key() {
    throw new Error("<MinimapBoundless>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value2) {
    throw new Error("<MinimapBoundless>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get d3Translate() {
    throw new Error("<MinimapBoundless>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set d3Translate(value2) {
    throw new Error("<MinimapBoundless>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MinimapBoundless_default = MinimapBoundless;

// node_modules/svelvet/Edges/DeleteAnchor.svelte
var file7 = "node_modules/svelvet/Edges/DeleteAnchor.svelte";
function add_css6(target) {
  append_styles(target, "svelte-99zmj7", ".Anchor.svelte-99zmj7{position:absolute;cursor:pointer}svg.svelte-99zmj7{border-radius:.2rem;border:black solid 1px;background-color:#e45b56}.Anchor.svelte-99zmj7:hover{background-color:#000000}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGVsZXRlQW5jaG9yLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE2REksT0FBTyxjQUFDLENBQUEsQUFDTixRQUFRLENBQUUsUUFBUSxDQUNsQixNQUFNLENBQUUsT0FBTyxBQUNqQixDQUFBLEFBRUEsR0FBRyxjQUFDLENBQUEsQUFDRixhQUFhLENBQUUsS0FBSyxDQUNwQixNQUFNLENBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQ3ZCLGdCQUFnQixDQUFFLE9BQU8sQUFDM0IsQ0FBQSxBQUVBLHFCQUFPLE1BQU0sQUFBQyxDQUFBLEFBQ1osZ0JBQWdCLENBQUUsT0FBTyxBQUMzQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkRlbGV0ZUFuY2hvci5zdmVsdGUiXX0= */");
}
function create_fragment11(ctx) {
  let div;
  let svg;
  let path0;
  let path1;
  let div_style_value;
  let mounted;
  let dispose;
  const block = {
    c: function create2() {
      div = element("div");
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "d", "M19 5L5 19");
      attr_dev(path0, "stroke", "#333333");
      attr_dev(path0, "stroke-width", "2");
      attr_dev(path0, "stroke-linecap", "round");
      add_location(path0, file7, 58, 79, 1591);
      attr_dev(path1, "d", "M5 5L19 19");
      attr_dev(path1, "stroke", "#333333");
      attr_dev(path1, "stroke-width", "2");
      attr_dev(path1, "stroke-linecap", "round");
      add_location(path1, file7, 58, 165, 1677);
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "svelte-99zmj7");
      add_location(svg, file7, 58, 7, 1519);
      attr_dev(div, "class", "Anchor svelte-99zmj7");
      attr_dev(div, "style", div_style_value = `
        height:${/*anchorHeight*/
      ctx[5]}px;
        width:${/*anchorWidth*/
      ctx[4]}px;
        top: ${/*top*/
      ctx[6]}px;
        left:${/*left*/
      ctx[7]}px;
      `);
      add_location(div, file7, 26, 4, 600);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, svg);
      append_dev(svg, path0);
      append_dev(svg, path1);
      if (!mounted) {
        dispose = [
          listen_dev(div, "mousedown", mousedown_handler, false, false, false),
          listen_dev(
            div,
            "mouseup",
            /*mouseup_handler*/
            ctx[11],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[12],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[13],
            false,
            false,
            false
          ),
          listen_dev(div, "keydown", keydown_handler3, false, false, false)
        ];
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var mousedown_handler = (e2) => {
  e2.preventDefault();
  e2.stopPropagation();
};
var keydown_handler3 = () => {
  return;
};
function instance11($$self2, $$props2, $$invalidate2) {
  let store;
  let $derivedEdges2;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("DeleteAnchor", slots2, []);
  let { key: key2 } = $$props2;
  let { node } = $$props2;
  let hovered = false;
  let anchorWidth = 13;
  let anchorHeight = 13;
  let top = 0;
  let left = 0;
  const { deleteNode, derivedEdges: derivedEdges2, nodeLinkStore } = findOrCreateStore(key2);
  validate_store(derivedEdges2, "derivedEdges");
  component_subscribe($$self2, derivedEdges2, (value2) => $$invalidate2(3, $derivedEdges2 = value2));
  $$self2.$$.on_mount.push(function() {
    if (key2 === void 0 && !("key" in $$props2 || $$self2.$$.bound[$$self2.$$.props["key"]])) {
      console.warn("<DeleteAnchor> was created without expected prop 'key'");
    }
    if (node === void 0 && !("node" in $$props2 || $$self2.$$.bound[$$self2.$$.props["node"]])) {
      console.warn("<DeleteAnchor> was created without expected prop 'node'");
    }
  });
  const writable_props2 = ["key", "node"];
  Object.keys($$props2).forEach((key3) => {
    if (!~writable_props2.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<DeleteAnchor> was created with unknown prop '${key3}'`);
  });
  const mouseup_handler = (e2) => {
    e2.preventDefault();
    deleteNode(e2, node.id);
  };
  const mouseenter_handler = (e2) => {
    $$invalidate2(1, hovered = true);
    store.hoveredElement.set(node);
  };
  const mouseleave_handler = (e2) => {
    store.edgesStore.set($derivedEdges2);
    $$invalidate2(1, hovered = false);
    store.hoveredElement.set(null);
  };
  $$self2.$$set = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(10, key2 = $$props3.key);
    if ("node" in $$props3)
      $$invalidate2(0, node = $$props3.node);
  };
  $$self2.$capture_state = () => ({
    findOrCreateStore,
    key: key2,
    node,
    hovered,
    anchorWidth,
    anchorHeight,
    top,
    left,
    deleteNode,
    derivedEdges: derivedEdges2,
    nodeLinkStore,
    store,
    $derivedEdges: $derivedEdges2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(10, key2 = $$props3.key);
    if ("node" in $$props3)
      $$invalidate2(0, node = $$props3.node);
    if ("hovered" in $$props3)
      $$invalidate2(1, hovered = $$props3.hovered);
    if ("anchorWidth" in $$props3)
      $$invalidate2(4, anchorWidth = $$props3.anchorWidth);
    if ("anchorHeight" in $$props3)
      $$invalidate2(5, anchorHeight = $$props3.anchorHeight);
    if ("top" in $$props3)
      $$invalidate2(6, top = $$props3.top);
    if ("left" in $$props3)
      $$invalidate2(7, left = $$props3.left);
    if ("store" in $$props3)
      $$invalidate2(2, store = $$props3.store);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*key*/
    1024) {
      $:
        $$invalidate2(2, store = findOrCreateStore(key2));
    }
  };
  return [
    node,
    hovered,
    store,
    $derivedEdges2,
    anchorWidth,
    anchorHeight,
    top,
    left,
    deleteNode,
    derivedEdges2,
    key2,
    mouseup_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var DeleteAnchor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { key: 10, node: 0 }, add_css6);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DeleteAnchor",
      options,
      id: create_fragment11.name
    });
  }
  get key() {
    throw new Error("<DeleteAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value2) {
    throw new Error("<DeleteAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get node() {
    throw new Error("<DeleteAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value2) {
    throw new Error("<DeleteAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DeleteAnchor_default = DeleteAnchor;

// node_modules/svelvet/Nodes/index.svelte
var file8 = "node_modules/svelvet/Nodes/index.svelte";
function add_css7(target) {
  append_styles(target, "svelte-14vkmyj", ".Node.svelte-14vkmyj{position:absolute;display:grid;user-select:none;cursor:move;justify-content:center;overscroll-behavior:auto;align-items:center;font-size:14px;text-align:center;border:solid 1px black;border-radius:5px;box-shadow:1px 1px 3px 1px rgba(0, 0, 0, 0.2);transform-style:preserve-3d;color:black}.Node.svelte-14vkmyj:hover{box-shadow:1px 1px 3px 1px rgba(0, 0, 0, 0.4)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWlLRSxLQUFLLGVBQUMsQ0FBQSxBQUNKLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLElBQUksQ0FDakIsTUFBTSxDQUFFLElBQUksQ0FDWixlQUFlLENBQUUsTUFBTSxDQUN2QixtQkFBbUIsQ0FBRSxJQUFJLENBQ3pCLFdBQVcsQ0FBRSxNQUFNLENBQ25CLFNBQVMsQ0FBRSxJQUFJLENBQ2YsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsTUFBTSxDQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUN2QixhQUFhLENBQUUsR0FBRyxDQUNsQixVQUFVLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQzlDLGVBQWUsQ0FBRSxXQUFXLENBQzVCLEtBQUssQ0FBRSxLQUFLLEFBQ2QsQ0FBQSxBQUVBLG9CQUFLLE1BQU0sQUFBQyxDQUFBLEFBQ1YsVUFBVSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxBQUNoRCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbImluZGV4LnN2ZWx0ZSJdfQ== */");
}
function create_if_block_2(ctx) {
  let deleteanchor;
  let current;
  deleteanchor = new DeleteAnchor_default({
    props: {
      key: (
        /*key*/
        ctx[1]
      ),
      node: (
        /*node*/
        ctx[0]
      ),
      width: (
        /*nodeWidth*/
        ctx[4] || /*node*/
        ctx[0].width
      ),
      height: (
        /*nodeHeight*/
        ctx[5] || /*node*/
        ctx[0].height
      ),
      position: (
        /*node*/
        ctx[0].targetPosition || "top"
      ),
      role: "target"
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(deleteanchor.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(deleteanchor, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const deleteanchor_changes = {};
      if (dirty[0] & /*key*/
      2)
        deleteanchor_changes.key = /*key*/
        ctx2[1];
      if (dirty[0] & /*node*/
      1)
        deleteanchor_changes.node = /*node*/
        ctx2[0];
      if (dirty[0] & /*nodeWidth, node*/
      17)
        deleteanchor_changes.width = /*nodeWidth*/
        ctx2[4] || /*node*/
        ctx2[0].width;
      if (dirty[0] & /*nodeHeight, node*/
      33)
        deleteanchor_changes.height = /*nodeHeight*/
        ctx2[5] || /*node*/
        ctx2[0].height;
      if (dirty[0] & /*node*/
      1)
        deleteanchor_changes.position = /*node*/
        ctx2[0].targetPosition || "top";
      deleteanchor.$set(deleteanchor_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(deleteanchor.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(deleteanchor.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(deleteanchor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(134:0) {#if node.delete || $deleteNodes}",
    ctx
  });
  return block;
}
function create_else_block4(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[29].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      add_location(div, file8, 152, 6, 4022);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(default_slot, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(default_slot, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(152:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let div;
  let p;
  let t_value = (
    /*node*/
    ctx[0].data.label + ""
  );
  let t;
  const block = {
    c: function create2() {
      div = element("div");
      p = element("p");
      t = text2(t_value);
      add_location(p, file8, 149, 8, 3962);
      add_location(div, file8, 148, 6, 3948);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, p);
      append_dev(p, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*node*/
      1 && t_value !== (t_value = /*node*/
      ctx2[0].data.label + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(148:30) ",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create2() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*node*/
      ctx[0].src))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "");
      set_style(
        img,
        "width",
        /*node*/
        ctx[0].width * 0.85 + "px"
      );
      set_style(
        img,
        "height",
        /*node*/
        ctx[0].height * 0.85 + "px"
      );
      set_style(img, "overflow", "hidden");
      add_location(img, file8, 140, 6, 3745);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*node*/
      1 && !src_url_equal(img.src, img_src_value = /*node*/
      ctx2[0].src)) {
        attr_dev(img, "src", img_src_value);
      }
      if (dirty[0] & /*node*/
      1) {
        set_style(
          img,
          "width",
          /*node*/
          ctx2[0].width * 0.85 + "px"
        );
      }
      if (dirty[0] & /*node*/
      1) {
        set_style(
          img,
          "height",
          /*node*/
          ctx2[0].height * 0.85 + "px"
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(140:4) {#if node.image}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let div;
  let t02;
  let edgeanchor0;
  let t12;
  let current_block_type_index;
  let if_block1;
  let t22;
  let edgeanchor1;
  let div_class_value;
  let div_style_value;
  let div_id_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*node*/
    (ctx[0].delete || /*$deleteNodes*/
    ctx[14]) && create_if_block_2(ctx)
  );
  edgeanchor0 = new EdgeAnchor_default({
    props: {
      key: (
        /*key*/
        ctx[1]
      ),
      node: (
        /*node*/
        ctx[0]
      ),
      width: (
        /*nodeWidth*/
        ctx[4] || /*node*/
        ctx[0].width
      ),
      height: (
        /*nodeHeight*/
        ctx[5] || /*node*/
        ctx[0].height
      ),
      position: (
        /*node*/
        ctx[0].targetPosition || "top"
      ),
      role: "target"
    },
    $$inline: true
  });
  const if_block_creators = [create_if_block5, create_if_block_12, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (/*node*/
    ctx2[0].image)
      return 0;
    if (/*node*/
    ctx2[0].data.label)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  edgeanchor1 = new EdgeAnchor_default({
    props: {
      key: (
        /*key*/
        ctx[1]
      ),
      node: (
        /*node*/
        ctx[0]
      ),
      width: (
        /*nodeWidth*/
        ctx[4] || /*node*/
        ctx[0].width
      ),
      height: (
        /*nodeHeight*/
        ctx[5] || /*node*/
        ctx[0].height
      ),
      position: (
        /*node*/
        ctx[0].sourcePosition || "bottom"
      ),
      role: "source"
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t02 = space();
      create_component(edgeanchor0.$$.fragment);
      t12 = space();
      if_block1.c();
      t22 = space();
      create_component(edgeanchor1.$$.fragment);
      attr_dev(div, "class", div_class_value = "Node " + /*node*/
      (ctx[0].className || "") + " svelte-14vkmyj");
      attr_dev(div, "style", div_style_value = "left: " + /*node*/
      ctx[0].position.x + "px; top: " + /*node*/
      ctx[0].position.y + "px; width: " + /*nodeWidth*/
      (ctx[4] || /*node*/
      ctx[0].width) + "px; height: " + /*nodeHeight*/
      (ctx[5] || /*node*/
      ctx[0].height) + "px; background-color: " + /*node*/
      ctx[0].bgColor + "; border-color: " + /*node*/
      ctx[0].borderColor + "; border-radius: " + /*node*/
      ctx[0].borderRadius + "px; color: " + /*node*/
      ctx[0].textColor + "; " + /*customCssText*/
      ctx[3]);
      attr_dev(div, "id", div_id_value = "svelvet-" + /*node*/
      ctx[0].id);
      add_location(div, file8, 82, 0, 2242);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t02);
      mount_component(edgeanchor0, div, null);
      append_dev(div, t12);
      if_blocks[current_block_type_index].m(div, null);
      append_dev(div, t22);
      mount_component(edgeanchor1, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "mousemove",
            /*mousemove_handler*/
            ctx[30],
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "mouseup",
            /*mouseup_handler*/
            ctx[31],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseup",
            /*mouseup_handler_1*/
            ctx[32],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[33],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "touchmove",
            /*touchmove_handler*/
            ctx[34],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "touchstart",
            /*touchstart_handler*/
            ctx[35],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "touchend",
            /*touchend_handler*/
            ctx[36],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mousedown",
            /*mousedown_handler*/
            ctx[37],
            false,
            false,
            false
          ),
          listen_dev(div, "keydown", keydown_handler4, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (/*node*/
      ctx2[0].delete || /*$deleteNodes*/
      ctx2[14]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*node, $deleteNodes*/
          16385) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t02);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const edgeanchor0_changes = {};
      if (dirty[0] & /*key*/
      2)
        edgeanchor0_changes.key = /*key*/
        ctx2[1];
      if (dirty[0] & /*node*/
      1)
        edgeanchor0_changes.node = /*node*/
        ctx2[0];
      if (dirty[0] & /*nodeWidth, node*/
      17)
        edgeanchor0_changes.width = /*nodeWidth*/
        ctx2[4] || /*node*/
        ctx2[0].width;
      if (dirty[0] & /*nodeHeight, node*/
      33)
        edgeanchor0_changes.height = /*nodeHeight*/
        ctx2[5] || /*node*/
        ctx2[0].height;
      if (dirty[0] & /*node*/
      1)
        edgeanchor0_changes.position = /*node*/
        ctx2[0].targetPosition || "top";
      edgeanchor0.$set(edgeanchor0_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, t22);
      }
      const edgeanchor1_changes = {};
      if (dirty[0] & /*key*/
      2)
        edgeanchor1_changes.key = /*key*/
        ctx2[1];
      if (dirty[0] & /*node*/
      1)
        edgeanchor1_changes.node = /*node*/
        ctx2[0];
      if (dirty[0] & /*nodeWidth, node*/
      17)
        edgeanchor1_changes.width = /*nodeWidth*/
        ctx2[4] || /*node*/
        ctx2[0].width;
      if (dirty[0] & /*nodeHeight, node*/
      33)
        edgeanchor1_changes.height = /*nodeHeight*/
        ctx2[5] || /*node*/
        ctx2[0].height;
      if (dirty[0] & /*node*/
      1)
        edgeanchor1_changes.position = /*node*/
        ctx2[0].sourcePosition || "bottom";
      edgeanchor1.$set(edgeanchor1_changes);
      if (!current || dirty[0] & /*node*/
      1 && div_class_value !== (div_class_value = "Node " + /*node*/
      (ctx2[0].className || "") + " svelte-14vkmyj")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*node, nodeWidth, nodeHeight, customCssText*/
      57 && div_style_value !== (div_style_value = "left: " + /*node*/
      ctx2[0].position.x + "px; top: " + /*node*/
      ctx2[0].position.y + "px; width: " + /*nodeWidth*/
      (ctx2[4] || /*node*/
      ctx2[0].width) + "px; height: " + /*nodeHeight*/
      (ctx2[5] || /*node*/
      ctx2[0].height) + "px; background-color: " + /*node*/
      ctx2[0].bgColor + "; border-color: " + /*node*/
      ctx2[0].borderColor + "; border-radius: " + /*node*/
      ctx2[0].borderRadius + "px; color: " + /*node*/
      ctx2[0].textColor + "; " + /*customCssText*/
      ctx2[3])) {
        attr_dev(div, "style", div_style_value);
      }
      if (!current || dirty[0] & /*node*/
      1 && div_id_value !== (div_id_value = "svelvet-" + /*node*/
      ctx2[0].id)) {
        attr_dev(div, "id", div_id_value);
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(edgeanchor0.$$.fragment, local2);
      transition_in(if_block1);
      transition_in(edgeanchor1.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block0);
      transition_out(edgeanchor0.$$.fragment, local2);
      transition_out(if_block1);
      transition_out(edgeanchor1.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      destroy_component(edgeanchor0);
      if_blocks[current_block_type_index].d();
      destroy_component(edgeanchor1);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var keydown_handler4 = () => {
  return;
};
function instance12($$self2, $$props2, $$invalidate2) {
  let shouldMove;
  let $nodeIdSelected;
  let $movementStore2;
  let $isLocked;
  let $snapgrid;
  let $snapResize;
  let $nodeSelected2;
  let $nodeEditStore;
  let $deleteNodes;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Nodes", slots2, ["default"]);
  let { node } = $$props2;
  let { key: key2 } = $$props2;
  let customCssText = "";
  let nodeWidth;
  let nodeHeight;
  const { onNodeMove, onNodeClick, onTouchMove, getStyles, nodeSelected: nodeSelected2, nodeIdSelected, movementStore: movementStore2, snapgrid, snapResize, isLocked: isLocked2, nodeEditStore, deleteNodes } = findOrCreateStore(key2);
  validate_store(nodeSelected2, "nodeSelected");
  component_subscribe($$self2, nodeSelected2, (value2) => $$invalidate2(12, $nodeSelected2 = value2));
  validate_store(nodeIdSelected, "nodeIdSelected");
  component_subscribe($$self2, nodeIdSelected, (value2) => $$invalidate2(8, $nodeIdSelected = value2));
  validate_store(movementStore2, "movementStore");
  component_subscribe($$self2, movementStore2, (value2) => $$invalidate2(27, $movementStore2 = value2));
  validate_store(snapgrid, "snapgrid");
  component_subscribe($$self2, snapgrid, (value2) => $$invalidate2(10, $snapgrid = value2));
  validate_store(snapResize, "snapResize");
  component_subscribe($$self2, snapResize, (value2) => $$invalidate2(11, $snapResize = value2));
  validate_store(isLocked2, "isLocked");
  component_subscribe($$self2, isLocked2, (value2) => $$invalidate2(9, $isLocked = value2));
  validate_store(nodeEditStore, "nodeEditStore");
  component_subscribe($$self2, nodeEditStore, (value2) => $$invalidate2(13, $nodeEditStore = value2));
  validate_store(deleteNodes, "deleteNodes");
  component_subscribe($$self2, deleteNodes, (value2) => $$invalidate2(14, $deleteNodes = value2));
  let moving = false;
  let moved = false;
  let label;
  const showEditModal = (e2, node2) => {
    e2.preventDefault();
    set_store_value(nodeIdSelected, $nodeIdSelected = node2.id, $nodeIdSelected);
    const input = document.querySelector(".edit-modal");
    input.style.display = "flex";
  };
  afterUpdate((e2) => {
    if (node.className) {
      const [width2, height2, innerText] = getStyles(e2, node);
      $$invalidate2(4, nodeWidth = width2);
      $$invalidate2(5, nodeHeight = height2);
      $$invalidate2(3, customCssText = innerText);
    }
  });
  $$self2.$$.on_mount.push(function() {
    if (node === void 0 && !("node" in $$props2 || $$self2.$$.bound[$$self2.$$.props["node"]])) {
      console.warn("<Nodes> was created without expected prop 'node'");
    }
    if (key2 === void 0 && !("key" in $$props2 || $$self2.$$.bound[$$self2.$$.props["key"]])) {
      console.warn("<Nodes> was created without expected prop 'key'");
    }
  });
  const writable_props2 = ["node", "key"];
  Object.keys($$props2).forEach((key3) => {
    if (!~writable_props2.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<Nodes> was created with unknown prop '${key3}'`);
  });
  const mousemove_handler = (e2) => {
    e2.preventDefault();
    if (shouldMove && !$isLocked) {
      onNodeMove(e2, node.id);
      $$invalidate2(6, moved = true);
    }
  };
  const mouseup_handler = (e2) => {
    if ($snapgrid) {
      $$invalidate2(0, node.position.x = Math.floor(node.position.x / $snapResize) * $snapResize, node);
      $$invalidate2(0, node.position.y = Math.floor(node.position.y / $snapResize) * $snapResize, node);
      onNodeMove(e2, node.id);
    }
    $$invalidate2(2, moving = false);
    set_store_value(nodeSelected2, $nodeSelected2 = false, $nodeSelected2);
    $$invalidate2(6, moved = false);
  };
  const mouseup_handler_1 = (e2) => {
    if (!moved && node.id == $nodeIdSelected) {
      onNodeClick(e2, node.id);
    }
  };
  const contextmenu_handler2 = (e2) => {
    if ($nodeEditStore)
      showEditModal(e2, node);
  };
  const touchmove_handler = (e2) => {
    if (shouldMove) {
      onTouchMove(e2, node.id);
    }
  };
  const touchstart_handler = (e2) => {
    e2.preventDefault();
    $$invalidate2(2, moving = true);
    set_store_value(nodeSelected2, $nodeSelected2 = true, $nodeSelected2);
  };
  const touchend_handler = (e2) => {
    $$invalidate2(2, moving = false);
    set_store_value(nodeSelected2, $nodeSelected2 = false, $nodeSelected2);
  };
  const mousedown_handler2 = (e2) => {
    e2.preventDefault();
    $$invalidate2(2, moving = true);
    set_store_value(nodeIdSelected, $nodeIdSelected = node.id, $nodeIdSelected);
    set_store_value(nodeSelected2, $nodeSelected2 = true, $nodeSelected2);
  };
  $$self2.$$set = ($$props3) => {
    if ("node" in $$props3)
      $$invalidate2(0, node = $$props3.node);
    if ("key" in $$props3)
      $$invalidate2(1, key2 = $$props3.key);
    if ("$$scope" in $$props3)
      $$invalidate2(28, $$scope2 = $$props3.$$scope);
  };
  $$self2.$capture_state = () => ({
    findOrCreateStore,
    afterUpdate,
    EdgeAnchor: EdgeAnchor_default,
    DeleteAnchor: DeleteAnchor_default,
    node,
    key: key2,
    customCssText,
    nodeWidth,
    nodeHeight,
    onNodeMove,
    onNodeClick,
    onTouchMove,
    getStyles,
    nodeSelected: nodeSelected2,
    nodeIdSelected,
    movementStore: movementStore2,
    snapgrid,
    snapResize,
    isLocked: isLocked2,
    nodeEditStore,
    deleteNodes,
    moving,
    moved,
    label,
    showEditModal,
    shouldMove,
    $nodeIdSelected,
    $movementStore: $movementStore2,
    $isLocked,
    $snapgrid,
    $snapResize,
    $nodeSelected: $nodeSelected2,
    $nodeEditStore,
    $deleteNodes
  });
  $$self2.$inject_state = ($$props3) => {
    if ("node" in $$props3)
      $$invalidate2(0, node = $$props3.node);
    if ("key" in $$props3)
      $$invalidate2(1, key2 = $$props3.key);
    if ("customCssText" in $$props3)
      $$invalidate2(3, customCssText = $$props3.customCssText);
    if ("nodeWidth" in $$props3)
      $$invalidate2(4, nodeWidth = $$props3.nodeWidth);
    if ("nodeHeight" in $$props3)
      $$invalidate2(5, nodeHeight = $$props3.nodeHeight);
    if ("moving" in $$props3)
      $$invalidate2(2, moving = $$props3.moving);
    if ("moved" in $$props3)
      $$invalidate2(6, moved = $$props3.moved);
    if ("label" in $$props3)
      label = $$props3.label;
    if ("shouldMove" in $$props3)
      $$invalidate2(7, shouldMove = $$props3.shouldMove);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty[0] & /*moving, $movementStore*/
    134217732) {
      $:
        $$invalidate2(7, shouldMove = moving && $movementStore2);
    }
    if ($$self2.$$.dirty[0] & /*node*/
    1) {
      $:
        label = node.data.label;
    }
  };
  return [
    node,
    key2,
    moving,
    customCssText,
    nodeWidth,
    nodeHeight,
    moved,
    shouldMove,
    $nodeIdSelected,
    $isLocked,
    $snapgrid,
    $snapResize,
    $nodeSelected2,
    $nodeEditStore,
    $deleteNodes,
    onNodeMove,
    onNodeClick,
    onTouchMove,
    nodeSelected2,
    nodeIdSelected,
    movementStore2,
    snapgrid,
    snapResize,
    isLocked2,
    nodeEditStore,
    deleteNodes,
    showEditModal,
    $movementStore2,
    $$scope2,
    slots2,
    mousemove_handler,
    mouseup_handler,
    mouseup_handler_1,
    contextmenu_handler2,
    touchmove_handler,
    touchstart_handler,
    touchend_handler,
    mousedown_handler2
  ];
}
var Nodes = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { node: 0, key: 1 }, add_css7, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Nodes",
      options,
      id: create_fragment12.name
    });
  }
  get node() {
    throw new Error("<Nodes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value2) {
    throw new Error("<Nodes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get key() {
    throw new Error("<Nodes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value2) {
    throw new Error("<Nodes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Nodes_default = Nodes;

// node_modules/svelvet/Containers/Minimap/GreyNodeBoundary.svelte
var file9 = "node_modules/svelvet/Containers/Minimap/GreyNodeBoundary.svelte";
function add_css8(target) {
  append_styles(target, "svelte-14qfyer", ".nodes.svelte-14qfyer{position:absolute;background-color:black;color:black;opacity:20%;z-index:9;border-radius:.1rem}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JleU5vZGVCb3VuZGFyeS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBd0JBLHFCQUFNLENBQUEsQUFDRixTQUFTLFFBQVEsQ0FDakIsZ0JBQWdCLENBQUUsS0FBSyxDQUN2QixLQUFLLENBQUUsS0FBSyxDQUNaLE9BQU8sQ0FBRSxHQUFHLENBQ1osT0FBTyxDQUFFLENBQUMsQ0FDVixhQUFhLENBQUUsS0FBSyxBQUN4QixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkdyZXlOb2RlQm91bmRhcnkuc3ZlbHRlIl19 */");
}
function create_fragment13(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create2() {
      div = element("div");
      attr_dev(div, "class", div_class_value = "nodes nodes-" + /*key*/
      ctx[0] + " svelte-14qfyer");
      set_style(
        div,
        "top",
        /*top*/
        ctx[1] + "px"
      );
      set_style(
        div,
        "left",
        /*left*/
        ctx[2] + "px"
      );
      set_style(
        div,
        "height",
        /*nHeight*/
        ctx[4] + "px"
      );
      set_style(
        div,
        "width",
        /*nWidth*/
        ctx[3] + "px"
      );
      add_location(div, file9, 21, 0, 493);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*key*/
      1 && div_class_value !== (div_class_value = "nodes nodes-" + /*key*/
      ctx2[0] + " svelte-14qfyer")) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & /*top*/
      2) {
        set_style(
          div,
          "top",
          /*top*/
          ctx2[1] + "px"
        );
      }
      if (dirty & /*left*/
      4) {
        set_style(
          div,
          "left",
          /*left*/
          ctx2[2] + "px"
        );
      }
      if (dirty & /*nHeight*/
      16) {
        set_style(
          div,
          "height",
          /*nHeight*/
          ctx2[4] + "px"
        );
      }
      if (dirty & /*nWidth*/
      8) {
        set_style(
          div,
          "width",
          /*nWidth*/
          ctx2[3] + "px"
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self2, $$props2, $$invalidate2) {
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("GreyNodeBoundary", slots2, []);
  let { key: key2 } = $$props2;
  let { node } = $$props2;
  let { heightRatio } = $$props2;
  let { widthRatio } = $$props2;
  let top = 0;
  let left = 0;
  let nWidth = 0;
  let nHeight = 0;
  $$self2.$$.on_mount.push(function() {
    if (key2 === void 0 && !("key" in $$props2 || $$self2.$$.bound[$$self2.$$.props["key"]])) {
      console.warn("<GreyNodeBoundary> was created without expected prop 'key'");
    }
    if (node === void 0 && !("node" in $$props2 || $$self2.$$.bound[$$self2.$$.props["node"]])) {
      console.warn("<GreyNodeBoundary> was created without expected prop 'node'");
    }
    if (heightRatio === void 0 && !("heightRatio" in $$props2 || $$self2.$$.bound[$$self2.$$.props["heightRatio"]])) {
      console.warn("<GreyNodeBoundary> was created without expected prop 'heightRatio'");
    }
    if (widthRatio === void 0 && !("widthRatio" in $$props2 || $$self2.$$.bound[$$self2.$$.props["widthRatio"]])) {
      console.warn("<GreyNodeBoundary> was created without expected prop 'widthRatio'");
    }
  });
  const writable_props2 = ["key", "node", "heightRatio", "widthRatio"];
  Object.keys($$props2).forEach((key3) => {
    if (!~writable_props2.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<GreyNodeBoundary> was created with unknown prop '${key3}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(0, key2 = $$props3.key);
    if ("node" in $$props3)
      $$invalidate2(5, node = $$props3.node);
    if ("heightRatio" in $$props3)
      $$invalidate2(6, heightRatio = $$props3.heightRatio);
    if ("widthRatio" in $$props3)
      $$invalidate2(7, widthRatio = $$props3.widthRatio);
  };
  $$self2.$capture_state = () => ({
    key: key2,
    node,
    heightRatio,
    widthRatio,
    top,
    left,
    nWidth,
    nHeight
  });
  $$self2.$inject_state = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(0, key2 = $$props3.key);
    if ("node" in $$props3)
      $$invalidate2(5, node = $$props3.node);
    if ("heightRatio" in $$props3)
      $$invalidate2(6, heightRatio = $$props3.heightRatio);
    if ("widthRatio" in $$props3)
      $$invalidate2(7, widthRatio = $$props3.widthRatio);
    if ("top" in $$props3)
      $$invalidate2(1, top = $$props3.top);
    if ("left" in $$props3)
      $$invalidate2(2, left = $$props3.left);
    if ("nWidth" in $$props3)
      $$invalidate2(3, nWidth = $$props3.nWidth);
    if ("nHeight" in $$props3)
      $$invalidate2(4, nHeight = $$props3.nHeight);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*node, heightRatio, widthRatio*/
    224) {
      $: {
        $$invalidate2(4, nHeight = Math.max(node.height * heightRatio, 5));
        $$invalidate2(3, nWidth = Math.max(node.width * widthRatio, 5));
        $$invalidate2(1, top = node.position.y * heightRatio);
        $$invalidate2(2, left = node.position.x * widthRatio);
      }
    }
  };
  return [key2, top, left, nWidth, nHeight, node, heightRatio, widthRatio];
}
var GreyNodeBoundary = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance13,
      create_fragment13,
      safe_not_equal,
      {
        key: 0,
        node: 5,
        heightRatio: 6,
        widthRatio: 7
      },
      add_css8
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GreyNodeBoundary",
      options,
      id: create_fragment13.name
    });
  }
  get key() {
    throw new Error("<GreyNodeBoundary>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value2) {
    throw new Error("<GreyNodeBoundary>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get node() {
    throw new Error("<GreyNodeBoundary>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value2) {
    throw new Error("<GreyNodeBoundary>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get heightRatio() {
    throw new Error("<GreyNodeBoundary>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set heightRatio(value2) {
    throw new Error("<GreyNodeBoundary>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get widthRatio() {
    throw new Error("<GreyNodeBoundary>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set widthRatio(value2) {
    throw new Error("<GreyNodeBoundary>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GreyNodeBoundary_default = GreyNodeBoundary;

// node_modules/svelvet/Containers/Minimap/MinimapBoundary.svelte
var file10 = "node_modules/svelvet/Containers/Minimap/MinimapBoundary.svelte";
function add_css9(target) {
  append_styles(target, "svelte-enqdqj", ".miniMap.svelte-enqdqj{height:100px;width:100px;background-color:rgb(237, 236, 236);border:solid black;border-width:1px;border-radius:.5rem;color:rgb(142, 142, 142);position:absolute;bottom:15px;right:15px;z-index:10;box-shadow:2px 2px 7px rgb(77, 77, 77);overflow:hidden}.viewBox.svelte-enqdqj{background-color:rgb(120, 120, 120);border:solid red 1px;position:absolute}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWluaW1hcEJvdW5kYXJ5LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE4REksUUFBUSxjQUFDLENBQUEsQUFDTCxNQUFNLENBQUUsS0FBSyxDQUNiLEtBQUssQ0FBRSxLQUFLLENBQ1osZ0JBQWdCLENBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDcEMsTUFBTSxDQUFFLEtBQUssQ0FBQyxLQUFLLENBQ25CLFlBQVksQ0FBRSxHQUFHLENBQ2pCLGFBQWEsQ0FBRSxLQUFLLENBQ3BCLEtBQUssQ0FBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUN6QixRQUFRLENBQUUsUUFBUSxDQUNsQixNQUFNLENBQUUsSUFBSSxDQUNaLEtBQUssQ0FBRSxJQUFJLENBQ1gsUUFBUSxFQUFFLENBQ1YsVUFBVSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQ3ZDLFFBQVEsQ0FBRSxNQUFNLEFBQ3BCLENBQUEsQUFDQSxzQkFBUSxDQUFBLEFBQ0osZ0JBQWdCLENBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDcEMsTUFBTSxDQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUNyQixRQUFRLENBQUUsUUFBUSxBQUN0QixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIk1pbmltYXBCb3VuZGFyeS5zdmVsdGUiXX0= */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function create_each_block2(ctx) {
  let greynode;
  let current;
  greynode = new GreyNodeBoundary_default({
    props: {
      node: (
        /*node*/
        ctx[21]
      ),
      key: (
        /*key*/
        ctx[0]
      ),
      heightRatio: (
        /*heightRatio*/
        ctx[5]
      ),
      widthRatio: (
        /*widthRatio*/
        ctx[4]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(greynode.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(greynode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const greynode_changes = {};
      if (dirty & /*$nodesStore*/
      2048)
        greynode_changes.node = /*node*/
        ctx2[21];
      if (dirty & /*key*/
      1)
        greynode_changes.key = /*key*/
        ctx2[0];
      if (dirty & /*heightRatio*/
      32)
        greynode_changes.heightRatio = /*heightRatio*/
        ctx2[5];
      if (dirty & /*widthRatio*/
      16)
        greynode_changes.widthRatio = /*widthRatio*/
        ctx2[4];
      greynode.$set(greynode_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(greynode.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(greynode.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(greynode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(58:8) {#each $nodesStore as node}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let t;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*$nodesStore*/
    ctx[11]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create2() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div0, "class", div0_class_value = "viewBox viewBox-" + /*key*/
      ctx[0] + " svelte-enqdqj");
      set_style(
        div0,
        "height",
        /*$heightStore*/
        ctx[9] * /*heightRatio*/
        ctx[5] / /*d3Translate*/
        ctx[1].k + "px"
      );
      set_style(
        div0,
        "width",
        /*$widthStore*/
        ctx[10] * /*widthRatio*/
        ctx[4] / /*d3Translate*/
        ctx[1].k + "px"
      );
      set_style(
        div0,
        "top",
        /*viewBottom*/
        ctx[7] + "px"
      );
      set_style(
        div0,
        "left",
        /*viewRight*/
        ctx[6] + "px"
      );
      add_location(div0, file10, 56, 8, 1877);
      attr_dev(div1, "class", div1_class_value = null_to_empty(`miniMap miniMap-${/*key*/
      ctx[0]}`) + " svelte-enqdqj");
      set_style(
        div1,
        "height",
        /*mapHeight*/
        ctx[2] + 2 + "px"
      );
      set_style(
        div1,
        "width",
        /*mapWidth*/
        ctx[3] + 2 + "px"
      );
      add_location(div1, file10, 55, 4, 1709);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div1, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      ctx[17](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*handleClick*/
            ctx[15],
            false,
            false,
            false
          ),
          listen_dev(div1, "keydown", keydown_handler5, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*key*/
      1 && div0_class_value !== (div0_class_value = "viewBox viewBox-" + /*key*/
      ctx2[0] + " svelte-enqdqj")) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*$heightStore, heightRatio, d3Translate*/
      546) {
        set_style(
          div0,
          "height",
          /*$heightStore*/
          ctx2[9] * /*heightRatio*/
          ctx2[5] / /*d3Translate*/
          ctx2[1].k + "px"
        );
      }
      if (!current || dirty & /*$widthStore, widthRatio, d3Translate*/
      1042) {
        set_style(
          div0,
          "width",
          /*$widthStore*/
          ctx2[10] * /*widthRatio*/
          ctx2[4] / /*d3Translate*/
          ctx2[1].k + "px"
        );
      }
      if (!current || dirty & /*viewBottom*/
      128) {
        set_style(
          div0,
          "top",
          /*viewBottom*/
          ctx2[7] + "px"
        );
      }
      if (!current || dirty & /*viewRight*/
      64) {
        set_style(
          div0,
          "left",
          /*viewRight*/
          ctx2[6] + "px"
        );
      }
      if (dirty & /*$nodesStore, key, heightRatio, widthRatio*/
      2097) {
        each_value = /*$nodesStore*/
        ctx2[11];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*key*/
      1 && div1_class_value !== (div1_class_value = null_to_empty(`miniMap miniMap-${/*key*/
      ctx2[0]}`) + " svelte-enqdqj")) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*mapHeight*/
      4) {
        set_style(
          div1,
          "height",
          /*mapHeight*/
          ctx2[2] + 2 + "px"
        );
      }
      if (!current || dirty & /*mapWidth*/
      8) {
        set_style(
          div1,
          "width",
          /*mapWidth*/
          ctx2[3] + 2 + "px"
        );
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local2) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_each(each_blocks, detaching);
      ctx[17](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var keydown_handler5 = () => {
  return;
};
function instance14($$self2, $$props2, $$invalidate2) {
  let $heightStore2;
  let $widthStore2;
  let $nodesStore2;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("MinimapBoundary", slots2, []);
  let { key: key2 } = $$props2;
  let { boundary: boundary2 } = $$props2;
  let { d3Translate: d3Translate2 } = $$props2;
  const svelvetStore2 = findOrCreateStore(key2);
  const { nodesStore: nodesStore2, heightStore: heightStore2, widthStore: widthStore2 } = svelvetStore2;
  validate_store(nodesStore2, "nodesStore");
  component_subscribe($$self2, nodesStore2, (value2) => $$invalidate2(11, $nodesStore2 = value2));
  validate_store(heightStore2, "heightStore");
  component_subscribe($$self2, heightStore2, (value2) => $$invalidate2(9, $heightStore2 = value2));
  validate_store(widthStore2, "widthStore");
  component_subscribe($$self2, widthStore2, (value2) => $$invalidate2(10, $widthStore2 = value2));
  const dispatch2 = createEventDispatcher();
  let mapHeight = 100;
  let mapWidth = 100;
  let widthRatio = 1;
  let heightRatio = 1;
  let viewRight = 1;
  let viewBottom = 1;
  let map;
  let hasBeenClicked = false;
  function handleClick(event) {
    if (!hasBeenClicked) {
      hasBeenClicked = true;
      let bounds = map.getBoundingClientRect();
      dispatch2("message", {
        x: (event.clientX - bounds.left) / widthRatio,
        y: (event.clientY - bounds.top) / heightRatio
      });
      setTimeout(
        () => {
          hasBeenClicked = false;
        },
        500
      );
    }
  }
  $$self2.$$.on_mount.push(function() {
    if (key2 === void 0 && !("key" in $$props2 || $$self2.$$.bound[$$self2.$$.props["key"]])) {
      console.warn("<MinimapBoundary> was created without expected prop 'key'");
    }
    if (boundary2 === void 0 && !("boundary" in $$props2 || $$self2.$$.bound[$$self2.$$.props["boundary"]])) {
      console.warn("<MinimapBoundary> was created without expected prop 'boundary'");
    }
    if (d3Translate2 === void 0 && !("d3Translate" in $$props2 || $$self2.$$.bound[$$self2.$$.props["d3Translate"]])) {
      console.warn("<MinimapBoundary> was created without expected prop 'd3Translate'");
    }
  });
  const writable_props2 = ["key", "boundary", "d3Translate"];
  Object.keys($$props2).forEach((key3) => {
    if (!~writable_props2.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<MinimapBoundary> was created with unknown prop '${key3}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      map = $$value;
      $$invalidate2(8, map);
    });
  }
  $$self2.$$set = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(0, key2 = $$props3.key);
    if ("boundary" in $$props3)
      $$invalidate2(16, boundary2 = $$props3.boundary);
    if ("d3Translate" in $$props3)
      $$invalidate2(1, d3Translate2 = $$props3.d3Translate);
  };
  $$self2.$capture_state = () => ({
    findOrCreateStore,
    onMount,
    createEventDispatcher,
    GreyNode: GreyNodeBoundary_default,
    key: key2,
    boundary: boundary2,
    d3Translate: d3Translate2,
    svelvetStore: svelvetStore2,
    nodesStore: nodesStore2,
    heightStore: heightStore2,
    widthStore: widthStore2,
    dispatch: dispatch2,
    mapHeight,
    mapWidth,
    widthRatio,
    heightRatio,
    viewRight,
    viewBottom,
    map,
    hasBeenClicked,
    handleClick,
    $heightStore: $heightStore2,
    $widthStore: $widthStore2,
    $nodesStore: $nodesStore2
  });
  $$self2.$inject_state = ($$props3) => {
    if ("key" in $$props3)
      $$invalidate2(0, key2 = $$props3.key);
    if ("boundary" in $$props3)
      $$invalidate2(16, boundary2 = $$props3.boundary);
    if ("d3Translate" in $$props3)
      $$invalidate2(1, d3Translate2 = $$props3.d3Translate);
    if ("mapHeight" in $$props3)
      $$invalidate2(2, mapHeight = $$props3.mapHeight);
    if ("mapWidth" in $$props3)
      $$invalidate2(3, mapWidth = $$props3.mapWidth);
    if ("widthRatio" in $$props3)
      $$invalidate2(4, widthRatio = $$props3.widthRatio);
    if ("heightRatio" in $$props3)
      $$invalidate2(5, heightRatio = $$props3.heightRatio);
    if ("viewRight" in $$props3)
      $$invalidate2(6, viewRight = $$props3.viewRight);
    if ("viewBottom" in $$props3)
      $$invalidate2(7, viewBottom = $$props3.viewBottom);
    if ("map" in $$props3)
      $$invalidate2(8, map = $$props3.map);
    if ("hasBeenClicked" in $$props3)
      hasBeenClicked = $$props3.hasBeenClicked;
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  $$self2.$$.update = () => {
    if ($$self2.$$.dirty & /*boundary, mapWidth, mapHeight, d3Translate, widthRatio, heightRatio*/
    65598) {
      $: {
        if (boundary2.y > boundary2.x) {
          $$invalidate2(2, mapHeight = 100);
          $$invalidate2(3, mapWidth = Math.max(boundary2.x.toFixed(0) * 100 / boundary2.y.toFixed(0), 25));
        } else if (boundary2.y < boundary2.x) {
          $$invalidate2(3, mapWidth = 100);
          $$invalidate2(2, mapHeight = Math.max(boundary2.y.toFixed(0) * 100 / boundary2.x.toFixed(0), 25));
        } else {
          $$invalidate2(2, mapHeight = 100);
          $$invalidate2(3, mapWidth = 100);
        }
        $$invalidate2(4, widthRatio = mapWidth / boundary2.x);
        $$invalidate2(5, heightRatio = mapHeight / boundary2.y);
        $$invalidate2(6, viewRight = Math.abs(d3Translate2.x * widthRatio / d3Translate2.k));
        $$invalidate2(7, viewBottom = Math.abs(d3Translate2.y * heightRatio / d3Translate2.k));
      }
    }
  };
  return [
    key2,
    d3Translate2,
    mapHeight,
    mapWidth,
    widthRatio,
    heightRatio,
    viewRight,
    viewBottom,
    map,
    $heightStore2,
    $widthStore2,
    $nodesStore2,
    nodesStore2,
    heightStore2,
    widthStore2,
    handleClick,
    boundary2,
    div1_binding
  ];
}
var MinimapBoundary = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { key: 0, boundary: 16, d3Translate: 1 }, add_css9);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MinimapBoundary",
      options,
      id: create_fragment14.name
    });
  }
  get key() {
    throw new Error("<MinimapBoundary>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value2) {
    throw new Error("<MinimapBoundary>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get boundary() {
    throw new Error("<MinimapBoundary>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set boundary(value2) {
    throw new Error("<MinimapBoundary>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get d3Translate() {
    throw new Error("<MinimapBoundary>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set d3Translate(value2) {
    throw new Error("<MinimapBoundary>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MinimapBoundary_default = MinimapBoundary;

// node_modules/svelvet/Containers/GraphView/index.svelte
var file11 = "node_modules/svelvet/Containers/GraphView/index.svelte";
function add_css10(target) {
  append_styles(target, "svelte-1lntfah", "#graphview-container.svelte-1lntfah{display:flex;align-items:center;justify-content:center}.Nodes.svelte-1lntfah{position:absolute;width:100%;height:100%;cursor:grab}.Nodes.svelte-1lntfah:active{cursor:grabbing}#dwnldimg.svelte-1lntfah{width:1.5rem;margin-right:0.1rem}#store-input.svelte-1lntfah,#store-input-btn.svelte-1lntfah{height:1.5rem;border-radius:.3rem;font-size:.7rem;margin:2px}#store-input-btn.svelte-1lntfah:hover{cursor:pointer;background-color:#FF4742;color:white;box-shadow:1px 1px 3px 1px rgba(0, 0, 0, 0.2)}#export-import.svelte-1lntfah{position:absolute;left:10px;bottom:10px;display:flex;align-items:center;justify-content:flex-start}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTJTRSxvQkFBb0IsZUFBQyxDQUFBLEFBQ25CLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsZUFBZSxDQUFFLE1BQU0sQUFDekIsQ0FBQSxBQUVBLE1BQU0sZUFBQyxDQUFBLEFBQ0wsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLE1BQU0sQ0FBRSxJQUFJLEFBRWQsQ0FBQyxBQUVELHFCQUFNLE9BQU8sQUFBQyxDQUFBLEFBQ1osTUFBTSxDQUFFLFFBQVEsQUFDbEIsQ0FBQSxBQUVBLFNBQVMsZUFBQyxDQUFBLEFBQ1IsS0FBSyxDQUFFLE1BQU0sQ0FDYixZQUFZLENBQUUsTUFBTSxBQUN0QixDQUFBLEFBRUEsMkJBQVksQ0FBRSxnQkFBZ0IsZUFBQyxDQUFBLEFBQzdCLE1BQU0sQ0FBRSxNQUFNLENBQ2QsYUFBYSxDQUFFLEtBQUssQ0FDcEIsU0FBUyxDQUFFLEtBQUssQ0FDaEIsTUFBTSxDQUFFLEdBQUcsQUFDYixDQUFBLEFBRUEsK0JBQWdCLE1BQU0sQUFBQyxDQUFBLEFBQ3JCLE1BQU0sQ0FBRSxPQUFPLENBQ2YsZ0JBQWdCLENBQUUsT0FBTyxDQUN6QixLQUFLLENBQUUsS0FBSyxDQUNaLFVBQVUsQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQUFDaEQsQ0FBQSxBQUVBLGNBQWMsZUFBQyxDQUFBLEFBQ2IsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsSUFBSSxDQUFFLElBQUksQ0FDVixNQUFNLENBQUUsSUFBSSxDQUNaLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsZUFBZSxDQUFFLFVBQVUsQUFDN0IsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJpbmRleC5zdmVsdGUiXX0= */");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[40] = list[i];
  return child_ctx;
}
function create_if_block_8(ctx) {
  let minimapboundless;
  let current;
  minimapboundless = new MinimapBoundless_default({
    props: {
      key: (
        /*key*/
        ctx[2]
      ),
      d3Translate: (
        /*d3Translate*/
        ctx[5]
      )
    },
    $$inline: true
  });
  minimapboundless.$on(
    "message",
    /*miniMapClick*/
    ctx[18]
  );
  const block = {
    c: function create2() {
      create_component(minimapboundless.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(minimapboundless, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const minimapboundless_changes = {};
      if (dirty[0] & /*key*/
      4)
        minimapboundless_changes.key = /*key*/
        ctx2[2];
      if (dirty[0] & /*d3Translate*/
      32)
        minimapboundless_changes.d3Translate = /*d3Translate*/
        ctx2[5];
      minimapboundless.$set(minimapboundless_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(minimapboundless.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(minimapboundless.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(minimapboundless, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(224:21) ",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let minimapboundary;
  let current;
  minimapboundary = new MinimapBoundary_default({
    props: {
      key: (
        /*key*/
        ctx[2]
      ),
      boundary: (
        /*boundary*/
        ctx[4]
      ),
      d3Translate: (
        /*d3Translate*/
        ctx[5]
      )
    },
    $$inline: true
  });
  minimapboundary.$on(
    "message",
    /*miniMapClick*/
    ctx[18]
  );
  const block = {
    c: function create2() {
      create_component(minimapboundary.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(minimapboundary, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const minimapboundary_changes = {};
      if (dirty[0] & /*key*/
      4)
        minimapboundary_changes.key = /*key*/
        ctx2[2];
      if (dirty[0] & /*boundary*/
      16)
        minimapboundary_changes.boundary = /*boundary*/
        ctx2[4];
      if (dirty[0] & /*d3Translate*/
      32)
        minimapboundary_changes.d3Translate = /*d3Translate*/
        ctx2[5];
      minimapboundary.$set(minimapboundary_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(minimapboundary.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(minimapboundary.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(minimapboundary, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(222:2) {#if minimap && boundary}",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let node;
  let current;
  node = new Nodes_default({
    props: {
      node: (
        /*node*/
        ctx[40]
      ),
      key: (
        /*key*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(node.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(node, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const node_changes = {};
      if (dirty[0] & /*$nodesStore*/
      256)
        node_changes.node = /*node*/
        ctx2[40];
      if (dirty[0] & /*key*/
      4)
        node_changes.key = /*key*/
        ctx2[2];
      if (dirty[0] & /*$nodesStore*/
      256 | dirty[1] & /*$$scope*/
      4096) {
        node_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node.$set(node_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(node.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(node.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(node, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(239:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let node;
  let current;
  node = new Nodes_default({
    props: {
      node: (
        /*node*/
        ctx[40]
      ),
      key: (
        /*key*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(node.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(node, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const node_changes = {};
      if (dirty[0] & /*$nodesStore*/
      256)
        node_changes.node = /*node*/
        ctx2[40];
      if (dirty[0] & /*key*/
      4)
        node_changes.key = /*key*/
        ctx2[2];
      if (dirty[0] & /*$nodesStore*/
      256 | dirty[1] & /*$$scope*/
      4096) {
        node_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node.$set(node_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(node.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(node.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(node, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(236:35) ",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let node;
  let t;
  let current;
  node = new Nodes_default({
    props: {
      node: (
        /*node*/
        ctx[40]
      ),
      key: (
        /*key*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(node.$$.fragment);
      t = space();
    },
    m: function mount(target, anchor) {
      mount_component(node, target, anchor);
      insert_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const node_changes = {};
      if (dirty[0] & /*$nodesStore*/
      256)
        node_changes.node = /*node*/
        ctx2[40];
      if (dirty[0] & /*key*/
      4)
        node_changes.key = /*key*/
        ctx2[2];
      if (dirty[0] & /*$nodesStore*/
      256 | dirty[1] & /*$$scope*/
      4096) {
        node_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node.$set(node_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(node.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(node.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(node, detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(233:8) {#if node.data.html}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let t_value = (
    /*node*/
    ctx[40].data.label + ""
  );
  let t;
  const block = {
    c: function create2() {
      t = text2(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$nodesStore*/
      256 && t_value !== (t_value = /*node*/
      ctx2[40].data.label + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(240:10) <Node {node} {key} >",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let switch_instance;
  let t;
  let current;
  var switch_value = (
    /*node*/
    ctx[40].data.custom
  );
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create2() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = /*node*/
      ctx2[40].data.custom)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t.parentNode, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(238:10) <Node {node} {key} >",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let html_tag;
  let raw_value = (
    /*node*/
    ctx[40].data.html + ""
  );
  let html_anchor;
  const block = {
    c: function create2() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$nodesStore*/
      256 && raw_value !== (raw_value = /*node*/
      ctx2[40].data.html + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(234:10) <Node {node} {key} >",
    ctx
  });
  return block;
}
function create_each_block_1(key_2, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5, create_if_block_6, create_else_block_1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (/*node*/
    ctx2[40].data.html)
      return 0;
    if (/*node*/
    ctx2[40].data.custom)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    key: key_2,
    first: null,
    c: function create2() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(231:6) {#each $nodesStore as node (node.id)}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let rect;
  const block = {
    c: function create2() {
      rect = svg_element("rect");
      attr_dev(rect, "width", "100%");
      attr_dev(rect, "height", "100%");
      set_style(rect, "fill", "url(#background-" + /*key*/
      ctx[2] + ")");
      add_location(rect, file11, 267, 6, 9929);
    },
    m: function mount(target, anchor) {
      insert_dev(target, rect, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*key*/
      4) {
        set_style(rect, "fill", "url(#background-" + /*key*/
        ctx2[2] + ")");
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(rect);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(267:4) {#if $backgroundStore}",
    ctx
  });
  return block;
}
function create_else_block5(ctx) {
  let simplebezieredge;
  let current;
  simplebezieredge = new SimpleBezierEdge_default({
    props: { edge: (
      /*edge*/
      ctx[37]
    ) },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(simplebezieredge.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(simplebezieredge, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const simplebezieredge_changes = {};
      if (dirty[0] & /*$derivedEdges*/
      128)
        simplebezieredge_changes.edge = /*edge*/
        ctx2[37];
      simplebezieredge.$set(simplebezieredge_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(simplebezieredge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(simplebezieredge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(simplebezieredge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(280:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let stepedge;
  let current;
  stepedge = new StepEdge_default({
    props: { edge: (
      /*edge*/
      ctx[37]
    ) },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(stepedge.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(stepedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const stepedge_changes = {};
      if (dirty[0] & /*$derivedEdges*/
      128)
        stepedge_changes.edge = /*edge*/
        ctx2[37];
      stepedge.$set(stepedge_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(stepedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(stepedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(stepedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(278:39) ",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let smoothstepedge;
  let current;
  smoothstepedge = new SmoothStepEdge_default({
    props: { edge: (
      /*edge*/
      ctx[37]
    ) },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(smoothstepedge.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(smoothstepedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const smoothstepedge_changes = {};
      if (dirty[0] & /*$derivedEdges*/
      128)
        smoothstepedge_changes.edge = /*edge*/
        ctx2[37];
      smoothstepedge.$set(smoothstepedge_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(smoothstepedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(smoothstepedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(smoothstepedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(276:45) ",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let straightedge;
  let current;
  straightedge = new StraightEdge_default({
    props: { edge: (
      /*edge*/
      ctx[37]
    ) },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(straightedge.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(straightedge, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const straightedge_changes = {};
      if (dirty[0] & /*$derivedEdges*/
      128)
        straightedge_changes.edge = /*edge*/
        ctx2[37];
      straightedge.$set(straightedge_changes);
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(straightedge.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(straightedge.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(straightedge, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(274:8) {#if edge.type === 'straight'}",
    ctx
  });
  return block;
}
function create_each_block3(key_2, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_13, create_if_block_22, create_if_block_3, create_else_block5];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (/*edge*/
    ctx2[37].type === "straight")
      return 0;
    if (/*edge*/
    ctx2[37].type === "smoothstep")
      return 1;
    if (/*edge*/
    ctx2[37].type === "step")
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    key: key_2,
    first: null,
    c: function create2() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(273:6) {#each $derivedEdges as edge (edge.id)}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let div;
  let a;
  let svg;
  let g0;
  let g2;
  let path0;
  let g1;
  let polygon;
  let path1;
  let a_id_value;
  let t02;
  let input;
  let t12;
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create2() {
      div = element("div");
      a = element("a");
      svg = svg_element("svg");
      g0 = svg_element("g");
      g2 = svg_element("g");
      path0 = svg_element("path");
      g1 = svg_element("g");
      polygon = svg_element("polygon");
      path1 = svg_element("path");
      t02 = space();
      input = element("input");
      t12 = space();
      button = element("button");
      button.textContent = "Upload";
      attr_dev(g0, "id", "SVGRepo_bgCarrier");
      attr_dev(g0, "stroke-width", "0");
      add_location(g0, file11, 289, 151, 10751);
      attr_dev(path0, "d", "M0 0h48v48H0z");
      attr_dev(path0, "fill", "none");
      add_location(path0, file11, 289, 227, 10827);
      attr_dev(polygon, "points", "22,4 22,20 14,20 24,30 34,20 26,20 26,4 ");
      add_location(polygon, file11, 289, 289, 10889);
      attr_dev(path1, "d", "M8,44h32c2.206,0,4-1.794,4-4V30h-4v10H8V30H4v10C4,42.206,5.794,44,8,44z");
      add_location(path1, file11, 289, 359, 10959);
      attr_dev(g1, "id", "Shopicon");
      add_location(g1, file11, 289, 271, 10871);
      attr_dev(g2, "id", "SVGRepo_iconCarrier");
      add_location(g2, file11, 289, 198, 10798);
      attr_dev(svg, "id", "dwnldimg");
      attr_dev(svg, "viewBox", "0 0 48 48");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "fill", "#000000");
      attr_dev(svg, "class", "svelte-1lntfah");
      add_location(svg, file11, 289, 62, 10662);
      attr_dev(a, "id", a_id_value = "downloadState-" + /*key*/
      ctx[2]);
      attr_dev(a, "download", "svelvet-state.json");
      attr_dev(a, "class", "svelte-1lntfah");
      add_location(a, file11, 289, 4, 10604);
      attr_dev(input, "type", "text");
      attr_dev(input, "id", "store-input");
      attr_dev(input, "placeholder", "Paste JSON here");
      attr_dev(input, "class", "svelte-1lntfah");
      add_location(input, file11, 290, 4, 11073);
      attr_dev(button, "id", "store-input-btn");
      attr_dev(button, "class", "svelte-1lntfah");
      add_location(button, file11, 291, 4, 11144);
      attr_dev(div, "id", "export-import");
      attr_dev(div, "class", "svelte-1lntfah");
      add_location(div, file11, 288, 2, 10575);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, a);
      append_dev(a, svg);
      append_dev(svg, g0);
      append_dev(svg, g2);
      append_dev(g2, path0);
      append_dev(g2, g1);
      append_dev(g1, polygon);
      append_dev(g1, path1);
      append_dev(div, t02);
      append_dev(div, input);
      append_dev(div, t12);
      append_dev(div, button);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*uploadStore*/
          ctx[19],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*key*/
      4 && a_id_value !== (a_id_value = "downloadState-" + /*key*/
      ctx2[2])) {
        attr_dev(a, "id", a_id_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(287:2) {#if $shareable}",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let div2;
  let current_block_type_index;
  let if_block0;
  let t02;
  let editmodal;
  let t12;
  let div1;
  let div0;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let div0_class_value;
  let div1_class_value;
  let t22;
  let svg;
  let defs;
  let pattern;
  let circle;
  let circle_cx_value;
  let circle_cy_value;
  let pattern_id_value;
  let g;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let svg_class_value;
  let svg_viewBox_value;
  let t32;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_7, create_if_block_8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (/*minimap*/
    ctx2[3] && /*boundary*/
    ctx2[4])
      return 0;
    if (/*minimap*/
    ctx2[3])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  editmodal = new EditModal_default({
    props: { key: (
      /*key*/
      ctx[2]
    ) },
    $$inline: true
  });
  let each_value_1 = (
    /*$nodesStore*/
    ctx[8]
  );
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => /*node*/
  ctx2[40].id;
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key2 = get_key(child_ctx);
    each0_lookup.set(key2, each_blocks_1[i] = create_each_block_1(key2, child_ctx));
  }
  let if_block1 = (
    /*$backgroundStore*/
    ctx[9] && create_if_block_4(ctx)
  );
  let each_value = (
    /*$derivedEdges*/
    ctx[7]
  );
  validate_each_argument(each_value);
  const get_key_1 = (ctx2) => /*edge*/
  ctx2[37].id;
  validate_each_keys(ctx, each_value, get_each_context3, get_key_1);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key2 = get_key_1(child_ctx);
    each1_lookup.set(key2, each_blocks[i] = create_each_block3(key2, child_ctx));
  }
  let if_block2 = (
    /*$shareable*/
    ctx[6] && create_if_block6(ctx)
  );
  const block = {
    c: function create2() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t02 = space();
      create_component(editmodal.$$.fragment);
      t12 = space();
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t22 = space();
      svg = svg_element("svg");
      defs = svg_element("defs");
      pattern = svg_element("pattern");
      circle = svg_element("circle");
      if (if_block1)
        if_block1.c();
      g = svg_element("g");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t32 = space();
      if (if_block2)
        if_block2.c();
      attr_dev(div0, "class", div0_class_value = null_to_empty(`Node Node-${/*key*/
      ctx[2]}`) + " svelte-1lntfah");
      add_location(div0, file11, 229, 4, 8817);
      attr_dev(div1, "class", div1_class_value = null_to_empty(`Nodes Nodes-${/*key*/
      ctx[2]}`) + " svelte-1lntfah");
      add_location(div1, file11, 227, 2, 8641);
      attr_dev(circle, "id", "dot");
      attr_dev(circle, "cx", circle_cx_value = gridSize / 2 - dotSize / 2);
      attr_dev(circle, "cy", circle_cy_value = gridSize / 2 - dotSize / 2);
      attr_dev(circle, "r", "0.5");
      set_style(circle, "fill", "gray");
      add_location(circle, file11, 256, 8, 9697);
      attr_dev(pattern, "id", pattern_id_value = `background-${/*key*/
      ctx[2]}`);
      attr_dev(pattern, "x", "0");
      attr_dev(pattern, "y", "0");
      attr_dev(pattern, "width", gridSize);
      attr_dev(pattern, "height", gridSize);
      attr_dev(pattern, "patternUnits", "userSpaceOnUse");
      attr_dev(pattern, "class", "svelte-1lntfah");
      add_location(pattern, file11, 248, 6, 9522);
      add_location(defs, file11, 247, 4, 9509);
      add_location(g, file11, 271, 4, 10112);
      attr_dev(svg, "class", svg_class_value = null_to_empty(`Edges Edges-${/*key*/
      ctx[2]}`) + " svelte-1lntfah");
      attr_dev(svg, "viewBox", svg_viewBox_value = "0 0 " + /*$widthStore*/
      ctx[10] + " " + /*$heightStore*/
      ctx[11]);
      add_location(svg, file11, 246, 2, 9426);
      attr_dev(div2, "id", "graphview-container");
      attr_dev(div2, "class", "svelte-1lntfah");
      add_location(div2, file11, 219, 0, 8247);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      append_dev(div2, t02);
      mount_component(editmodal, div2, null);
      append_dev(div2, t12);
      append_dev(div2, div1);
      append_dev(div1, div0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(div0, null);
      }
      append_dev(div2, t22);
      append_dev(div2, svg);
      append_dev(svg, defs);
      append_dev(defs, pattern);
      append_dev(pattern, circle);
      if (if_block1)
        if_block1.m(svg, null);
      append_dev(svg, g);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(g, null);
      }
      append_dev(div2, t32);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div1, "contextmenu", prevent_default(
            /*contextmenu_handler*/
            ctx[25]
          ), false, true, false),
          listen_dev(
            div1,
            "click",
            /*closeEditModal*/
            ctx[20],
            false,
            false,
            false
          ),
          listen_dev(div1, "keydown", keydown_handler6, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div2, t02);
        } else {
          if_block0 = null;
        }
      }
      const editmodal_changes = {};
      if (dirty[0] & /*key*/
      4)
        editmodal_changes.key = /*key*/
        ctx2[2];
      editmodal.$set(editmodal_changes);
      if (dirty[0] & /*$nodesStore, key*/
      260) {
        each_value_1 = /*$nodesStore*/
        ctx2[8];
        validate_each_argument(each_value_1);
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_1, each0_lookup, div0, outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
        check_outros();
      }
      if (!current || dirty[0] & /*key*/
      4 && div0_class_value !== (div0_class_value = null_to_empty(`Node Node-${/*key*/
      ctx2[2]}`) + " svelte-1lntfah")) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*key*/
      4 && div1_class_value !== (div1_class_value = null_to_empty(`Nodes Nodes-${/*key*/
      ctx2[2]}`) + " svelte-1lntfah")) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*key*/
      4 && pattern_id_value !== (pattern_id_value = `background-${/*key*/
      ctx2[2]}`)) {
        attr_dev(pattern, "id", pattern_id_value);
      }
      if (/*$backgroundStore*/
      ctx2[9]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          if_block1.m(svg, g);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*$derivedEdges*/
      128) {
        each_value = /*$derivedEdges*/
        ctx2[7];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context3, get_key_1);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value, each1_lookup, g, outro_and_destroy_block, create_each_block3, null, get_each_context3);
        check_outros();
      }
      if (!current || dirty[0] & /*key*/
      4 && svg_class_value !== (svg_class_value = null_to_empty(`Edges Edges-${/*key*/
      ctx2[2]}`) + " svelte-1lntfah")) {
        attr_dev(svg, "class", svg_class_value);
      }
      if (!current || dirty[0] & /*$widthStore, $heightStore*/
      3072 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*$widthStore*/
      ctx2[10] + " " + /*$heightStore*/
      ctx2[11])) {
        attr_dev(svg, "viewBox", svg_viewBox_value);
      }
      if (/*$shareable*/
      ctx2[6]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block6(ctx2);
          if_block2.c();
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(editmodal.$$.fragment, local2);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local2) {
      transition_out(if_block0);
      transition_out(editmodal.$$.fragment, local2);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      destroy_component(editmodal);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      if (if_block1)
        if_block1.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var gridSize = 15;
var dotSize = 10;
var keydown_handler6 = () => {
  return;
};
function instance15($$self, $$props, $$invalidate) {
  let $shareable;
  let $derivedEdges, $$unsubscribe_derivedEdges = noop, $$subscribe_derivedEdges = () => ($$unsubscribe_derivedEdges(), $$unsubscribe_derivedEdges = subscribe(derivedEdges, ($$value) => $$invalidate(7, $derivedEdges = $$value)), derivedEdges);
  let $nodesStore, $$unsubscribe_nodesStore = noop, $$subscribe_nodesStore = () => ($$unsubscribe_nodesStore(), $$unsubscribe_nodesStore = subscribe(nodesStore, ($$value) => $$invalidate(8, $nodesStore = $$value)), nodesStore);
  let $backgroundStore;
  let $movementStore;
  let $nodeSelected;
  let $widthStore;
  let $heightStore;
  $$self.$$.on_destroy.push(() => $$unsubscribe_derivedEdges());
  $$self.$$.on_destroy.push(() => $$unsubscribe_nodesStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GraphView", slots, []);
  let d3 = {
    zoom: zoom_default2,
    zoomTransform: transform,
    zoomIdentity: identity2,
    select: select_default2,
    selectAll: selectAll_default2,
    pointer: pointer_default
  };
  let { nodesStore } = $$props;
  validate_store(nodesStore, "nodesStore");
  $$subscribe_nodesStore();
  let { derivedEdges } = $$props;
  validate_store(derivedEdges, "derivedEdges");
  $$subscribe_derivedEdges();
  let { key } = $$props;
  let { initialZoom } = $$props;
  let { initialLocation } = $$props;
  let { minimap } = $$props;
  let { width } = $$props;
  let { height } = $$props;
  let { boundary } = $$props;
  const svelvetStore = findOrCreateStore(key);
  const { nodeSelected, backgroundStore, movementStore, widthStore, heightStore, d3Scale, isLocked, shareable } = svelvetStore;
  validate_store(nodeSelected, "nodeSelected");
  component_subscribe($$self, nodeSelected, (value2) => $$invalidate(27, $nodeSelected = value2));
  validate_store(backgroundStore, "backgroundStore");
  component_subscribe($$self, backgroundStore, (value2) => $$invalidate(9, $backgroundStore = value2));
  validate_store(movementStore, "movementStore");
  component_subscribe($$self, movementStore, (value2) => $$invalidate(26, $movementStore = value2));
  validate_store(widthStore, "widthStore");
  component_subscribe($$self, widthStore, (value2) => $$invalidate(10, $widthStore = value2));
  validate_store(heightStore, "heightStore");
  component_subscribe($$self, heightStore, (value2) => $$invalidate(11, $heightStore = value2));
  validate_store(shareable, "shareable");
  component_subscribe($$self, shareable, (value2) => $$invalidate(6, $shareable = value2));
  let d3Translate = { x: 0, y: 0, k: 1 };
  function miniMapClick(event) {
    if (!boundary) {
      d3.select(`.Edges-${key}`).transition().duration(500).call(d3Zoom.translateTo, event.detail.x, event.detail.y);
      d3.select(`.Nodes-${key}`).transition().duration(500).call(d3Zoom.translateTo, event.detail.x, event.detail.y);
    } else {
      d3.select(`.Edges-${key}`).transition().duration(500).call(d3Zoom.translateTo, event.detail.x, event.detail.y);
      d3.select(`.Nodes-${key}`).transition().duration(500).call(d3Zoom.translateTo, event.detail.x, event.detail.y);
    }
  }
  function determineD3Instance() {
    if (boundary) {
      return d3.zoom().filter(() => !$nodeSelected).scaleExtent([0.4, 2]).translateExtent([[0, 0], [boundary.x, boundary.y]]).extent([[0, 0], [width, height]]).on("zoom", handleZoom);
    } else {
      return d3.zoom().filter(() => !$nodeSelected).scaleExtent([0.4, 2]).on("zoom", handleZoom);
    }
  }
  let d3Zoom = determineD3Instance();
  function zoomInit() {
    d3.select(`.Edges-${key}`).transition().duration(0).call(d3Zoom.translateTo, 0, 0).transition().duration(0).call(d3Zoom.translateTo, initialLocation.x, initialLocation.y).transition().duration(0).call(d3Zoom.scaleBy, Number.parseFloat(0.4 + 0.16 * initialZoom).toFixed(2));
    $$invalidate(5, d3Translate = d3.zoomIdentity.translate(initialLocation.x, initialLocation.y).scale(Number.parseFloat(0.4 + 0.16 * initialZoom).toFixed(2)));
    d3.select(`.Nodes-${key}`).transition().duration(0).call(d3Zoom.translateTo, 0, 0).transition().duration(0).call(d3Zoom.translateTo, initialLocation.x, initialLocation.y).transition().duration(0).call(d3Zoom.scaleBy, Number.parseFloat(0.4 + 0.16 * initialZoom).toFixed(2));
    d3Scale.set(d3.zoomTransform(d3.select(`.Nodes-${key}`)).k);
  }
  onMount(() => {
    d3.select(`.Edges-${key}`).call(d3Zoom);
    d3.select(`.Nodes-${key}`).call(d3Zoom);
    d3.select(`#background-${key}`).call(d3Zoom);
    d3.selectAll("#dot").call(d3Zoom);
    zoomInit();
  });
  const uploadStore = (e) => {
    const storeInput = document.getElementById("store-input");
    const reviver = (key, value) => {
      if (key === "custom")
        return eval(value);
      return value;
    };
    const text = storeInput.value;
    const newStore = JSON.parse(text, reviver);
    svelvetStore.nodesStore.set(newStore.nodes);
    svelvetStore.edgesStore.set(newStore.edges);
    storeInput.value = "";
  };
  function handleZoom(e2) {
    if (!$movementStore)
      return;
    d3Scale.set(e2.transform.k);
    if ($backgroundStore) {
      d3.select(`#background-${key}`).attr("x", e2.transform.x).attr("y", e2.transform.y).attr("width", gridSize * e2.transform.k).attr("height", gridSize * e2.transform.k).selectAll("#dot").attr("x", gridSize * e2.transform.k / 2 - dotSize / 2).attr("y", gridSize * e2.transform.k / 2 - dotSize / 2).attr("opacity", Math.min(e2.transform.k, 1));
    }
    d3.select(`.Edges-${key} g`).attr("transform", e2.transform);
    let transform2 = d3.zoomTransform(this);
    $$invalidate(5, d3Translate = transform2);
    d3.select(`.Node-${key}`).style("transform", "translate(" + transform2.x + "px," + transform2.y + "px) scale(" + transform2.k + ")").style("transform-origin", "0 0");
  }
  const closeEditModal = () => {
    const input = document.querySelector(`.edit-modal-${key}`);
    input.style.display = "none";
  };
  const setImportExport = () => {
    function replacer(key2, value2) {
      if (key2 === "custom") {
        const str = value2 + "";
        const arr = str.split(" ");
        return arr[1];
      }
      return value2;
    }
    const state = { nodes: $nodesStore, edges: $derivedEdges };
    const makeTextFile = (text3) => {
      const data = new Blob([text3], { type: "application/json" });
      const textFile = window.URL.createObjectURL(data);
      return textFile;
    };
    document.getElementById(`downloadState-${key}`).href = makeTextFile(JSON.stringify(state, replacer));
  };
  afterUpdate(() => {
    if ($shareable)
      setImportExport();
  });
  $$self.$$.on_mount.push(function() {
    if (nodesStore === void 0 && !("nodesStore" in $$props || $$self.$$.bound[$$self.$$.props["nodesStore"]])) {
      console.warn("<GraphView> was created without expected prop 'nodesStore'");
    }
    if (derivedEdges === void 0 && !("derivedEdges" in $$props || $$self.$$.bound[$$self.$$.props["derivedEdges"]])) {
      console.warn("<GraphView> was created without expected prop 'derivedEdges'");
    }
    if (key === void 0 && !("key" in $$props || $$self.$$.bound[$$self.$$.props["key"]])) {
      console.warn("<GraphView> was created without expected prop 'key'");
    }
    if (initialZoom === void 0 && !("initialZoom" in $$props || $$self.$$.bound[$$self.$$.props["initialZoom"]])) {
      console.warn("<GraphView> was created without expected prop 'initialZoom'");
    }
    if (initialLocation === void 0 && !("initialLocation" in $$props || $$self.$$.bound[$$self.$$.props["initialLocation"]])) {
      console.warn("<GraphView> was created without expected prop 'initialLocation'");
    }
    if (minimap === void 0 && !("minimap" in $$props || $$self.$$.bound[$$self.$$.props["minimap"]])) {
      console.warn("<GraphView> was created without expected prop 'minimap'");
    }
    if (width === void 0 && !("width" in $$props || $$self.$$.bound[$$self.$$.props["width"]])) {
      console.warn("<GraphView> was created without expected prop 'width'");
    }
    if (height === void 0 && !("height" in $$props || $$self.$$.bound[$$self.$$.props["height"]])) {
      console.warn("<GraphView> was created without expected prop 'height'");
    }
    if (boundary === void 0 && !("boundary" in $$props || $$self.$$.bound[$$self.$$.props["boundary"]])) {
      console.warn("<GraphView> was created without expected prop 'boundary'");
    }
  });
  const writable_props = [
    "nodesStore",
    "derivedEdges",
    "key",
    "initialZoom",
    "initialLocation",
    "minimap",
    "width",
    "height",
    "boundary"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<GraphView> was created with unknown prop '${key2}'`);
  });
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("nodesStore" in $$props2)
      $$subscribe_nodesStore($$invalidate(0, nodesStore = $$props2.nodesStore));
    if ("derivedEdges" in $$props2)
      $$subscribe_derivedEdges($$invalidate(1, derivedEdges = $$props2.derivedEdges));
    if ("key" in $$props2)
      $$invalidate(2, key = $$props2.key);
    if ("initialZoom" in $$props2)
      $$invalidate(21, initialZoom = $$props2.initialZoom);
    if ("initialLocation" in $$props2)
      $$invalidate(22, initialLocation = $$props2.initialLocation);
    if ("minimap" in $$props2)
      $$invalidate(3, minimap = $$props2.minimap);
    if ("width" in $$props2)
      $$invalidate(23, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(24, height = $$props2.height);
    if ("boundary" in $$props2)
      $$invalidate(4, boundary = $$props2.boundary);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    onMount,
    zoom: zoom_default2,
    zoomTransform: transform,
    zoomIdentity: identity2,
    select: select_default2,
    selectAll: selectAll_default2,
    pointer: pointer_default,
    local,
    SimpleBezierEdge: SimpleBezierEdge_default,
    StraightEdge: StraightEdge_default,
    SmoothStepEdge: SmoothStepEdge_default,
    StepEdge: StepEdge_default,
    EditModal: EditModal_default,
    MinimapBoundless: MinimapBoundless_default,
    Node: Nodes_default,
    findOrCreateStore,
    MinimapBoundary: MinimapBoundary_default,
    d3,
    nodesStore,
    derivedEdges,
    key,
    initialZoom,
    initialLocation,
    minimap,
    width,
    height,
    boundary,
    svelvetStore,
    nodeSelected,
    backgroundStore,
    movementStore,
    widthStore,
    heightStore,
    d3Scale,
    isLocked,
    shareable,
    gridSize,
    dotSize,
    d3Translate,
    miniMapClick,
    determineD3Instance,
    d3Zoom,
    zoomInit,
    uploadStore,
    handleZoom,
    closeEditModal,
    setImportExport,
    $shareable,
    $derivedEdges,
    $nodesStore,
    $backgroundStore,
    $movementStore,
    $nodeSelected,
    $widthStore,
    $heightStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("d3" in $$props2)
      d3 = $$props2.d3;
    if ("nodesStore" in $$props2)
      $$subscribe_nodesStore($$invalidate(0, nodesStore = $$props2.nodesStore));
    if ("derivedEdges" in $$props2)
      $$subscribe_derivedEdges($$invalidate(1, derivedEdges = $$props2.derivedEdges));
    if ("key" in $$props2)
      $$invalidate(2, key = $$props2.key);
    if ("initialZoom" in $$props2)
      $$invalidate(21, initialZoom = $$props2.initialZoom);
    if ("initialLocation" in $$props2)
      $$invalidate(22, initialLocation = $$props2.initialLocation);
    if ("minimap" in $$props2)
      $$invalidate(3, minimap = $$props2.minimap);
    if ("width" in $$props2)
      $$invalidate(23, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(24, height = $$props2.height);
    if ("boundary" in $$props2)
      $$invalidate(4, boundary = $$props2.boundary);
    if ("d3Translate" in $$props2)
      $$invalidate(5, d3Translate = $$props2.d3Translate);
    if ("d3Zoom" in $$props2)
      d3Zoom = $$props2.d3Zoom;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    nodesStore,
    derivedEdges,
    key,
    minimap,
    boundary,
    d3Translate,
    $shareable,
    $derivedEdges,
    $nodesStore,
    $backgroundStore,
    $widthStore,
    $heightStore,
    nodeSelected,
    backgroundStore,
    movementStore,
    widthStore,
    heightStore,
    shareable,
    miniMapClick,
    uploadStore,
    closeEditModal,
    initialZoom,
    initialLocation,
    width,
    height,
    contextmenu_handler
  ];
}
var GraphView = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance15,
      create_fragment15,
      safe_not_equal,
      {
        nodesStore: 0,
        derivedEdges: 1,
        key: 2,
        initialZoom: 21,
        initialLocation: 22,
        minimap: 3,
        width: 23,
        height: 24,
        boundary: 4
      },
      add_css10,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GraphView",
      options,
      id: create_fragment15.name
    });
  }
  get nodesStore() {
    throw new Error("<GraphView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodesStore(value2) {
    throw new Error("<GraphView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get derivedEdges() {
    throw new Error("<GraphView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set derivedEdges(value2) {
    throw new Error("<GraphView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get key() {
    throw new Error("<GraphView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value2) {
    throw new Error("<GraphView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialZoom() {
    throw new Error("<GraphView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialZoom(value2) {
    throw new Error("<GraphView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialLocation() {
    throw new Error("<GraphView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialLocation(value2) {
    throw new Error("<GraphView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minimap() {
    throw new Error("<GraphView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minimap(value2) {
    throw new Error("<GraphView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<GraphView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value2) {
    throw new Error("<GraphView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<GraphView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value2) {
    throw new Error("<GraphView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get boundary() {
    throw new Error("<GraphView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set boundary(value2) {
    throw new Error("<GraphView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GraphView_default = GraphView;

// node_modules/svelvet/Containers/Svelvet/index.svelte
var file12 = "node_modules/svelvet/Containers/Svelvet/index.svelte";
function add_css11(target) {
  append_styles(target, "svelte-tw9ly1", ".Svelvet.svelte-tw9ly1{position:relative;overflow:hidden;display:grid;font-family:'Segoe UI', sans-serif}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguc3ZlbHRlIiwibWFwcGluZ3MiOiJBQStERSxRQUFRLGNBQUMsQ0FBQSxBQUNQLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLFVBQVUsQ0FBQyxDQUFDLFVBQVUsQUFDckMsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJpbmRleC5zdmVsdGUiXX0= */");
}
function create_fragment16(ctx) {
  let div;
  let graphview;
  let div_style_value;
  let current;
  graphview = new GraphView_default({
    props: {
      nodesStore: (
        /*nodesStore*/
        ctx[12]
      ),
      boundary: (
        /*boundary*/
        ctx[5]
      ),
      width: (
        /*width*/
        ctx[0]
      ),
      height: (
        /*height*/
        ctx[1]
      ),
      minimap: (
        /*minimap*/
        ctx[4]
      ),
      derivedEdges: (
        /*derivedEdges*/
        ctx[13]
      ),
      key: (
        /*key*/
        ctx[9]
      ),
      initialLocation: (
        /*initialLocation*/
        ctx[2]
      ),
      initialZoom: (
        /*initialZoom*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      div = element("div");
      create_component(graphview.$$.fragment);
      attr_dev(div, "class", "Svelvet svelte-tw9ly1");
      attr_dev(div, "style", div_style_value = `width: ${/*$widthStore*/
      ctx[6]}px; height: ${/*$heightStore*/
      ctx[7]}px; background-color: ${/*$backgroundColor*/
      ctx[8]}`);
      add_location(div, file12, 58, 0, 2519);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(graphview, div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const graphview_changes = {};
      if (dirty & /*boundary*/
      32)
        graphview_changes.boundary = /*boundary*/
        ctx2[5];
      if (dirty & /*width*/
      1)
        graphview_changes.width = /*width*/
        ctx2[0];
      if (dirty & /*height*/
      2)
        graphview_changes.height = /*height*/
        ctx2[1];
      if (dirty & /*minimap*/
      16)
        graphview_changes.minimap = /*minimap*/
        ctx2[4];
      if (dirty & /*initialLocation*/
      4)
        graphview_changes.initialLocation = /*initialLocation*/
        ctx2[2];
      if (dirty & /*initialZoom*/
      8)
        graphview_changes.initialZoom = /*initialZoom*/
        ctx2[3];
      graphview.$set(graphview_changes);
      if (!current || dirty & /*$widthStore, $heightStore, $backgroundColor*/
      448 && div_style_value !== (div_style_value = `width: ${/*$widthStore*/
      ctx2[6]}px; height: ${/*$heightStore*/
      ctx2[7]}px; background-color: ${/*$backgroundColor*/
      ctx2[8]}`)) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local2) {
      if (current)
        return;
      transition_in(graphview.$$.fragment, local2);
      current = true;
    },
    o: function outro(local2) {
      transition_out(graphview.$$.fragment, local2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(graphview);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self2, $$props2, $$invalidate2) {
  let $widthStore2;
  let $heightStore2;
  let $backgroundColor;
  let { $$slots: slots2 = {}, $$scope: $$scope2 } = $$props2;
  validate_slots("Svelvet", slots2, []);
  let { nodes } = $$props2;
  let { edges } = $$props2;
  let { width: width2 = 600 } = $$props2;
  let { height: height2 = 600 } = $$props2;
  let { background = false } = $$props2;
  let { nodeLink = false } = $$props2;
  let { nodeCreate = false } = $$props2;
  let { nodeEdit = false } = $$props2;
  let { movement = true } = $$props2;
  let { snap = false } = $$props2;
  let { snapTo = 30 } = $$props2;
  let { bgColor = "#ffffff" } = $$props2;
  let { initialLocation: initialLocation2 = { x: 0, y: 0 } } = $$props2;
  let { initialZoom: initialZoom2 = 4 } = $$props2;
  let { minimap: minimap2 = false } = $$props2;
  let { locked = false } = $$props2;
  let { boundary: boundary2 = false } = $$props2;
  let { shareable: shareable2 = false } = $$props2;
  let { deleteNodes = false } = $$props2;
  const key2 = (Math.random() + 1).toString(36).substring(7);
  const svelvetStore2 = findOrCreateStore(key2);
  const { widthStore: widthStore2, heightStore: heightStore2, nodesStore: nodesStore2, derivedEdges: derivedEdges2, backgroundColor, isLocked: isLocked2 } = svelvetStore2;
  validate_store(widthStore2, "widthStore");
  component_subscribe($$self2, widthStore2, (value2) => $$invalidate2(6, $widthStore2 = value2));
  validate_store(heightStore2, "heightStore");
  component_subscribe($$self2, heightStore2, (value2) => $$invalidate2(7, $heightStore2 = value2));
  validate_store(backgroundColor, "backgroundColor");
  component_subscribe($$self2, backgroundColor, (value2) => $$invalidate2(8, $backgroundColor = value2));
  onMount(() => {
    svelvetStore2.nodesStore.set(nodes);
    svelvetStore2.edgesStore.set(edges);
    svelvetStore2.widthStore.set(width2);
    svelvetStore2.heightStore.set(height2);
    svelvetStore2.backgroundStore.set(background);
    svelvetStore2.movementStore.set(movement);
    svelvetStore2.snapgrid.set(snap);
    svelvetStore2.backgroundColor.set(bgColor);
    svelvetStore2.snapResize.set(snapTo);
    svelvetStore2.initZoom.set(initialZoom2);
    svelvetStore2.initLocation.set(initialLocation2);
    svelvetStore2.isLocked.set(locked);
    svelvetStore2.boundary.set(boundary2);
    svelvetStore2.nodeLinkStore.set(nodeLink);
    svelvetStore2.nodeCreateStore.set(nodeCreate);
    svelvetStore2.nodeEditStore.set(nodeEdit);
    svelvetStore2.shareable.set(shareable2);
    svelvetStore2.deleteNodes.set(deleteNodes);
  });
  $$self2.$$.on_mount.push(function() {
    if (nodes === void 0 && !("nodes" in $$props2 || $$self2.$$.bound[$$self2.$$.props["nodes"]])) {
      console.warn("<Svelvet> was created without expected prop 'nodes'");
    }
    if (edges === void 0 && !("edges" in $$props2 || $$self2.$$.bound[$$self2.$$.props["edges"]])) {
      console.warn("<Svelvet> was created without expected prop 'edges'");
    }
  });
  const writable_props2 = [
    "nodes",
    "edges",
    "width",
    "height",
    "background",
    "nodeLink",
    "nodeCreate",
    "nodeEdit",
    "movement",
    "snap",
    "snapTo",
    "bgColor",
    "initialLocation",
    "initialZoom",
    "minimap",
    "locked",
    "boundary",
    "shareable",
    "deleteNodes"
  ];
  Object.keys($$props2).forEach((key3) => {
    if (!~writable_props2.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<Svelvet> was created with unknown prop '${key3}'`);
  });
  $$self2.$$set = ($$props3) => {
    if ("nodes" in $$props3)
      $$invalidate2(15, nodes = $$props3.nodes);
    if ("edges" in $$props3)
      $$invalidate2(16, edges = $$props3.edges);
    if ("width" in $$props3)
      $$invalidate2(0, width2 = $$props3.width);
    if ("height" in $$props3)
      $$invalidate2(1, height2 = $$props3.height);
    if ("background" in $$props3)
      $$invalidate2(17, background = $$props3.background);
    if ("nodeLink" in $$props3)
      $$invalidate2(18, nodeLink = $$props3.nodeLink);
    if ("nodeCreate" in $$props3)
      $$invalidate2(19, nodeCreate = $$props3.nodeCreate);
    if ("nodeEdit" in $$props3)
      $$invalidate2(20, nodeEdit = $$props3.nodeEdit);
    if ("movement" in $$props3)
      $$invalidate2(21, movement = $$props3.movement);
    if ("snap" in $$props3)
      $$invalidate2(22, snap = $$props3.snap);
    if ("snapTo" in $$props3)
      $$invalidate2(23, snapTo = $$props3.snapTo);
    if ("bgColor" in $$props3)
      $$invalidate2(24, bgColor = $$props3.bgColor);
    if ("initialLocation" in $$props3)
      $$invalidate2(2, initialLocation2 = $$props3.initialLocation);
    if ("initialZoom" in $$props3)
      $$invalidate2(3, initialZoom2 = $$props3.initialZoom);
    if ("minimap" in $$props3)
      $$invalidate2(4, minimap2 = $$props3.minimap);
    if ("locked" in $$props3)
      $$invalidate2(25, locked = $$props3.locked);
    if ("boundary" in $$props3)
      $$invalidate2(5, boundary2 = $$props3.boundary);
    if ("shareable" in $$props3)
      $$invalidate2(26, shareable2 = $$props3.shareable);
    if ("deleteNodes" in $$props3)
      $$invalidate2(27, deleteNodes = $$props3.deleteNodes);
  };
  $$self2.$capture_state = () => ({
    GraphView: GraphView_default,
    findOrCreateStore,
    onMount,
    nodes,
    edges,
    width: width2,
    height: height2,
    background,
    nodeLink,
    nodeCreate,
    nodeEdit,
    movement,
    snap,
    snapTo,
    bgColor,
    initialLocation: initialLocation2,
    initialZoom: initialZoom2,
    minimap: minimap2,
    locked,
    boundary: boundary2,
    shareable: shareable2,
    deleteNodes,
    key: key2,
    svelvetStore: svelvetStore2,
    widthStore: widthStore2,
    heightStore: heightStore2,
    nodesStore: nodesStore2,
    derivedEdges: derivedEdges2,
    backgroundColor,
    isLocked: isLocked2,
    $widthStore: $widthStore2,
    $heightStore: $heightStore2,
    $backgroundColor
  });
  $$self2.$inject_state = ($$props3) => {
    if ("nodes" in $$props3)
      $$invalidate2(15, nodes = $$props3.nodes);
    if ("edges" in $$props3)
      $$invalidate2(16, edges = $$props3.edges);
    if ("width" in $$props3)
      $$invalidate2(0, width2 = $$props3.width);
    if ("height" in $$props3)
      $$invalidate2(1, height2 = $$props3.height);
    if ("background" in $$props3)
      $$invalidate2(17, background = $$props3.background);
    if ("nodeLink" in $$props3)
      $$invalidate2(18, nodeLink = $$props3.nodeLink);
    if ("nodeCreate" in $$props3)
      $$invalidate2(19, nodeCreate = $$props3.nodeCreate);
    if ("nodeEdit" in $$props3)
      $$invalidate2(20, nodeEdit = $$props3.nodeEdit);
    if ("movement" in $$props3)
      $$invalidate2(21, movement = $$props3.movement);
    if ("snap" in $$props3)
      $$invalidate2(22, snap = $$props3.snap);
    if ("snapTo" in $$props3)
      $$invalidate2(23, snapTo = $$props3.snapTo);
    if ("bgColor" in $$props3)
      $$invalidate2(24, bgColor = $$props3.bgColor);
    if ("initialLocation" in $$props3)
      $$invalidate2(2, initialLocation2 = $$props3.initialLocation);
    if ("initialZoom" in $$props3)
      $$invalidate2(3, initialZoom2 = $$props3.initialZoom);
    if ("minimap" in $$props3)
      $$invalidate2(4, minimap2 = $$props3.minimap);
    if ("locked" in $$props3)
      $$invalidate2(25, locked = $$props3.locked);
    if ("boundary" in $$props3)
      $$invalidate2(5, boundary2 = $$props3.boundary);
    if ("shareable" in $$props3)
      $$invalidate2(26, shareable2 = $$props3.shareable);
    if ("deleteNodes" in $$props3)
      $$invalidate2(27, deleteNodes = $$props3.deleteNodes);
  };
  if ($$props2 && "$$inject" in $$props2) {
    $$self2.$inject_state($$props2.$$inject);
  }
  return [
    width2,
    height2,
    initialLocation2,
    initialZoom2,
    minimap2,
    boundary2,
    $widthStore2,
    $heightStore2,
    $backgroundColor,
    key2,
    widthStore2,
    heightStore2,
    nodesStore2,
    derivedEdges2,
    backgroundColor,
    nodes,
    edges,
    background,
    nodeLink,
    nodeCreate,
    nodeEdit,
    movement,
    snap,
    snapTo,
    bgColor,
    locked,
    shareable2,
    deleteNodes
  ];
}
var Svelvet = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance16,
      create_fragment16,
      safe_not_equal,
      {
        nodes: 15,
        edges: 16,
        width: 0,
        height: 1,
        background: 17,
        nodeLink: 18,
        nodeCreate: 19,
        nodeEdit: 20,
        movement: 21,
        snap: 22,
        snapTo: 23,
        bgColor: 24,
        initialLocation: 2,
        initialZoom: 3,
        minimap: 4,
        locked: 25,
        boundary: 5,
        shareable: 26,
        deleteNodes: 27
      },
      add_css11
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Svelvet",
      options,
      id: create_fragment16.name
    });
  }
  get nodes() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodes(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get edges() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set edges(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeLink() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeLink(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeCreate() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeCreate(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeEdit() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeEdit(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get movement() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set movement(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get snap() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set snap(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get snapTo() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set snapTo(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialLocation() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialLocation(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialZoom() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialZoom(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minimap() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minimap(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get locked() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locked(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get boundary() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set boundary(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shareable() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shareable(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deleteNodes() {
    throw new Error("<Svelvet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deleteNodes(value2) {
    throw new Error("<Svelvet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Svelvet_default = Svelvet;

// node_modules/svelvet/index.js
var svelvet_default = Svelvet_default;
export {
  Position,
  svelvet_default as default
};
//# sourceMappingURL=svelvet.js.map
