import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  append_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  check_outros,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  group_outros,
  init,
  insert_dev,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  safe_not_equal,
  space,
  text,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-4NZVM4V3.js";
import "./chunk-HYZYPRER.js";

// node_modules/svelte-infinite-loading/src/Spinner.svelte
var file = "node_modules/svelte-infinite-loading/src/Spinner.svelte";
function add_css(target) {
  append_styles(target, "svelte-10h86fq", ".loading-wave-dots.svelte-10h86fq.svelte-10h86fq{position:relative}.loading-wave-dots.svelte-10h86fq .wave-item.svelte-10h86fq{position:absolute;top:50%;left:50%;display:inline-block;margin-top:-4px;width:8px;height:8px;border-radius:50%;-webkit-animation:svelte-10h86fq-loading-wave-dots linear 2.8s infinite;animation:svelte-10h86fq-loading-wave-dots linear 2.8s infinite}.loading-wave-dots.svelte-10h86fq .wave-item.svelte-10h86fq:first-child{margin-left:-36px}.loading-wave-dots.svelte-10h86fq .wave-item.svelte-10h86fq:nth-child(2){margin-left:-20px;-webkit-animation-delay:0.14s;animation-delay:0.14s}.loading-wave-dots.svelte-10h86fq .wave-item.svelte-10h86fq:nth-child(3){margin-left:-4px;-webkit-animation-delay:0.28s;animation-delay:0.28s}.loading-wave-dots.svelte-10h86fq .wave-item.svelte-10h86fq:nth-child(4){margin-left:12px;-webkit-animation-delay:0.42s;animation-delay:0.42s}.loading-wave-dots.svelte-10h86fq .wave-item.svelte-10h86fq:last-child{margin-left:28px;-webkit-animation-delay:0.56s;animation-delay:0.56s}@-webkit-keyframes svelte-10h86fq-loading-wave-dots{0%{-webkit-transform:translateY(0);transform:translateY(0);background:#bbb}10%{-webkit-transform:translateY(-6px);transform:translateY(-6px);background:#999}20%{-webkit-transform:translateY(0);transform:translateY(0);background:#bbb}100%{-webkit-transform:translateY(0);transform:translateY(0);background:#bbb}}@keyframes svelte-10h86fq-loading-wave-dots{0%{-webkit-transform:translateY(0);transform:translateY(0);background:#bbb}10%{-webkit-transform:translateY(-6px);transform:translateY(-6px);background:#999}20%{-webkit-transform:translateY(0);transform:translateY(0);background:#bbb}100%{-webkit-transform:translateY(0);transform:translateY(0);background:#bbb}}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq{width:5px;height:5px;-webkit-animation:svelte-10h86fq-loading-circles linear .75s infinite;animation:svelte-10h86fq-loading-circles linear .75s infinite}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:first-child{margin-top:-14.5px;margin-left:-2.5px}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:nth-child(2){margin-top:-11.26px;margin-left:6.26px}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:nth-child(3){margin-top:-2.5px;margin-left:9.5px}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:nth-child(4){margin-top:6.26px;margin-left:6.26px}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:nth-child(5){margin-top:9.5px;margin-left:-2.5px}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:nth-child(6){margin-top:6.26px;margin-left:-11.26px}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:nth-child(7){margin-top:-2.5px;margin-left:-14.5px}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:last-child{margin-top:-11.26px;margin-left:-11.26px}@-webkit-keyframes svelte-10h86fq-loading-circles{0%{background:#dfdfdf}90%{background:#505050}100%{background:#dfdfdf}}@keyframes svelte-10h86fq-loading-circles{0%{background:#dfdfdf}90%{background:#505050}100%{background:#dfdfdf}}.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq{background:#666;-webkit-animation:svelte-10h86fq-loading-bubbles linear .75s infinite;animation:svelte-10h86fq-loading-bubbles linear .75s infinite}.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:first-child{margin-top:-12.5px;margin-left:-0.5px}.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:nth-child(2){margin-top:-9.26px;margin-left:8.26px}.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:nth-child(3){margin-top:-0.5px;margin-left:11.5px}.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:nth-child(4){margin-top:8.26px;margin-left:8.26px}.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:nth-child(5){margin-top:11.5px;margin-left:-0.5px}.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:nth-child(6){margin-top:8.26px;margin-left:-9.26px}.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:nth-child(7){margin-top:-0.5px;margin-left:-12.5px}.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:last-child{margin-top:-9.26px;margin-left:-9.26px}@-webkit-keyframes svelte-10h86fq-loading-bubbles{0%{width:1px;height:1px;box-shadow:0 0 0 3px #666}90%{width:1px;height:1px;box-shadow:0 0 0 0 #666}100%{width:1px;height:1px;box-shadow:0 0 0 3px #666}}@keyframes svelte-10h86fq-loading-bubbles{0%{width:1px;height:1px;box-shadow:0 0 0 3px #666}90%{width:1px;height:1px;box-shadow:0 0 0 0 #666}100%{width:1px;height:1px;box-shadow:0 0 0 3px #666}}.loading-default.svelte-10h86fq.svelte-10h86fq{position:relative;border:1px solid #999;-webkit-animation:svelte-10h86fq-loading-rotating ease 1.5s infinite;animation:svelte-10h86fq-loading-rotating ease 1.5s infinite}.loading-default.svelte-10h86fq.svelte-10h86fq:before{content:'';position:absolute;display:block;top:0;left:50%;margin-top:-3px;margin-left:-3px;width:6px;height:6px;background-color:#999;border-radius:50%}.loading-spiral.svelte-10h86fq.svelte-10h86fq{border:2px solid #777;border-right-color:transparent;-webkit-animation:svelte-10h86fq-loading-rotating linear .85s infinite;animation:svelte-10h86fq-loading-rotating linear .85s infinite}@-webkit-keyframes svelte-10h86fq-loading-rotating{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes svelte-10h86fq-loading-rotating{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.loading-bubbles.svelte-10h86fq.svelte-10h86fq,.loading-circles.svelte-10h86fq.svelte-10h86fq{position:relative}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq,.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq{position:absolute;top:50%;left:50%;display:inline-block;border-radius:50%}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:nth-child(2),.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:nth-child(2){-webkit-animation-delay:0.093s;animation-delay:0.093s}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:nth-child(3),.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:nth-child(3){-webkit-animation-delay:0.186s;animation-delay:0.186s}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:nth-child(4),.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:nth-child(4){-webkit-animation-delay:0.279s;animation-delay:0.279s}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:nth-child(5),.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:nth-child(5){-webkit-animation-delay:0.372s;animation-delay:0.372s}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:nth-child(6),.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:nth-child(6){-webkit-animation-delay:0.465s;animation-delay:0.465s}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:nth-child(7),.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:nth-child(7){-webkit-animation-delay:0.558s;animation-delay:0.558s}.loading-circles.svelte-10h86fq .circle-item.svelte-10h86fq:last-child,.loading-bubbles.svelte-10h86fq .bubble-item.svelte-10h86fq:last-child{-webkit-animation-delay:0.651s;animation-delay:0.651s}.loading-bubbles.svelte-10h86fq.svelte-10h86fq,.loading-circles.svelte-10h86fq.svelte-10h86fq,.loading-spiral.svelte-10h86fq.svelte-10h86fq,.loading-wave-dots.svelte-10h86fq.svelte-10h86fq,.loading-default.svelte-10h86fq.svelte-10h86fq{display:inline-block;margin:5px 0;width:28px;height:28px;font-size:28px;line-height:28px;border-radius:50%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}
function create_else_block(ctx) {
  let i;
  const block = {
    c: function create() {
      i = element("i");
      attr_dev(i, "class", "loading-default svelte-10h86fq");
      add_location(i, file, 51, 1, 1184);
    },
    m: function mount(target, anchor) {
      insert_dev(target, i, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(49:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let span5;
  let span0;
  let t0;
  let span1;
  let t1;
  let span2;
  let t2;
  let span3;
  let t3;
  let span4;
  const block = {
    c: function create() {
      span5 = element("span");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = space();
      span2 = element("span");
      t2 = space();
      span3 = element("span");
      t3 = space();
      span4 = element("span");
      attr_dev(span0, "class", "wave-item svelte-10h86fq");
      add_location(span0, file, 41, 2, 978);
      attr_dev(span1, "class", "wave-item svelte-10h86fq");
      add_location(span1, file, 42, 2, 1012);
      attr_dev(span2, "class", "wave-item svelte-10h86fq");
      add_location(span2, file, 43, 2, 1046);
      attr_dev(span3, "class", "wave-item svelte-10h86fq");
      add_location(span3, file, 44, 2, 1080);
      attr_dev(span4, "class", "wave-item svelte-10h86fq");
      add_location(span4, file, 45, 2, 1114);
      attr_dev(span5, "class", "loading-wave-dots svelte-10h86fq");
      add_location(span5, file, 40, 1, 943);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span5, anchor);
      append_dev(span5, span0);
      append_dev(span5, t0);
      append_dev(span5, span1);
      append_dev(span5, t1);
      append_dev(span5, span2);
      append_dev(span5, t2);
      append_dev(span5, span3);
      append_dev(span5, t3);
      append_dev(span5, span4);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span5);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(38:33) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let i;
  const block = {
    c: function create() {
      i = element("i");
      attr_dev(i, "class", "loading-spiral svelte-10h86fq");
      add_location(i, file, 35, 1, 856);
    },
    m: function mount(target, anchor) {
      insert_dev(target, i, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(33:31) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let span8;
  let span0;
  let t0;
  let span1;
  let t1;
  let span2;
  let t2;
  let span3;
  let t3;
  let span4;
  let t4;
  let span5;
  let t5;
  let span6;
  let t6;
  let span7;
  const block = {
    c: function create() {
      span8 = element("span");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = space();
      span2 = element("span");
      t2 = space();
      span3 = element("span");
      t3 = space();
      span4 = element("span");
      t4 = space();
      span5 = element("span");
      t5 = space();
      span6 = element("span");
      t6 = space();
      span7 = element("span");
      attr_dev(span0, "class", "circle-item svelte-10h86fq");
      add_location(span0, file, 22, 2, 509);
      attr_dev(span1, "class", "circle-item svelte-10h86fq");
      add_location(span1, file, 23, 2, 545);
      attr_dev(span2, "class", "circle-item svelte-10h86fq");
      add_location(span2, file, 24, 2, 581);
      attr_dev(span3, "class", "circle-item svelte-10h86fq");
      add_location(span3, file, 25, 2, 617);
      attr_dev(span4, "class", "circle-item svelte-10h86fq");
      add_location(span4, file, 26, 2, 653);
      attr_dev(span5, "class", "circle-item svelte-10h86fq");
      add_location(span5, file, 27, 2, 689);
      attr_dev(span6, "class", "circle-item svelte-10h86fq");
      add_location(span6, file, 28, 2, 725);
      attr_dev(span7, "class", "circle-item svelte-10h86fq");
      add_location(span7, file, 29, 2, 761);
      attr_dev(span8, "class", "loading-circles svelte-10h86fq");
      add_location(span8, file, 21, 1, 476);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span8, anchor);
      append_dev(span8, span0);
      append_dev(span8, t0);
      append_dev(span8, span1);
      append_dev(span8, t1);
      append_dev(span8, span2);
      append_dev(span8, t2);
      append_dev(span8, span3);
      append_dev(span8, t3);
      append_dev(span8, span4);
      append_dev(span8, t4);
      append_dev(span8, span5);
      append_dev(span8, t5);
      append_dev(span8, span6);
      append_dev(span8, t6);
      append_dev(span8, span7);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span8);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(19:32) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let span8;
  let span0;
  let t0;
  let span1;
  let t1;
  let span2;
  let t2;
  let span3;
  let t3;
  let span4;
  let t4;
  let span5;
  let t5;
  let span6;
  let t6;
  let span7;
  const block = {
    c: function create() {
      span8 = element("span");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = space();
      span2 = element("span");
      t2 = space();
      span3 = element("span");
      t3 = space();
      span4 = element("span");
      t4 = space();
      span5 = element("span");
      t5 = space();
      span6 = element("span");
      t6 = space();
      span7 = element("span");
      attr_dev(span0, "class", "bubble-item svelte-10h86fq");
      add_location(span0, file, 8, 2, 127);
      attr_dev(span1, "class", "bubble-item svelte-10h86fq");
      add_location(span1, file, 9, 2, 163);
      attr_dev(span2, "class", "bubble-item svelte-10h86fq");
      add_location(span2, file, 10, 2, 199);
      attr_dev(span3, "class", "bubble-item svelte-10h86fq");
      add_location(span3, file, 11, 2, 235);
      attr_dev(span4, "class", "bubble-item svelte-10h86fq");
      add_location(span4, file, 12, 2, 271);
      attr_dev(span5, "class", "bubble-item svelte-10h86fq");
      add_location(span5, file, 13, 2, 307);
      attr_dev(span6, "class", "bubble-item svelte-10h86fq");
      add_location(span6, file, 14, 2, 343);
      attr_dev(span7, "class", "bubble-item svelte-10h86fq");
      add_location(span7, file, 15, 2, 379);
      attr_dev(span8, "class", "loading-bubbles svelte-10h86fq");
      add_location(span8, file, 7, 1, 94);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span8, anchor);
      append_dev(span8, span0);
      append_dev(span8, t0);
      append_dev(span8, span1);
      append_dev(span8, t1);
      append_dev(span8, span2);
      append_dev(span8, t2);
      append_dev(span8, span3);
      append_dev(span8, t3);
      append_dev(span8, span4);
      append_dev(span8, t4);
      append_dev(span8, span5);
      append_dev(span8, t5);
      append_dev(span8, span6);
      append_dev(span8, t6);
      append_dev(span8, span7);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span8);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(5:0) {#if spinner === 'bubbles'}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (/*spinner*/
    ctx2[0] === "bubbles")
      return create_if_block;
    if (/*spinner*/
    ctx2[0] === "circles")
      return create_if_block_1;
    if (/*spinner*/
    ctx2[0] === "spiral")
      return create_if_block_2;
    if (/*spinner*/
    ctx2[0] === "wavedots")
      return create_if_block_3;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Spinner", slots, []);
  let { spinner = "" } = $$props;
  const writable_props = ["spinner"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Spinner> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("spinner" in $$props2)
      $$invalidate(0, spinner = $$props2.spinner);
  };
  $$self.$capture_state = () => ({ spinner });
  $$self.$inject_state = ($$props2) => {
    if ("spinner" in $$props2)
      $$invalidate(0, spinner = $$props2.spinner);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [spinner];
}
var Spinner = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { spinner: 0 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Spinner",
      options,
      id: create_fragment.name
    });
  }
  get spinner() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spinner(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Spinner_default = Spinner;

// node_modules/svelte-infinite-loading/src/InfiniteLoading.svelte
var { Object: Object_1, console: console_1 } = globals;
var file2 = "node_modules/svelte-infinite-loading/src/InfiniteLoading.svelte";
function add_css2(target) {
  append_styles(target, "svelte-o3w4bf", ".infinite-loading-container.svelte-o3w4bf{clear:both;text-align:center}.btn-try-infinite.svelte-o3w4bf{margin-top:5px;padding:5px 10px;color:#999;font-size:14px;line-height:1;background:transparent;border:1px solid #ccc;border-radius:3px;outline:none;cursor:pointer}.btn-try-infinite.svelte-o3w4bf:not(:active):hover{opacity:0.8}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5maW5pdGVMb2FkaW5nLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEyV0MsMkJBQTJCLGNBQUMsQ0FBQSxBQUMzQixLQUFLLENBQU8sSUFBSSxDQUNoQixVQUFVLENBQUUsTUFBTSxBQUNuQixDQUFBLEFBRUEsaUJBQWlCLGNBQUMsQ0FBQSxBQUNqQixVQUFVLENBQUssR0FBRyxDQUNsQixPQUFPLENBQVEsR0FBRyxDQUFDLElBQUksQ0FDdkIsS0FBSyxDQUFVLElBQUksQ0FDbkIsU0FBUyxDQUFNLElBQUksQ0FDbkIsV0FBVyxDQUFJLENBQUMsQ0FDaEIsVUFBVSxDQUFLLFdBQVcsQ0FDMUIsTUFBTSxDQUFTLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUM3QixhQUFhLENBQUUsR0FBRyxDQUNsQixPQUFPLENBQVEsSUFBSSxDQUNuQixNQUFNLENBQVMsT0FBTyxBQUN2QixDQUFBLEFBRUEsK0JBQWlCLEtBQUssT0FBTyxDQUFDLE1BQU0sQUFBQyxDQUFBLEFBQ3BDLE9BQU8sQ0FBRSxHQUFHLEFBQ2IsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJJbmZpbml0ZUxvYWRpbmcuc3ZlbHRlIl19 */");
}
var get_error_slot_changes = (dirty) => ({});
var get_error_slot_context = (ctx) => ({ attemptLoad: (
  /*attemptLoad*/
  ctx[7]
) });
var get_noMore_slot_changes = (dirty) => ({});
var get_noMore_slot_context = (ctx) => ({});
var get_noResults_slot_changes = (dirty) => ({});
var get_noResults_slot_context = (ctx) => ({});
var get_spinner_slot_changes = (dirty) => ({ isFirstLoad: dirty & /*isFirstLoad*/
2 });
var get_spinner_slot_context = (ctx) => ({ isFirstLoad: (
  /*isFirstLoad*/
  ctx[1]
) });
function create_if_block_32(ctx) {
  let div;
  let current;
  const spinner_slot_template = (
    /*#slots*/
    ctx[15].spinner
  );
  const spinner_slot = create_slot(
    spinner_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_spinner_slot_context
  );
  const spinner_slot_or_fallback = spinner_slot || fallback_block_3(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (spinner_slot_or_fallback)
        spinner_slot_or_fallback.c();
      attr_dev(div, "class", "infinite-status-prompt");
      add_location(div, file2, 326, 2, 8147);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (spinner_slot_or_fallback) {
        spinner_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (spinner_slot) {
        if (spinner_slot.p && (!current || dirty & /*$$scope, isFirstLoad*/
        16386)) {
          update_slot_base(
            spinner_slot,
            spinner_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              spinner_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_spinner_slot_changes
            ),
            get_spinner_slot_context
          );
        }
      } else {
        if (spinner_slot_or_fallback && spinner_slot_or_fallback.p && (!current || dirty & /*spinner*/
        1)) {
          spinner_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(spinner_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(spinner_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (spinner_slot_or_fallback)
        spinner_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(326:1) {#if showSpinner}",
    ctx
  });
  return block;
}
function fallback_block_3(ctx) {
  let spinner_1;
  let current;
  spinner_1 = new Spinner_default({
    props: { spinner: (
      /*spinner*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(spinner_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(spinner_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const spinner_1_changes = {};
      if (dirty & /*spinner*/
      1)
        spinner_1_changes.spinner = /*spinner*/
        ctx2[0];
      spinner_1.$set(spinner_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(spinner_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(spinner_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(spinner_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(328:38)      ",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let div;
  let current;
  const noResults_slot_template = (
    /*#slots*/
    ctx[15].noResults
  );
  const noResults_slot = create_slot(
    noResults_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_noResults_slot_context
  );
  const noResults_slot_or_fallback = noResults_slot || fallback_block_2(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (noResults_slot_or_fallback)
        noResults_slot_or_fallback.c();
      attr_dev(div, "class", "infinite-status-prompt");
      add_location(div, file2, 334, 2, 8300);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (noResults_slot_or_fallback) {
        noResults_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (noResults_slot) {
        if (noResults_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            noResults_slot,
            noResults_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              noResults_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_noResults_slot_changes
            ),
            get_noResults_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(noResults_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(noResults_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (noResults_slot_or_fallback)
        noResults_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(334:1) {#if showNoResults}",
    ctx
  });
  return block;
}
function fallback_block_2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("No results :(");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(336:26)      No results :(    ",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let div;
  let current;
  const noMore_slot_template = (
    /*#slots*/
    ctx[15].noMore
  );
  const noMore_slot = create_slot(
    noMore_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_noMore_slot_context
  );
  const noMore_slot_or_fallback = noMore_slot || fallback_block_1(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (noMore_slot_or_fallback)
        noMore_slot_or_fallback.c();
      attr_dev(div, "class", "infinite-status-prompt");
      add_location(div, file2, 342, 2, 8430);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (noMore_slot_or_fallback) {
        noMore_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (noMore_slot) {
        if (noMore_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            noMore_slot,
            noMore_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              noMore_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_noMore_slot_changes
            ),
            get_noMore_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(noMore_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(noMore_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (noMore_slot_or_fallback)
        noMore_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(342:1) {#if showNoMore}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("No more data :)");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(344:23)      No more data :)    ",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let current;
  const error_slot_template = (
    /*#slots*/
    ctx[15].error
  );
  const error_slot = create_slot(
    error_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_error_slot_context
  );
  const error_slot_or_fallback = error_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (error_slot_or_fallback)
        error_slot_or_fallback.c();
      attr_dev(div, "class", "infinite-status-prompt");
      add_location(div, file2, 350, 2, 8558);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (error_slot_or_fallback) {
        error_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (error_slot) {
        if (error_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            error_slot,
            error_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              error_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_error_slot_changes
            ),
            get_error_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (error_slot_or_fallback)
        error_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(350:1) {#if showError}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t0;
  let br;
  let t1;
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      t0 = text("Oops, something went wrong :(\n				");
      br = element("br");
      t1 = space();
      button = element("button");
      button.textContent = "Retry";
      add_location(br, file2, 353, 4, 8670);
      attr_dev(button, "class", "btn-try-infinite svelte-o3w4bf");
      add_location(button, file2, 354, 4, 8679);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, br, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*attemptLoad*/
          ctx[7],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(br);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(352:36)      Oops, something went wrong :(     ",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let current;
  let if_block0 = (
    /*showSpinner*/
    ctx[6] && create_if_block_32(ctx)
  );
  let if_block1 = (
    /*showNoResults*/
    ctx[4] && create_if_block_22(ctx)
  );
  let if_block2 = (
    /*showNoMore*/
    ctx[3] && create_if_block_12(ctx)
  );
  let if_block3 = (
    /*showError*/
    ctx[5] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      attr_dev(div, "class", "infinite-loading-container svelte-o3w4bf");
      add_location(div, file2, 324, 0, 8061);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append_dev(div, t2);
      if (if_block3)
        if_block3.m(div, null);
      ctx[16](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (/*showSpinner*/
      ctx2[6]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*showSpinner*/
          64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_32(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (/*showNoResults*/
      ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*showNoResults*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_22(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (/*showNoMore*/
      ctx2[3]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*showNoMore*/
          8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_12(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (/*showError*/
      ctx2[5]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*showError*/
          32) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block2(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      ctx[16](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var THROTTLE_LIMIT = 50;
var LOOP_CHECK_TIMEOUT = 1e3;
var LOOP_CHECK_MAX_CALLS = 10;
var ERROR_INFINITE_LOOP = [
  `executed the callback function more than ${LOOP_CHECK_MAX_CALLS} times for a short time, it looks like searched a wrong scroll wrapper that doest not has fixed height or maximum height, please check it. If you want to force to set a element as scroll wrapper rather than automatic searching, you can do this:`,
  "<!-- add a special attribute for the real scroll wrapper (can also be data-infinite-wrapper) -->",
  "<div infinite-wrapper>",
  "  ...",
  "  <!-- set forceUseInfiniteWrapper -->",
  "  <InfiniteLoading forceUseInfiniteWrapper>",
  "</div>",
  "or",
  '<div class="infinite-wrapper">',
  "  ...",
  "  <!-- set forceUseInfiniteWrapper as css selector of the real scroll wrapper -->",
  '  <InfiniteLoading forceUseInfiniteWrapper=".infinite-wrapper" />',
  "</div>"
].join("\n");
var thirdEventArg = (() => {
  let supportsPassive = false;
  try {
    const opts = Object.defineProperty({}, "passive", {
      get() {
        supportsPassive = { passive: true };
        return true;
      }
    });
    window.addEventListener("testPassive", null, opts);
    window.removeEventListener("testPassive", null, opts);
  } catch (e) {
  }
  return supportsPassive;
})();
var throttler = {
  timers: [],
  caches: [],
  throttle(fn) {
    if (this.caches.indexOf(fn) === -1) {
      this.caches.push(fn);
      this.timers.push(setTimeout(
        () => {
          fn();
          this.caches.splice(this.caches.indexOf(fn), 1);
          this.timers.shift();
        },
        THROTTLE_LIMIT
      ));
    }
  },
  reset() {
    this.timers.forEach((timer) => {
      clearTimeout(timer);
    });
    this.timers.length = 0;
    this.caches = [];
  }
};
var loopTracker = {
  isChecked: false,
  timer: null,
  times: 0,
  track() {
    this.times += 1;
    clearTimeout(this.timer);
    this.timer = setTimeout(
      () => {
        this.isChecked = true;
      },
      LOOP_CHECK_TIMEOUT
    );
    if (this.times > LOOP_CHECK_MAX_CALLS) {
      console.error(ERROR_INFINITE_LOOP);
      this.isChecked = true;
    }
  }
};
var scrollBarStorage = {
  key: "_infiniteScrollHeight",
  getScrollElement(element2) {
    return element2 === window ? document.documentElement : element2;
  },
  save(element2) {
    const target = this.getScrollElement(element2);
    target[this.key] = target.scrollHeight;
  },
  restore(element2) {
    const target = this.getScrollElement(element2);
    if (typeof target[this.key] === "number") {
      target.scrollTop = target.scrollHeight - target[this.key] + target.scrollTop;
    }
    this.remove(target);
  },
  remove(element2) {
    if (element2[this.key] !== void 0) {
      delete element2[this.key];
    }
  }
};
function isVisible(element2) {
  return element2 && element2.offsetWidth + element2.offsetHeight > 0;
}
function instance2($$self, $$props, $$invalidate) {
  let showSpinner;
  let showError;
  let showNoResults;
  let showNoMore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InfiniteLoading", slots, ["spinner", "noResults", "noMore", "error"]);
  const dispatch = createEventDispatcher();
  const STATUS = {
    READY: 0,
    LOADING: 1,
    COMPLETE: 2,
    ERROR: 3
  };
  let { distance = 100 } = $$props;
  let { spinner = "default" } = $$props;
  let { direction = "bottom" } = $$props;
  let { forceUseInfiniteWrapper = false } = $$props;
  let { identifier = +new Date() } = $$props;
  let isFirstLoad = true;
  let status = STATUS.READY;
  let mounted = false;
  let thisElement;
  let scrollParent;
  const stateChanger = {
    loaded: async () => {
      $$invalidate(1, isFirstLoad = false);
      if (direction === "top") {
        await tick();
        scrollBarStorage.restore(scrollParent);
      }
      if (status === STATUS.LOADING) {
        await tick();
        await attemptLoad(true);
      }
    },
    complete: async () => {
      $$invalidate(12, status = STATUS.COMPLETE);
      await tick();
      scrollParent.removeEventListener("scroll", scrollHandler, thirdEventArg);
    },
    reset: async () => {
      $$invalidate(12, status = STATUS.READY);
      $$invalidate(1, isFirstLoad = true);
      scrollBarStorage.remove(scrollParent);
      scrollParent.addEventListener("scroll", scrollHandler, thirdEventArg);
      setTimeout(
        () => {
          throttler.reset();
          scrollHandler();
        },
        1
      );
    },
    error: () => {
      $$invalidate(12, status = STATUS.ERROR);
      throttler.reset();
    }
  };
  function scrollHandler(event) {
    if (status === STATUS.READY) {
      if (event && event.constructor === Event && isVisible(thisElement)) {
        throttler.throttle(attemptLoad);
      } else {
        attemptLoad();
      }
    }
  }
  async function attemptLoad(isContinuousCall) {
    if (status !== STATUS.COMPLETE && isVisible(thisElement) && getCurrentDistance() <= distance) {
      $$invalidate(12, status = STATUS.LOADING);
      if (direction === "top") {
        await tick();
        scrollBarStorage.save(scrollParent);
      }
      dispatch("infinite", stateChanger);
      if (isContinuousCall && !forceUseInfiniteWrapper && !loopTracker.isChecked) {
        loopTracker.track();
      }
    } else if (status === STATUS.LOADING) {
      $$invalidate(12, status = STATUS.READY);
    }
  }
  function getCurrentDistance() {
    let distance2;
    if (direction === "top") {
      distance2 = typeof scrollParent.scrollTop === "number" ? scrollParent.scrollTop : scrollParent.pageYOffset;
    } else {
      const infiniteElementOffsetTopFromBottom = thisElement.getBoundingClientRect().top;
      const scrollElementOffsetTopFromBottom = scrollParent === window ? window.innerHeight : scrollParent.getBoundingClientRect().bottom;
      distance2 = infiniteElementOffsetTopFromBottom - scrollElementOffsetTopFromBottom;
    }
    return distance2;
  }
  function getScrollParent(element2 = thisElement) {
    let result;
    if (typeof forceUseInfiniteWrapper === "string") {
      result = document.querySelector(forceUseInfiniteWrapper);
    }
    if (!result) {
      if (element2.tagName === "BODY") {
        result = window;
      } else if (!forceUseInfiniteWrapper && ["scroll", "auto"].indexOf(getComputedStyle(element2).overflowY) > -1) {
        result = element2;
      } else if (element2.hasAttribute("infinite-wrapper") || element2.hasAttribute("data-infinite-wrapper")) {
        result = element2;
      }
    }
    return result || getScrollParent(element2.parentNode);
  }
  function updateScrollParent() {
    if (mounted)
      scrollParent = getScrollParent();
  }
  function identifierUpdated() {
    if (mounted)
      stateChanger.reset();
  }
  onMount(async () => {
    $$invalidate(13, mounted = true);
    setTimeout(
      () => {
        scrollHandler();
        scrollParent.addEventListener("scroll", scrollHandler, thirdEventArg);
      },
      1
    );
  });
  onDestroy(() => {
    if (mounted && status !== STATUS.COMPLETE) {
      throttler.reset();
      scrollBarStorage.remove(scrollParent);
      scrollParent.removeEventListener("scroll", scrollHandler, thirdEventArg);
    }
  });
  const writable_props = ["distance", "spinner", "direction", "forceUseInfiniteWrapper", "identifier"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<InfiniteLoading> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      thisElement = $$value;
      $$invalidate(2, thisElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("distance" in $$props2)
      $$invalidate(8, distance = $$props2.distance);
    if ("spinner" in $$props2)
      $$invalidate(0, spinner = $$props2.spinner);
    if ("direction" in $$props2)
      $$invalidate(9, direction = $$props2.direction);
    if ("forceUseInfiniteWrapper" in $$props2)
      $$invalidate(10, forceUseInfiniteWrapper = $$props2.forceUseInfiniteWrapper);
    if ("identifier" in $$props2)
      $$invalidate(11, identifier = $$props2.identifier);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    THROTTLE_LIMIT,
    LOOP_CHECK_TIMEOUT,
    LOOP_CHECK_MAX_CALLS,
    ERROR_INFINITE_LOOP,
    thirdEventArg,
    throttler,
    loopTracker,
    scrollBarStorage,
    isVisible,
    onMount,
    onDestroy,
    tick,
    createEventDispatcher,
    Spinner: Spinner_default,
    dispatch,
    STATUS,
    distance,
    spinner,
    direction,
    forceUseInfiniteWrapper,
    identifier,
    isFirstLoad,
    status,
    mounted,
    thisElement,
    scrollParent,
    stateChanger,
    scrollHandler,
    attemptLoad,
    getCurrentDistance,
    getScrollParent,
    updateScrollParent,
    identifierUpdated,
    showNoMore,
    showNoResults,
    showError,
    showSpinner
  });
  $$self.$inject_state = ($$props2) => {
    if ("distance" in $$props2)
      $$invalidate(8, distance = $$props2.distance);
    if ("spinner" in $$props2)
      $$invalidate(0, spinner = $$props2.spinner);
    if ("direction" in $$props2)
      $$invalidate(9, direction = $$props2.direction);
    if ("forceUseInfiniteWrapper" in $$props2)
      $$invalidate(10, forceUseInfiniteWrapper = $$props2.forceUseInfiniteWrapper);
    if ("identifier" in $$props2)
      $$invalidate(11, identifier = $$props2.identifier);
    if ("isFirstLoad" in $$props2)
      $$invalidate(1, isFirstLoad = $$props2.isFirstLoad);
    if ("status" in $$props2)
      $$invalidate(12, status = $$props2.status);
    if ("mounted" in $$props2)
      $$invalidate(13, mounted = $$props2.mounted);
    if ("thisElement" in $$props2)
      $$invalidate(2, thisElement = $$props2.thisElement);
    if ("scrollParent" in $$props2)
      scrollParent = $$props2.scrollParent;
    if ("showNoMore" in $$props2)
      $$invalidate(3, showNoMore = $$props2.showNoMore);
    if ("showNoResults" in $$props2)
      $$invalidate(4, showNoResults = $$props2.showNoResults);
    if ("showError" in $$props2)
      $$invalidate(5, showError = $$props2.showError);
    if ("showSpinner" in $$props2)
      $$invalidate(6, showSpinner = $$props2.showSpinner);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*status*/
    4096) {
      $:
        $$invalidate(6, showSpinner = status === STATUS.LOADING);
    }
    if ($$self.$$.dirty & /*status*/
    4096) {
      $:
        $$invalidate(5, showError = status === STATUS.ERROR);
    }
    if ($$self.$$.dirty & /*status, isFirstLoad*/
    4098) {
      $:
        $$invalidate(4, showNoResults = status === STATUS.COMPLETE && isFirstLoad);
    }
    if ($$self.$$.dirty & /*status, isFirstLoad*/
    4098) {
      $:
        $$invalidate(3, showNoMore = status === STATUS.COMPLETE && !isFirstLoad);
    }
    if ($$self.$$.dirty & /*forceUseInfiniteWrapper, mounted*/
    9216) {
      $:
        forceUseInfiniteWrapper, mounted, updateScrollParent();
    }
    if ($$self.$$.dirty & /*identifier, mounted*/
    10240) {
      $:
        identifier, mounted, identifierUpdated();
    }
  };
  return [
    spinner,
    isFirstLoad,
    thisElement,
    showNoMore,
    showNoResults,
    showError,
    showSpinner,
    attemptLoad,
    distance,
    direction,
    forceUseInfiniteWrapper,
    identifier,
    status,
    mounted,
    $$scope,
    slots,
    div_binding
  ];
}
var InfiniteLoading = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        distance: 8,
        spinner: 0,
        direction: 9,
        forceUseInfiniteWrapper: 10,
        identifier: 11
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InfiniteLoading",
      options,
      id: create_fragment2.name
    });
  }
  get distance() {
    throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set distance(value) {
    throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spinner() {
    throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spinner(value) {
    throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forceUseInfiniteWrapper() {
    throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forceUseInfiniteWrapper(value) {
    throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get identifier() {
    throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set identifier(value) {
    throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InfiniteLoading_default = InfiniteLoading;
export {
  InfiniteLoading_default as default
};
//# sourceMappingURL=svelte-infinite-loading.js.map
