use super::lnd::lnrpc;
/// This is part of public interface so it's re-exported.
pub use super::tonic_lnd_error::ConnectError;
use super::tonic_lnd_error::InternalConnectError;
use std::convert::TryInto;
use std::path::{Path, PathBuf};

#[cfg(feature = "tracing")]
use tracing;

/// The client returned by `connect` function
///
/// This is a convenience type which you most likely want to use instead of raw client.
pub type Client = lnrpc::lightning_client::LightningClient<
    tonic::codegen::InterceptedService<tonic::transport::Channel, MacaroonInterceptor>,
>;

/// [`tonic::Status`] is re-exported as `Error` for convenience.
pub type Error = tonic::Status;

macro_rules! try_map_err {
    ($result:expr, $mapfn:expr) => {
        match $result {
            Ok(value) => value,
            Err(error) => return Err($mapfn(error).into()),
        }
    };
}

/// Messages and other types generated by `tonic`/`prost`
///
/// This is the go-to module you will need to look in to find documentation on various message
/// types. However it may be better to start from methods on the [`LightningClient`](rpc::lightning_client::LightningClient) type.
// pub mod rpc {
//     tonic::include_proto!("lnrpc");
// }

/// Supplies requests with macaroon
#[derive(Clone)]
pub struct MacaroonInterceptor {
    macaroon: String,
}

impl tonic::service::Interceptor for MacaroonInterceptor {
    fn call(&mut self, mut request: tonic::Request<()>) -> Result<tonic::Request<()>, Error> {
        request.metadata_mut().insert(
            "macaroon",
            tonic::metadata::MetadataValue::from_str(&self.macaroon)
                .expect("hex produced non-ascii"),
        );
        Ok(request)
    }
}

async fn load_macaroon(
    path: impl AsRef<Path> + Into<PathBuf>,
) -> Result<String, InternalConnectError> {
    let macaroon =
        rocket::tokio::fs::read(&path)
            .await
            .map_err(|error| InternalConnectError::ReadFile {
                file: path.into(),
                error,
            })?;
    Ok(hex::encode(&macaroon))
}

/// Connects to LND using given address and credentials
///
/// This function does all required processing of the cert file and macaroon file, so that you
/// don't have to. The address must begin with "https://", though.
///
/// This is considered the recommended way to connect to LND. An alternative function to use
/// already-read certificate or macaroon data is currently **not** provided to discourage such use.
/// LND occasionally changes that data which would lead to errors and in turn in worse application.
///
/// If you have a motivating use case for use of direct data feel free to open an issue and
/// explain.
#[cfg_attr(feature = "tracing", tracing::instrument(name = "Connecting to LND"))]
pub async fn make_connection<A, CP, MP>(
    address: A,
    cert_file: CP,
    macaroon_file: MP,
) -> Result<(tonic::transport::Channel, Option<MacaroonInterceptor>), ConnectError>
where
    A: TryInto<tonic::transport::Endpoint> + std::fmt::Debug + ToString,
    <A as TryInto<tonic::transport::Endpoint>>::Error: std::error::Error + Send + Sync + 'static,
    CP: AsRef<Path> + Into<PathBuf> + std::fmt::Debug,
    MP: AsRef<Path> + Into<PathBuf> + std::fmt::Debug,
{
    let address_str = address.to_string();
    let conn = try_map_err!(address.try_into(), |error| {
        InternalConnectError::InvalidAddress {
            address: address_str.clone(),
            error: Box::new(error),
        }
    })
    .tls_config(tls::config(cert_file).await?)
    .map_err(InternalConnectError::TlsConfig)?
    .connect()
    .await
    .map_err(|error| InternalConnectError::Connect {
        address: address_str,
        error,
    })?;

    // let macaroon = load_macaroon(macaroon_file).await?;

    // let interceptor = MacaroonInterceptor { macaroon };

    // Ok(lnrpc::lightning_client::LightningClient::with_interceptor(
    //     conn,
    //     interceptor,
    // ))
    Ok((conn, None))
}

mod tls {
    use super::super::tonic_lnd_error::{ConnectError, InternalConnectError};
    use rustls::{Certificate, RootCertStore, ServerCertVerified, TLSError};
    use std::path::{Path, PathBuf};
    use webpki::DNSNameRef;

    pub(crate) async fn config(
        path: impl AsRef<Path> + Into<PathBuf>,
    ) -> Result<tonic::transport::ClientTlsConfig, ConnectError> {
        let mut tls_config = rustls::ClientConfig::new();
        tls_config
            .dangerous()
            .set_certificate_verifier(std::sync::Arc::new(CertVerifier::load(path).await?));
        tls_config.set_protocols(&["h2".into()]);
        Ok(tonic::transport::ClientTlsConfig::new().rustls_client_config(tls_config))
    }

    pub(crate) struct CertVerifier {
        certs: Vec<Vec<u8>>,
    }

    impl CertVerifier {
        pub(crate) async fn load(
            path: impl AsRef<Path> + Into<PathBuf>,
        ) -> Result<Self, InternalConnectError> {
            let contents = try_map_err!(rocket::tokio::fs::read(&path).await, |error| {
                InternalConnectError::ReadFile {
                    file: path.into(),
                    error,
                }
            });
            let mut reader = &*contents;

            let certs = try_map_err!(rustls_pemfile::certs(&mut reader), |error| {
                InternalConnectError::ParseCert {
                    file: path.into(),
                    error,
                }
            });

            #[cfg(feature = "tracing")]
            {
                tracing::debug!("Certificates loaded (Count: {})", certs.len());
            }

            Ok(CertVerifier { certs: certs })
        }
    }

    impl rustls::ServerCertVerifier for CertVerifier {
        fn verify_server_cert(
            &self,
            _roots: &RootCertStore,
            presented_certs: &[Certificate],
            _dns_name: DNSNameRef<'_>,
            _ocsp_response: &[u8],
        ) -> Result<ServerCertVerified, TLSError> {
            if self.certs.len() != presented_certs.len() {
                return Err(TLSError::General(format!(
                    "Mismatched number of certificates (Expected: {}, Presented: {})",
                    self.certs.len(),
                    presented_certs.len()
                )));
            }

            for (c, p) in self.certs.iter().zip(presented_certs.iter()) {
                if *p.0 != **c {
                    return Err(TLSError::General(format!(
                        "Server certificates do not match ours"
                    )));
                } else {
                    #[cfg(feature = "tracing")]
                    {
                        tracing::trace!("Confirmed certificate match");
                    }
                }
            }

            Ok(ServerCertVerified::assertion())
        }
    }
}
